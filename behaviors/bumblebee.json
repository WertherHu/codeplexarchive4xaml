{
  "ProjectName": "bumblebee",
  "Title": "Bumblebee",
  "Description": "Bumblebee is an Artificial Bee Colony (ABC) algorithm developed in F#. The algorithm is a randomized search method that mimics the behavior of bee hives: it dispatches \"bees\" to search for new solutions or explore the neighborhood of known solutions, and allocates new searches based on the quality of the results returned so far.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><b>Project Description</b><br />Bumblebee is an Artificial Bee Colony &#40;ABC&#41; algorithm developed in F&#35;. The algorithm is a randomized search method that mimics the behavior of bee hives&#58; it dispatches &#34;bees&#34; to search for new solutions or explore the neighborhood of known solutions, and allocates new searches based on the quality of the results returned so far.<br /><br />The Solver will search for a solution to a problem, defined by 3 functions: <br />\n<ul><li>a generator which returns new solutions, </li>\n<li>a mutator which returns solutions close to an existing solution, </li>\n<li>an evaluator, which evaluates the quality of a solution as a float. </li></ul>\n<br />The solver dispatches bees to search in parallel (Scout Bees for new solutions, Active Bees for improvements around a known solution), and fires events every time an improved solution is found, until the search is stopped.<br />\n<h3>The algorithm in action: Traveling Salesman Problem</h3>\rThe project includes a C# WPF application, which shows the algorithm working in real-time trying to find the shortest route between a list of randomly generated cities. The video below shows the bee busy on a 200-cities route:<br /><div class=\"video\" style=\"text-align:Center\"><span class=\"player\"><object height=\"285px\" width=\"320px\"><param name=\"movie\" value=\"http://www.youtube.com/v/PWbRBYKz4tw\"></param><param name=\"wmode\" value=\"transparent\"></param><embed height=\"285px\" width=\"320px\" type=\"application/x-shockwave-flash\" wmode=\"transparent\" src=\"http://www.youtube.com/v/PWbRBYKz4tw\" /></object></span><br /><span class=\"external\"><a href=\"http://www.youtube.com/watch?v=PWbRBYKz4tw\" target=\"_blank\">Launch in another window</a></span></div><br />\n<h3>Illustration: Traveling Salesman Problem</h3>\rThe objective is to find the shortest closed path connecting a list of cities. Starting with an array of Cities, we will generate new solutions by shuffling the initial list, and mutate solutions by either swapping a random pair of cities, or trying to remove crossings in the current solution. The Quality of a solution will be the negative of the distance, so that shorter distances have a higher quality than longer ones.<br /><br /><pre>\nopen System\nopen System.Diagnostics\nopen ClearLines.Bumblebee\n\n[&lt;DebuggerDisplay(&quot;{Name}&quot;)&gt;]\ntype City = { Name: string; X: float; Y: float }\n\nlet Main =\n   \n   // Euclidean distance between cities\n   let distance (C1, C2) = \n      (  (C1.X - C2.X) ** 2.0 + \n         (C1.Y - C2.Y) ** 2.0) ** 0.5\n\n   // Permutation function: \n   // swaps items at first and second index\n   let swap (first: int, second) index =\n      if index = first then second\n      elif index = second then first\n      else index\n\n   // Swap 2 random elements in an Array\n   let randomSwap (rng: Random) items =\n      let last = Array.length items\n      let first = rng.Next(last)\n      let second = rng.Next(last)\n      Array.permute (fun i -&gt; swap (first, second) i) items\n\n   // Fisher-Yates shuffle\n   let shuffle (rng: Random) items =\n      let rec shuffleTo (indexes: int[]) upTo =\n         match upTo with\n         | 0 -&gt; indexes\n         | _ -&gt;\n            let fst = rng.Next(upTo)\n            let temp = indexes.[fst]\n            indexes.[fst] &lt;- indexes.[upTo] \n            indexes.[upTo] &lt;- temp\n            shuffleTo indexes (upTo - 1)\n      let length = Array.length items\n      let indexes = [| 0 .. length - 1 |]\n      let shuffled = shuffleTo indexes (length - 1)\n      Array.permute (fun i -&gt; shuffled.[i]) items \n\n   // Compute the total distance,\n   // summing distances between consecutive cities\n   let quality (circuit: City []) =\n      let length = Array.length circuit\n      [|\n         for i in 0 .. (length - 1) -&gt;\n            distance(circuit.[i], circuit.[(i + 1) % length])\n      |]\n      |&gt; Array.sum\n\n   // determines if 2 pairs of cities intersect\n   // see http://stackoverflow.com/a/3842157/114519\n   let intersects (city1, city2) (city3, city4) =\n      let det1 = (city1.X - city3.X) * (city2.Y - city3.Y) - (city2.X - city3.X) * (city1.Y - city3.Y)\n      let det2 = (city1.X - city4.X) * (city2.Y - city4.Y) - (city2.X - city4.X) * (city1.Y - city4.Y)\n      let det3 = (city3.X - city1.X) * (city4.Y - city1.Y) - (city4.X - city1.X) * (city3.Y - city1.Y)\n      let det4 = (city3.X - city2.X) * (city4.Y - city2.Y) - (city4.X - city2.X) * (city3.Y - city2.Y)\n      (det1 * det2 &lt;= 0.0) &amp;&amp; (det3 * det4 &lt;= 0.0)\n\n   // Pick a random city in the circuit \n   // and look for an intersection afterwards.\n   // If an intersection is found, remove the crossing\n   let decross (rng: Random) (circuit: City []) =\n      let length = Array.length circuit\n\n      if length &lt; 4 \n      then circuit\n      else\n         let i = rng.Next(length - 3)\n         let c1, c2 = circuit.[i], circuit.[i + 1]\n      \n         let intersection =\n            seq { i + 2 .. length - 2 }  \n            |&gt; Seq.tryFind (fun i -&gt; intersects (c1, c2) (circuit.[i], circuit.[i+1]))\n\n         match intersection with\n         | None -&gt; circuit\n         | Some(j) -&gt; \n            let permutation x =\n               if x &gt; i &amp;&amp; x &lt;= j then i + j + 1 - x\n               else x\n            Array.permute permutation circuit\n\n   // create an Array of cities on a circle:\n   // that way, we know the best length is about 2*Pi*R\n   let testRoute radius points = \n      let angle = Math.PI * 2.0 / (double)points\n      [|\n         for i in 1 .. points -&gt;\n            {  Name = i.ToString(); \n               X = Math.Cos(angle * (double) i) * radius; \n               Y = Math.Sin(angle * (double) i) * radius }           \n      |]\n\n   let rng = RNG.create()\n\n   let root = testRoute 10.0 100 |&gt; shuffle rng\n\n   let generator = fun (rng: Random) -&gt; shuffle rng root\n   let mutator = fun (rng: Random) (circuit: City []) -&gt; \n      let p = rng.NextDouble()\n      if ( p &lt; 0.1 ) \n      then decross rng circuit\n      else randomSwap rng circuit\n\n   let evaluator = fun (circuit: City []) -&gt; - quality circuit\n   \n   let problem = new Problem&lt;City []&gt;(generator, mutator, evaluator)\n\n   let displaySolution (circuit: City []) = \n      Array.iter (fun (c) -&gt; Console.Write(c.Name + &quot; &quot;)) circuit\n\n   let foundSomething = fun (msg: SolutionMessage&lt;City []&gt;) -&gt; \n      Console.WriteLine(&quot;{0}, {1}&quot;, msg.DateTime.TimeOfDay, msg.Quality)\n      // Console.WriteLine(displaySolution(msg.Solution))\n      Console.WriteLine()\n         \n   let solver = new Solver&lt;City []&gt;()\n   solver.FoundSolution.Add foundSomething\n\n   Console.WriteLine(&quot;Press [Enter] to start&quot;)\n   let wait = Console.ReadLine()\n   Console.WriteLine(&quot;Starting: press [Enter] to stop search&quot;)   \n\n   solver.Search problem |&gt; ignore\n\n   let wait = Console.ReadLine()\n   solver.Stop()\n   Console.WriteLine(&quot;Search stopped: press [Enter] to close&quot;)   \n\n   let wait = Console.ReadLine()\n   Console.WriteLine(&quot;Done&quot;)\n</pre></div><div class=\"ClearBoth\"></div>",
  "TagList": "F#,Algorithms,fsharp,",
  "LastEdited": "2012-06-06T20:14:56.467-07:00"
}