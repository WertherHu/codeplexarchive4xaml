{
  "ProjectName": "behavioral",
  "Title": "Behavioral",
  "Description": "A Behavior Driven Design (BDD) library adding a clearer syntax and better organization to unit tests. Currently tested working with NUnit and MSTest.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><b>Project Description</b><br />A Behavior Driven Design &#40;BDD&#41; library adding a clearer syntax and better organization to unit tests. Currently tested working with NUnit and MSTest.<br /><br /><b>Quick Start</b><br />1) Download the pre-compiled assembly and add a reference to it from your <i>test</i> project.<br /><br />2) Create a new class deriving from <b>Behavioral.UnitTest&lt;TTarget&gt;</b> or <b>Behavioral.UnitTest&lt;TTarget, TReturnType&gt;</b>. The latter is required for testing methods that return a type, ie: are not <b>void</b>.<br /><br />3) In the class&#39; constructor, call <b>GivenThat&lt;TInitializer&gt;()</b>, <b>When&lt;TAction&gt;()</b> and <b>Then&lt;TAssertion&gt;()</b>, specifying English-language sentences (in Pascal Case) for the type arguments.<br /><br />4) Define the classes in part 3, implementing <b>IInitializer&lt;TTarget&gt;</b>, <b>IAction&lt;TTarget&gt;</b> and <b>IAssertion&lt;TTarget&gt;</b>, respectively.<br /><br /><b>Example</b><br /><br />Here is a very simple example of how to use Behavioral - in conjunction with NUnit - to test the <b>Add()</b> method of a simple <b>Calculator</b> class.<br /><br /><i>CalculatorTests.cs</i><br /><br /><pre>\nusing Behavioral;\nusing NUnit;\n\nnamespace MyTests\n{\n\t[TestFixture]\n\tpublic class AddingTwoPositiveNumbersShouldGiveCorrectResult : UnitTest&lt;Calculator, int&gt;\n\t{\n\t\t[Test]\n\t\tpublic override void Run()\n\t\t{\n\t\t\tGivenThat&lt;CalculatorIsDefaultConstructed&gt;();\n\n\t\t\tWhen&lt;TwoNumbersAreAdded&gt;(13, 45);\n\n\t\t\tThen&lt;ResultShouldMatch&gt;(58);\n\t\t}\n\t} \n\n\t[TestFixture]\n\tpublic class AddingNumbersThatCausesOverflowShouldThrowOverflowException : UnitTest&lt;Calculator, int&gt;\n\t{\n\t\t[Test]\n\t\tpublic override void Run()\n\t\t{\n\t\t\tGivenThat&lt;CalculatorIsDefaultConstructed&gt;();\n\n\t\t\tWhen&lt;TwoNumbersAreAdded&gt;(int.MaxValue, 1);\n\n\t\t\tThenThrow&lt;OverflowException&gt;();\n\t\t}\n\t}\n}\n</pre><br /><br /><i>CalculatorInitializers.cs</i><br /><br /><pre>\npublic class CalculatorIsDefaultConstructed : IInitializer&lt;Calculator&gt;\n{\n\tpublic void SetUp(ref Calculator calculator)\n\t{\n\t\tcalculator = new Calculator();\n\t}\n}\n</pre><br /><br /><i>CalculatorActions.cs</i><br /><br /><pre>\npublic class TwoNumbersAreAdded : IAction&lt;Calculator, int&gt;\n{\n\tpublic TwoNumbersAreAdded(int x, int y)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic int Execute(Calculator calculator)\n\t{\n\t\treturn calculator.Add(this.x, this.y);\n\t}\n\n\tprivate int x;\n\tprivate int y;\n}\n</pre><br /><br /><i>CalculatorAssertions.cs</i><br /><br /><pre>\npublic class ResultShouldMatch : IAssertion&lt;Calculator, int&gt;\n{\n\tpublic ResultShouldMatch(int expectedValue)\n\t{\n\t\tthis.expectedValue;\n\t}\n\n\tpublic void Verify(Calculator calculator, int returnValue)\n\t{\n\t\tAssert.AreEqual(this.expectedValue, returnValue);\n\t}\n\n\tprivate int expectedValue;\n}\n</pre><br /><br />So, that&#39;s a simple example of how to trivially test the following Calculator implementation:<br /><br /><i>Calculator.cs</i><br /><br /><pre>\npublic class Calculator\n{\n\tpublic int Add(int x, int y)\n\t{\n\t\tchecked\n\t\t{\n\t\t\treturn x + y;\n\t\t}\n\t}\n}\n</pre><br /><br /><br /><b>Background</b><br />Behavior Driven Development (BDD) is the natural next step after Test Driven Development (TDD). BDD is many different things, but one aspect of BDD is addressed by <b>Behavioral</b>: unit test organization.<br /><br />The usual way of organizing unit tests is as follows:<br /><br /><pre>\n[TestFixture]\npublic class CalculatorFixture\n{\n\t[SetUp]\n\tpublic void SetUp()\n\t{\n\t\tthis.calculator = new Calculator();\n\t}\n\n\t[Test]\n\tpublic void CanAddTwoPositiveNumbers()\n\t{\n\t\tint result = this.calculator.Add(13, 45);\n\t\tAssert.AreEqual(58, result);\n\t}\n\n\t[Test]\n\tpublic void AdditionOverflowCausesException()\n\t{\n\t\tAssert.Throws&lt;OverflowException&gt;(() =&gt; this.calculator.Add(int.MaxValue, 1));\n\t}\n\n\tprivate Calculator calculator;\n}\n</pre> <br /><br />As the tests become more complex and involved, there are two problems with this approach that are addressed by <b>Behavioral</b>.<br />\n<ul><li>The tests do not promote reuse, neither of the initialization code, the action under test nor the assertions that are made after the fact.</li>\n<li>The tests can become hard to understand and, as the tests in an agile project form a reliable documentation of the code&#39;s intent, it is important to keep them simple.</li></ul>\n</div><div class=\"ClearBoth\"></div>",
  "TagList": "TDD,BDD,Testing,Unit Testing,NUnit,MSTest,Test Driven Design,Behavioral,NBehave,NSpec,",
  "LastEdited": "2011-08-15T07:10:13.107-07:00"
}