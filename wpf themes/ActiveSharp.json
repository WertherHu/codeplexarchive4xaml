{
  "ProjectName": "ActiveSharp",
  "Title": "ActiveSharp - Automatic INotifyPropertyChanged",
  "Description": "Send property change notifications without specifying property name as a string. ",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><b>Project Description</b><br />Send property change notifications without specifying property name as a string. <br /><br />Instead, write properties like this:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n    <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">int</span> Foo\n    {\n        <span style=\"color:Blue;\">get</span> { <span style=\"color:Blue;\">return</span> _foo; }\n        <span style=\"color:Blue;\">set</span> { SetValue(<span style=\"color:Blue;\">ref</span> _foo, value); }  <span style=\"color:Green;\">// &lt;-- no property name here</span>\n    }\r\n</pre></div>Note that there is no need to include the name of the property as a string. ActiveSharp reliably and correctly figures that out for itself.  It works based on the fact that your property implementation passes the backing field (_foo) by <b>ref</b>.  (ActiveSharp uses that &quot;by ref&quot; call to identify <i>which</i> backing field was passed, and from the field it  identifies the property).<br /><br />This approach is much faster and more reliable than inspecting call stacks, which is a commonly-quoted, but <a href=\"http://www.lhotka.net/Article.aspx?area=4&amp;id=0708c745-f009-4d09-9f91-6a349b5b0317\">fatally</a> <a href=\"http://dotnet.agilekiwi.com/blog/2007/07/claytons-interception.html\">flawed</a>, alternative.<br /><br />Requires .NET 2.0 or later.<br /><br /><pre>\nUpdate, Sept 2011: You won&#39;t need ActiveSharp in C# 5.  To convert existing ActiveSharp code to C# 5, \nsimply edit your SetValue method (described below) to use the new CallerMemberName attribute, instead of using \nActiveSharp.  No other code changes will be required.\n</pre><br /><br /><b>Implementing INotifyPropertyChanged</b><br /><br /><b>Option 1:</b> The easiest way is to use ActiveSharp&#39;s PropertyChangeHelper:<br /><br />Add this code to your class or (preferrably) to a base class:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n    <span style=\"color:Blue;\">readonly</span> PropertyChangeHelper _propertyChangeHelper = <span style=\"color:Blue;\">new</span> PropertyChangeHelper();\n\n    <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">event</span> PropertyChangedEventHandler PropertyChanged\n    {\n        add { _propertyChangeHelper.Add(value); }\n        remove { _propertyChangeHelper.Remove(value); }\n    }\n            \n    <span style=\"color:Blue;\">protected</span> <span style=\"color:Blue;\">void</span> SetValue&lt;T&gt;(<span style=\"color:Blue;\">ref</span> T field, T value)\n    {\n        _propertyChangeHelper.SetValue(<span style=\"color:Blue;\">this</span>, <span style=\"color:Blue;\">ref</span> field, value);\n    }\r\n</pre></div><br />Also, add INotifyPropertyChanged to your base class&#39; list of ancestors.  Now, you have a base class that provides all the support for derived classes to sent property changed notifications really easily.  <br /><br />In your derived classes, simply implement your properties like this:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n    <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">int</span> Foo\n    {\n        <span style=\"color:Blue;\">get</span> { <span style=\"color:Blue;\">return</span> _foo; }\n        <span style=\"color:Blue;\">set</span> { SetValue(<span style=\"color:Blue;\">ref</span> _foo, value); }   <span style=\"color:Green;\">// assigns value and does prop change notification, all in one line</span>\n    }\r\n</pre></div><br />Note: a reader kindly wrote in with <a href=\"https://activesharp.codeplex.com/wikipage?title=Using%20ActiveSharp%20from%20VB&referringTitle=Home\">this</a> translation of the code to VB.NET.<br /><br /><b>Option 2:</b><br /><br />If you want more control, you can write your own SetValue method, instead of delegating to the helper class.  Someting like this:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n    <span style=\"color:Blue;\">protected</span> <span style=\"color:Blue;\">void</span> SetValue&lt;T&gt;(<span style=\"color:Blue;\">ref</span> T field, T value)\n    {\n        ...\n        field = value;   <span style=\"color:Green;\">//Actually assign the new value</span>\n        PropertyInfo changedProperty = \n               ActiveSharp.PropertyMapping.PropertyMap.GetProperty(<span style=\"color:Blue;\">this</span>, <span style=\"color:Blue;\">ref</span> field);\n        <span style=\"color:Green;\">// do whatever you like, now that you know which prop was changed</span>\n        ...\n    }\r\n</pre></div><br />As you can see, all the &quot;magic&quot; is in ActiveSharp.PropertyMapping.PropertyMap.GetProperty.  Given an object, and a field in that object, passed &quot;by ref&quot;, the routine finds the property that sets the field.  It returns a standard .NET PropertyInfo object.  Just read its Name property if all you want is the property name.<br /><br /><b>More Details</b><br /><br />ActiveSharp works using a unique combination of runtime identification of fields that are passed &quot;by ref&quot;, and runtime MSIL inspection (to see which properties use those fields). The MSIL inspection is done only once, then cached.  The by-ref field lookup is done on every call, but it&#39;s very quick (basically just an integer subtraction and a hash table lookup). For full details, see <a href=\"https://activesharp.codeplex.com/wikipage?title=How%20it%20works&referringTitle=Home\">How it works</a>.  <br /><br />Dicsussion thread <a href=\"https://www.codeplex.com/Thread/View.aspx?ProjectName=ActiveSharp&amp;ThreadId=22315\">here</a> for discussion of other things you can do with ActiveSharp, and how it compares with the alternatives.<br /><br />Blog posts <a href=\"http://dotnet.agilekiwi.com/blog/2008/02/better-property-change-notification.html\">here</a> and <a href=\"http://dotnet.agilekiwi.com/blog/2007/07/claytons-interception.html\">here</a> (including the comments) <br /><br /><b>++++++<u> NB: A Note Regarding Alternatives </u>+++++</b><br /><br />If you don&#39;t want this much &quot;funky stuff&quot; inside your application, there are some alternatives:<br />\n<ol><li>Always pass string.Empty as the property name in the PropertyChangedEventArgs.  This means &quot;consider all my properties to be changed&quot; (see <a href=\"http://msdn.microsoft.com/en-us/library/system.componentmodel.inotifypropertychanged.propertychanged.aspx\">http://msdn.microsoft.com/en-us/library/system.componentmodel.inotifypropertychanged.propertychanged.aspx</a> ). If you do this, then your property setter code never needs to figure out which property it is &quot;running in&quot;, since it just passes string.Empty for <i>all</i> of them.  In some (many?) cases, this may be an acceptable solution.  It is easy to code, easy to refactor, and requires neither ActiveSharp nor any other &quot;special&quot; solution.</li>\n<li>Use ActiveSharp as a unit-test tool, rather than an actual part of your application.  In this case, you <i>do</i> put hard-coded property names in the setter methods, but ActiveSharp checks those hard-coded strings <i>at unit test time</i>.  So, if you rename the property using a refactoring tool, but forget to change the hard-coded string, you&#39;ll get a test failure that reminds you to change the string. See <a href=\"https://activesharp.codeplex.com/wikipage?title=Using%20ActiveSharp%20as%20a%20Unit%20Test%20Tool&referringTitle=Home\">Using ActiveSharp as a Unit Test Tool</a>.</li>\n<li>Use an AOP tool.  These have the arguable disadvantage of more runtime and/or build-time &quot;baggage&quot; than ActiveSharp (i.e. more &quot;funky stuff&quot; rather than less), but they can certainly do the job.  <a href=\"http://shecht.wordpress.com/2009/12/12/inotifypropertychanged-with-unity-interception-aop/\">This</a> is my favourite post on AOP as a solution for INotifyPropertyChanged. </li></ol>\n<br /><b>Performance</b><br />For basic performance tests, and their results, see <a href=\"http://activesharp.codeplex.com/SourceControl/changeset/view/a5531d40c261#ActiveSharp.Tests%2fPerformanceTests.cs\">this unit test</a>.  The test results show that ActiveSharp is easily fast enough for most usages (and many, many times faster than crawling the call stack - which doesn&#39;t work properly anyway).  <br /><br />Finally, on the topic of performance, as of 27 March 2011, there is an alternative API for ActiveSharp (See <a href=\"https://activesharp.codeplex.com/workitem/2227\">Optimize performance</a>).  It is approximately 4 times faster than the old one.  However, because it is harder to use, and the old one is fast enough for all known usages of ActiveSharp, the new API is not yet included in any release.  Besides, option 2 above (<a href=\"https://activesharp.codeplex.com/wikipage?title=Using%20ActiveSharp%20as%20a%20Unit%20Test%20Tool&referringTitle=Home\">Using ActiveSharp as a Unit Test Tool</a>) gives the fastest runtime performance of all.</div><div class=\"ClearBoth\"></div>",
  "TagList": "c#,orm,WPF,winforms,",
  "LastEdited": "2011-09-22T02:18:43.06-07:00"
}