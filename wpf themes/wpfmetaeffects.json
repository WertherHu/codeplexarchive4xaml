{
  "ProjectName": "wpfmetaeffects",
  "Title": "WPF Meta-Effects",
  "Description": "WPF Meta-Effects makes it easier for shader effect developpers to develop and maintain shader code. You'll no longer have to write any HLSL, instead of that, you'll write typesafe, compile-time verified and intellisense capable C# code, and the runtime translates it for you !",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><h1>Project Description</h1>\rWPF Meta-Effects makes it easier for shader effect developpers to develop and maintain shader code. You&#39;ll no longer have to write any HLSL, instead of that, you&#39;ll write typesafe, compile-time verified and intellisense capable C&#35; code, and the runtime translates it for you &#33;<br />\n<h1>Features</h1>\r<ul><li>C# 4.0 Lamda expression-based shader language</li>\n<li>Dynamic generation of GPU code (allows late optimization of shader effects)</li></ul>\n\n<h2>Prerequisites to build the solution</h2>\r<ul><li>Visual Studio 2010 RTM</li>\n<li>DirectX SDK</li></ul>\n\n<h2>Special thanks</h2>\rThe syntax is based on a presentation done by Mitsuru Furuta during TechDays France 2010 and explained on his blog: <a href=\"http://blogs.msdn.com/mitsu/\">http://blogs.msdn.com/mitsu/</a><br />\n<h2>Known issues</h2>\rOnly a limited subset of the structures avalable in Mitsu&#39;s project are implemented. Things like loops and conditional structures are not implemented in this initial work.<br />\n<h2>Examples</h2>\r\nSimple invert color code:<br /><pre>\n        private class ShaderVariables\n        {\n            [Register(0)]\n            public sampler2D Input { get; set; }\n\n            [Texcoord]\n            public float2 TexCoord { get; set; }\n\n            public float4 Color { get; set; }\n        }\n        \n        private void CreateShader()\n        {\n            Expression&lt;Action&lt;ShaderVariables&gt;&gt; shaderSource = o =&gt;\n                Block.Declare(new ShaderVariables(), vars =&gt;\n                    Block.Default\n                    .Assign(vars.Color, vars.Input.tex2D(vars.TexCoord))\n                    .Assign(vars.Color, new float4(new float3(1,1,1) - vars.Color.xyz, vars.Color.w))\n                    ._(()=&gt;vars.Color.Return())\n                );\n            var hlsl = ExpressionToHlsl.TranslateToHLSL(shaderSource);\n            _shader = HlslCompiler.Compile(hlsl, ShaderProfile.ps_2_0);\n        }\n</pre><br />PlaneProjectionEffect (see <a href=\"http://slflow.codeplex.com\">http://slflow.codeplex.com</a> for original code):<br /><pre>        public class PlaneProjectionVariables\n        {\n            [Register(0)]\n            public float4x4 invertedMatrix { get; set; }\n\n            [Register(4)]\n            public float3 planeNormal { get; set; }\n\n            [Register(5)]\n            public float planeDistance { get; set; }\n\n            [Register(6)]\n            public float2 sourceSize { get; set; }\n\n            [Register(10)]\n            public float2 viewportOffset { get; set; }\n\n            [Register(0)]\n            public sampler2D implicitInputSampler { get; set; }\n\n            [Texcoord]\n            public float2 texCoords { get; set; }\n\n            public float3 sourceOfRay { get; set; }\n            public float3 rayVector { get; set; }\n            public float normalDotRayVector { get; set; }\n            public float normalDotSourceOfRay { get; set; }\n            public float distanceOfInterceptionPoint { get; set; }\n            public float3 intersectPointInWorldSpace { get; set; }\n            public float4 intersectPointInPlanSpace4 { get; set; }\n            public float3 intersectPointInPlanSpace { get; set; }\n            public float4 color { get; set; }\n        }\n        private void CreateShader()\n        {\n            Expression&lt;Action&lt;PlaneProjectionVariables&gt;&gt; expr = (PlaneProjectionVariables vs) =&gt;\n                Block.Declare(new PlaneProjectionVariables(),\n                vars =&gt;\n                    Block.Default\n                        .Assign(vars.sourceOfRay, new float3(vars.texCoords * 2.0f - 1.0f, 0))\n                        .Assign(vars.sourceOfRay.x, vars.sourceOfRay.x + vars.viewportOffset.x)\n                        .Assign(vars.sourceOfRay.y, vars.sourceOfRay.y + vars.viewportOffset.y)\n\n                        .Assign(vars.rayVector, new float3(0, 0, -1))\n                        .Assign(vars.normalDotRayVector, vars.planeNormal.dot(vars.rayVector))\n                        .Assign(vars.normalDotSourceOfRay, vars.planeNormal.dot(vars.sourceOfRay))\n\n                        .Assign(vars.distanceOfInterceptionPoint, 0.0f - (vars.normalDotSourceOfRay + vars.planeDistance) / vars.normalDotRayVector)\n\n                        .Assign(vars.intersectPointInWorldSpace, vars.sourceOfRay + vars.distanceOfInterceptionPoint * vars.rayVector)\n                        .Assign(vars.intersectPointInPlanSpace4, new float4(vars.intersectPointInWorldSpace, 1.0f).mul(vars.invertedMatrix.transpose()))\n                        .Assign(vars.intersectPointInPlanSpace, vars.intersectPointInPlanSpace4.xyz / vars.intersectPointInPlanSpace4.w)\n                        .Assign(vars.intersectPointInPlanSpace.x, vars.intersectPointInPlanSpace.x / vars.sourceSize.x * 0.5f)\n                        .Assign(vars.intersectPointInPlanSpace.y, vars.intersectPointInPlanSpace.y / vars.sourceSize.y * 0.5f)\n\n                        .Assign(vars.intersectPointInPlanSpace, vars.intersectPointInPlanSpace * 0.5f + 0.5f)\n                        .Assign(vars.color, vars.implicitInputSampler.tex2D(vars.intersectPointInPlanSpace.xy))\n                        ._(() =&gt; vars.color.Return())\n        );\n\n            var hlsl = ExpressionToHlsl.TranslateToHLSL(expr);\n            _shader = HlslCompiler.Compile(hlsl, ShaderProfile.ps_2_0);\n        }\n</pre><br />Composite effect:<br /><pre>\n        public class CommonParameters\n        {\n            [Register(0)]\n            public sampler2D Input { get; set; }\n\n            [Texcoord]\n            public float2 TexCoord { get; set; }\n\n\n            public float4 Color { get; set; }\n        }\n\n        public class Parameters1 : CommonParameters\n        {\n            [Register(0)]\n            public float2 Offset { get; set; }\n        }\n        public class Parameters2 : CommonParameters\n        {\n            [Register(1)]\n            public float4 ColorMultiplier { get; set; }\n        }\n        private void CreateShader()\n        {\n            Expression&lt;Action&lt;Parameters1&gt;&gt; exp1 = o =&gt;\n                Block.Declare(new Parameters1(), vars =&gt;\n                    Block.Default\n                        .Assign(vars.TexCoord, vars.TexCoord + vars.Offset)\n                        .Assign(vars.Color, vars.Input.tex2D(vars.TexCoord))\n                        );\n            Expression&lt;Action&lt;Parameters2&gt;&gt; exp2 = o =&gt;\n                Block.Declare(new Parameters2(), vars =&gt;\n                    Block.Default\n                        .Assign(vars.Color, vars.Color * vars.ColorMultiplier)\n                        ._(() =&gt; vars.Color.Return())\n                    );\n\n            var hlsl = ExpressionToHlsl.TranslateToHLSL(exp1, exp2);\n            _shader = HlslCompiler.Compile(hlsl, ShaderProfile.ps_2_0);            \n        }\n</pre><br /><br /></div><div class=\"ClearBoth\"></div>",
  "TagList": "",
  "LastEdited": "2010-04-27T05:58:49.583-07:00"
}