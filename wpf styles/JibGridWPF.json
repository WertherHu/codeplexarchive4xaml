{
  "ProjectName": "JibGridWPF",
  "Title": "JibGrid - WPF DataGrid With Grouping, Freezing, and Filtering",
  "Description": "Jib.Grid is a reference implementation demonstrating how to add Grouping, Freezing, and Filtering to the base WPF DataGrid. This project can serve as the basis for your specific needs. ",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><h1>Project Description</h1>\rJib.Grid is a reference implementation demonstrating how to add Grouping, Freezing, and Filtering to the base WPF DataGrid. This project can serve as the basis for your specific needs.<br /> <img src=\"/projects/JibGridWPF/6688c7c4-c408-4984-becb-fc3f6b7622e1\" alt=\"jibgrid_wpf.png\" title=\"jibgrid_wpf.png\" /> <br />This project is intended to demonstrate how each of these features can be implemented using the standard DataGrid provided in WPF. In total, the solution consists of several hundred lines of code {excluding xaml :) }. This small code-base should help others in understanding the techniques used for each feature. While fully functional, this project should serve as a reference implementation not a final solution. In several edge cases simplicity was chosen over completeness. As such, there are several limitations to this control. Before you use the control, please review these limitations outlined below. As a side note, all these limitations can be resolved, but the solutions would add too much complexity and code for this projects intended purpose.<br /><br /> <br />\n<h1>Filtering</h1>\rThe filter headers are added to the DataGrid by creating a custom ColumnHeaderStyle. This implementation has a serious drawback. To make a long story short, there is no easy way of tying the filter control to the corresponding column. In the end I use the VisualTreeHelper to find DataGridColumnHeader of the created filter control.  From the DataGridColumnHeader I then find the column for the filter control.<br /><br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">void</span> ColumnFilterHeader_Loaded(<span style=\"color:Blue;\">object</span> sender, RoutedEventArgs e)\n        {\n            DataGridColumn column = <span style=\"color:Blue;\">null</span>;\n            DataGridColumnHeader colHeader = <span style=\"color:Blue;\">null</span>;\n\n            UIElement parent = (UIElement)VisualTreeHelper.GetParent(<span style=\"color:Blue;\">this</span>);\n            <span style=\"color:Blue;\">while</span> (parent != <span style=\"color:Blue;\">null</span>)\n            {\n                parent = (UIElement)VisualTreeHelper.GetParent(parent);\n                <span style=\"color:Blue;\">if</span> (colHeader == <span style=\"color:Blue;\">null</span>)\n                    colHeader = parent <span style=\"color:Blue;\">as</span> DataGridColumnHeader;\n\n                <span style=\"color:Blue;\">if</span> (Grid == <span style=\"color:Blue;\">null</span>)\n                    Grid = parent <span style=\"color:Blue;\">as</span> JibGrid;\n            }\n\n            <span style=\"color:Blue;\">if</span> (colHeader != <span style=\"color:Blue;\">null</span>)\n                column =  colHeader.Column;\n        <span style=\"color:Green;\">// the code continues...</span>\n            }\n\n        }\r\n</pre></div><br />Since the ItemSource for the grid is a CollectionViewSource, filtering is done by generating a predicate composed of all the filters entered by the user. This predicate is composed by each filter control dynamically creating a lamda expression and then having the grid AND each predicate into the final predicate for the CollectionViewSource&#39;s filter. For simplicityâ€™s sake the lamda expression can only be generated off of first level properties. In addition to this, the filter controls do not support String Formatting (could not figure out how to apply it). It does support converters.<br /><br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n <span style=\"color:Blue;\">void</span> filter_PropertyChanged(<span style=\"color:Blue;\">object</span> sender, PropertyChangedEventArgs e)\n        {\n            <span style=\"color:Blue;\">if</span> (e.PropertyName == <span style=\"color:#A31515;\">&quot;FilterChanged&quot;</span>)\n            {\n                Predicate&lt;<span style=\"color:Blue;\">object</span>&gt; predicate = <span style=\"color:Blue;\">null</span>;\n                <span style=\"color:Blue;\">foreach</span> (<span style=\"color:Blue;\">var</span> filter <span style=\"color:Blue;\">in</span> Filters)\n                    <span style=\"color:Blue;\">if</span> (filter.HasPredicate)\n                        <span style=\"color:Blue;\">if</span> (predicate == <span style=\"color:Blue;\">null</span>)\n                            predicate = filter.GeneratePredicate();\n                        <span style=\"color:Blue;\">else</span>\n                            predicate = predicate.And(filter.GeneratePredicate());\n                <span style=\"color:Blue;\">bool</span> canContinue = <span style=\"color:Blue;\">true</span>;\n                <span style=\"color:Blue;\">var</span> args = <span style=\"color:Blue;\">new</span> CancelableFilterChangedEventArgs(predicate);\n                <span style=\"color:Blue;\">if</span> (BeforeFilterChanged != <span style=\"color:Blue;\">null</span> &amp;&amp; !IsResetting)\n                {\n                    BeforeFilterChanged(<span style=\"color:Blue;\">this</span>, args);\n                    canContinue = !args.Cancel;\n                }\n                <span style=\"color:Blue;\">if</span> (canContinue)\n                {\n                    ListCollectionView view = CollectionViewSource.GetDefaultView(<span style=\"color:Blue;\">this</span>.ItemsSource) <span style=\"color:Blue;\">as</span> ListCollectionView;\n                    <span style=\"color:Blue;\">if</span> (view != <span style=\"color:Blue;\">null</span> &amp;&amp; view.IsEditingItem)\n                        view.CommitEdit();\n                    <span style=\"color:Blue;\">if</span> (view != <span style=\"color:Blue;\">null</span> &amp;&amp; view.IsAddingNew)\n                        view.CommitNew();\n                    <span style=\"color:Blue;\">if</span> (CollectionView != <span style=\"color:Blue;\">null</span>)\n                        CollectionView.Filter = predicate;\n                    <span style=\"color:Blue;\">if</span> (AfterFilterChanged != <span style=\"color:Blue;\">null</span>)\n                        AfterFilterChanged(<span style=\"color:Blue;\">this</span>, <span style=\"color:Blue;\">new</span> FilterChangedEventArgs(predicate));\n                }\n                <span style=\"color:Blue;\">else</span>\n                {\n                    IsResetting = <span style=\"color:Blue;\">true</span>;\n                    <span style=\"color:Blue;\">var</span> ctrl = sender <span style=\"color:Blue;\">as</span> ColumnFilterControl;\n                    ctrl.ResetControl();\n                    IsResetting = <span style=\"color:Blue;\">false</span>;\n                }\n            }\n        }\r\n</pre></div>\n<h1>Grouping </h1>\rJibGrid uses the standard WPF technique of defining a row GroupStyle.  If you are familiar with this approach, you will know that it has SEVER performance limitations.  It seems that when a row style is defined, the grid no longer can perform row virtualization.  As such, while you can group, it is a real performance killer.<br /><br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">void</span> AddGroup(<span style=\"color:Blue;\">string</span> boundPropertyName)\n        {\n            <span style=\"color:Blue;\">if</span> (!<span style=\"color:Blue;\">string</span>.IsNullOrWhiteSpace(boundPropertyName) &amp;&amp; CollectionView != <span style=\"color:Blue;\">null</span> &amp;&amp; CollectionView.GroupDescriptions != <span style=\"color:Blue;\">null</span>)\n            {\n                <span style=\"color:Blue;\">foreach</span> (<span style=\"color:Blue;\">var</span> groupedCol <span style=\"color:Blue;\">in</span> CollectionView.GroupDescriptions)\n                {\n                    <span style=\"color:Blue;\">var</span> propertyGroup = groupedCol <span style=\"color:Blue;\">as</span> PropertyGroupDescription;\n\n                    <span style=\"color:Blue;\">if</span> (propertyGroup != <span style=\"color:Blue;\">null</span> &amp;&amp; propertyGroup.PropertyName == boundPropertyName)\n                        <span style=\"color:Blue;\">return</span>;\n                }\n\n                CollectionView.GroupDescriptions.Add(<span style=\"color:Blue;\">new</span> PropertyGroupDescription(boundPropertyName));\n            }\n        }\r\n</pre></div>\n<h1>Freezing</h1>\rThe WPF DataGrid supports Freezing Columns. This is done by the grouping controls setting the FrozenColumnCount on the DataGrid. When the user selects a column to freeze, the grid changes the display index and increments the FrozenColumnCount.<br /><br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">void</span> FreezeColumn(DataGridColumn column)\n        {\n            <span style=\"color:Blue;\">if</span> (<span style=\"color:Blue;\">this</span>.Columns != <span style=\"color:Blue;\">null</span> &amp;&amp; <span style=\"color:Blue;\">this</span>.Columns.Contains(column))\n            {\n                column.DisplayIndex = <span style=\"color:Blue;\">this</span>.FrozenColumnCount;\n                <span style=\"color:Blue;\">this</span>.FrozenColumnCount++;\n            }\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">bool</span> IsFrozenColumn(DataGridColumn column)\n        {\n            <span style=\"color:Blue;\">if</span> (<span style=\"color:Blue;\">this</span>.Columns != <span style=\"color:Blue;\">null</span> &amp;&amp; <span style=\"color:Blue;\">this</span>.Columns.Contains(column))\n            {\n                <span style=\"color:Blue;\">return</span> column.DisplayIndex &lt; <span style=\"color:Blue;\">this</span>.FrozenColumnCount;\n            }\n            <span style=\"color:Blue;\">else</span>\n            {\n                <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">false</span>;\n            }\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">void</span> UnFreezeColumn(DataGridColumn column)\n        {\n            <span style=\"color:Blue;\">if</span> (<span style=\"color:Blue;\">this</span>.FrozenColumnCount &gt; 0 &amp;&amp; column.IsFrozen &amp;&amp; <span style=\"color:Blue;\">this</span>.Columns != <span style=\"color:Blue;\">null</span> &amp;&amp; <span style=\"color:Blue;\">this</span>.Columns.Contains(column))\n            {\n                <span style=\"color:Blue;\">this</span>.FrozenColumnCount--;\n                column.DisplayIndex = <span style=\"color:Blue;\">this</span>.FrozenColumnCount;\n            }\n        }\r\n</pre></div>\n<h1>Limitations</h1>\r<ol><li>You can group at your own risk :) </li>\n<li>The grid does not support property paths with a depth greater than one. ie {Binding Path=Contact.Address.City} </li>\n<li>While the grid supports converters, it does not support StringFormating </li></ol></div><div class=\"ClearBoth\"></div>",
  "TagList": "",
  "LastEdited": "2012-02-06T19:47:30.657-08:00"
}