{
  "ProjectName": "njamb",
  "Title": "NJamb: A C# DSL for more rigorous tests",
  "Description": "NJamb is a C# syntax for tests and DDD specifications. It makes them more readable, faster to write, and more rigorous. Its Linq-style expressions can assert preconditions and postconditions. IntelliSense makes the syntax almost foolproof. And, it's designed to be extended.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\">\r\n<p><strong>Project Description</strong></p>\r\n<p>NJamb is a C# syntax for tests and DDD specifications. It makes them more readable, faster to write, and more rigorous. Its Linq-style expressions can assert preconditions and postconditions. IntelliSense makes the syntax almost foolproof. And, it's designed\r\n to be extended.</p>\r\n<p><strong>Sample NUnit fixture</strong></p>\r\n<p>The classic pattern for unit tests is arrange-act-assert, and the more recent BDD pattern of given-when-then isn't much different.&nbsp; This is fine as far as it goes, but it really only measures outcomes; it doesn't guard against garbage-in-garbage-out.&nbsp;\r\n If the SUT (system under test) happens to be in a state that would pass the test before the &quot;act&quot; or &quot;when&quot;,&nbsp; the test gives a false pass.&nbsp;</p>\r\n<p>An NJamb tests asserts immediately before a change, performs the change, and <em>\r\nonly then</em> measures outcomes.&nbsp; Here's what it looks like in practice:&nbsp;\r\n<strong><br>\r\n</strong></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>[TestFixture]<br><span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> SchoolbusFixture : ExperimentOn&lt;Schoolbus&gt;<br>{<br>    [Test]<br>    <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> CanTransportKids()<br>    {<br>        Expecting(ThatTheCollection(x =&gt; x.Tires).Has.CountOf(6).Always(),<br>            ThatTheCollection(x =&gt; x.Tires).Has.No.ItemsSatisfying(y =&gt; y.Punctured) <span style=\"color:green\">//</span><br>                .AndLater.Has.AtLeast(2).ItemsSatisfying(y =&gt; y.Punctured),<br>            That(x =&gt; x.CanTransportKids()).WillChangeTo(<span style=\"color:blue\">false</span>));<br><br>        Try(x =&gt; x.Tires.First().Punctured = <span style=\"color:blue\">true</span>);<br>    }<br><br>    <span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> Schoolbus TestSubjectFactory()<br>    {<br>        <span style=\"color:blue\">return</span> <span style=\"color:blue\">new</span> Schoolbus();<br>    }<br>}<br></pre>\r\n</div>\r\n<p>The Expecting() method takes IDeltaSpecification&lt;T&gt; arguments. Each of these is a pair of assertions: one about the SUT immediately before a change, and one about the SUT immediately after. By examining the SUT both before and after the change, these\r\n assertions are much more likely to describe the true inputs and outpus of the action.&nbsp;</p>\r\n<p>There are several other benefits to asserting expectations between &quot;arrange&quot; and &quot;act&quot;:</p>\r\n<ol>\r\n<li>It is more <span style=\"text-decoration:underline\">explicit documentation</span> of what the author of the test expects.\r\n</li><li>Because it forces the developer to be explicit, it forces the developer to <span style=\"text-decoration:underline\">\r\nthink about design</span>. </li><li>It can change how you write tests in much the same way that test-first changes how you write production code: when you write a delta assertion before any other part of the test, you can\r\n<span style=\"text-decoration:underline\">use its preconditions to drive the setup of the test</span>. It's a more thoughtful, more focused flow.\r\n</li><li>Preconditions provide a degree of <span style=\"text-decoration:underline\">safety when refactoring</span> tests, especially those with shared setups.&nbsp; Again, like production code.\r\n</li></ol>\r\n<p><strong>Design Principles</strong></p>\r\n<ul>\r\n<li>NJamb is <span style=\"text-decoration:underline\">readable</span>.&nbsp; It makes extensive use of generics, but its syntax is deliberately structured so that the compiler can infer types as you go; you don't have to type angle brackets.\r\n</li></ul>\r\n<ul>\r\n<li>NJamb is <span style=\"text-decoration:underline\">fast to write</span>. Much of its syntax is type-constrained so that its terms are only available when they make.&nbsp; For example,\r\n</li></ul>\r\n<div style=\"color:black; background-color:white\">\r\n<pre style=\"padding-left:30px\">Specify.For(() =&gt; <span style=\"color:blue\">string</span>.Empty).That(x =&gt; x.GetHashCode()).Is.GreaterThan(0)<br></pre>\r\n</div>\r\n<p style=\"padding-left:30px\">is valid syntax because GetHashCode returns an int, which implements IComparable&lt;int&gt;.&nbsp; Thus, string comparisons are only offered to strings; testing for NaN is only offered to float and double; Is.ReadOnly is available\r\n for an ICollection&lt;T&gt; but not for an IEnumerable&lt;T&gt;; etc. Modern VS tools such as ReSharper apply this knowledge as you type.&nbsp; It's better than compile-time checking--it's\r\n<em>compose-time</em> checked.</p>\r\n<ul>\r\n<li>NJamb <span style=\"text-decoration:underline\">specifications are self-describing</span>: their failure messages are highly readable.&nbsp; For example, when the above test fails (correctly) because only one tire has been punctured and two were expected,\r\n the output is: </li></ul>\r\n<pre style=\"padding-left:30px\">expected TestSubject.Tires would have at least 2 items satisfying y =&gt; y.Punctured<br> but had 1 such item.</pre>\r\n<p style=\"padding-left:30px\">There are several aspects of self-describing specifications worth noting:</p>\r\n<blockquote>\r\n<ul>\r\n</ul>\r\n<ol>\r\n<li>NJamb (mostly) <span style=\"text-decoration:underline\">eliminates the need for hand-crafted error messages</span>.&nbsp; You don't have to litter your tests with string literals (hence the name?) that are stale or nonsensical after the first refactor.\r\n</li><li>NJamb <span style=\"text-decoration:underline\">failure strings are lazy</span>: they aren't constructed until the specification has been evaluated and found to fail.\r\n</li><li>NJamb is <span style=\"text-decoration:underline\">smart about printing</span>.&nbsp; The framework's .ToString() of a variable like\r\n</li></ol>\r\n<div style=\"color:black; background-color:white\">\r\n<pre style=\"padding-left:30px\"><span style=\"color:blue\">var</span> list = <span style=\"color:blue\">new</span> List&lt;<span style=\"color:blue\">int</span>&gt;{3, 1, 2};<br></pre>\r\n</div>\r\n<blockquote>is ugly and barely informative:<br>\r\n</blockquote>\r\n<blockquote>\r\n<pre>System.Collections.Generic.List`1[System.Int32]</pre>\r\n</blockquote>\r\n<blockquote>NJamb prints that variable as</blockquote>\r\n<blockquote>\r\n<pre>List&lt;int&gt; {3, 1, 2}</pre>\r\n</blockquote>\r\n</blockquote>\r\n<ul>\r\n<li>NJamb is <span style=\"text-decoration:underline\">extensible</span>. Much of its built-in syntax relies on extension methods: this is how the type-appropriate syntax works, together with generic type parameter constraints. Because the entire DSL is designed\r\n with extension methods in mind, it's full of hooks for your extension methods. They plug right in. You won't even have to recompile the NJamb binaries.\r\n</li><li>NJamb is <span style=\"text-decoration:underline\">strongly (staticly) typed</span>. For example, in the fixture above, the argument to\r\n</li></ul>\r\n<pre style=\"padding-left:30px\">.WillChangeTo(...)</pre>\r\n<p style=\"padding-left:30px\">is constrained to be a bool because the expression</p>\r\n<pre style=\"padding-left:30px\">x =&gt; x.CanTransportKids()</pre>\r\n<p style=\"padding-left:30px\">returns a bool.&nbsp; This is much different than classic NUnit assertion syntax, much of which dates back to the era before .NET generics and to its Java predecessor.</p>\r\n<ul>\r\n<li>NJamb <span style=\"text-decoration:underline\">will work in your test framework</span>. Although it's developed with NUnit and includes helper assemblies out of the box, none of the core of NJamb depends on NUnit. NJamb can be used in any test framework\r\n that allows you to assert a failure with a string explanation. </li></ul>\r\n<p><strong>Roadmap in brief<br>\r\n</strong></p>\r\n<p>Version 0.x and eventually v1 of NJamb is aimed at tests.&nbsp; However, there are at least two other areas of the .NET framework that could benefit from its fluent syntax and self-describing specifications and predicates: DDD-style specifications, and Design\r\n by Contract.&nbsp; Those are planned.</p>\r\n<p>Version 0.1 is being developed in .NET 4.0. Initial builds will target &quot;Any CPU&quot; and not Silverlight.&nbsp; There's not much in NJamb itself that should have problems in SL or .NET 3.x, but some of the reflection helpers, etc., in Stile might not map to\r\n SL easily.&nbsp; As of this writing in Feb 2011, the project is a typical open-source initial release: reasonably feature-complete but under-documented, and seeking an audience.&nbsp; Packaging will depend on demand.</p>\r\n<p><strong>Why's it called NJamb?</strong></p>\r\n<p>It starts with an N because it is of and from .NET.&nbsp; It puns on &quot;enjamb&quot;, which is a term of art in poetry, used when a line breaks in the middle of a sentence, or even a word. According to Wikipedia, &quot;The term is directly borrowed from the\r\n<a title=\"French language\" href=\"http://en.wikipedia.org/wiki/French_language\">French</a>\r\n<em>enjambement</em>, meaning 'straddling' or 'bestriding'.&quot; Straddling is pretty much what the testing side of NJamb is all about: putting an assertion on both sides of a change.</p>\r\n<p>But the main reason is coincidence. Only days before the author of NJamb was going to have to put a name to this project, he drove past a hand-lettered sign outside a heating &amp; airconditioning dealer.&nbsp; He misread the sign because it was in all-caps\r\n and lacked any punctuation.&nbsp; He did a huge double-take and almost missed a stop sign.&nbsp; He had mentally punctuated it this way:</p>\r\n<pre>ENJOY A NEW FIREPLACE!<br>INSERT THIS, WINTER.</pre>\r\n<p>It was mostly the enjambment that threw him. This put the word in his mind and, embarassingly, continues to please him.&nbsp;</p>\r\n<p><strong>What's all that Stile stuff?</strong></p>\r\n<p>That's another project that will probably stand alone soon.&nbsp; It's a collection of helpers, base classes, and implemented patterns.&nbsp; Much of it tries to make the C# system libraries more readable.</p>\r\n<p>For instance, given an IList&lt;T&gt; that you want to make readonly, instead of writing</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">new</span> ReadOnlyCollection&lt;T&gt;(list)<br></pre>\r\n</div>\r\n<p>there's an extension method in Stile that's more terse and more readable:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>list.ToReadOnly()<br></pre>\r\n</div>\r\n<p><strong>Why's that one called Stile?</strong></p>\r\n<p>More punning, I'm afraid. A <em>stile </em>is a sort of bridge over a fence, or an opening in it, design to let people through while keeping livestock in. (The more familiar term\r\n<em>turnstile </em>is a particular variation.) Also, it rhymes with style. The Stile library tries to make it easier for people who know what they're doing to get where they need to go, and maybe even write more expressive code along the way.</p>\r\n</div><div class=\"ClearBoth\"></div>",
  "TagList": "",
  "LastEdited": "2011-05-28T14:16:30.047-07:00"
}