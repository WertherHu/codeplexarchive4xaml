{
  "ProjectName": "classtester",
  "Title": "Automatic Class Tester",
  "Description": "Automatically unit test your model:\n- Automatically test properties, spotting any miswired getters or setters\n- Increase code coverage, reaching parts manual tests don't even try to\n- Supports ignoring specified properties if you have any funky logic in there that needs a manual test \n- Tests for PropertyChanged events if your class implements INotifyPropertyChanged \nTests constructors and that they map parameters to properties \n",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><h1>Welcome to the Class Tester</h1>\rThis project started life as a blog post and some source code (read the <a href=\"http://www.thejoyofcode.com/Automatically_Unit_Test_your_Model.aspx\">original post</a>) but due to public demand (at least 2 comments!) it has now gone open source. The project has undergone a fairly significant refactoring since then with a number of new features and improvements:<br />\n<ul><li>A new <a href=\"https://classtester.codeplex.com/wikipage?title=PropertyTester&referringTitle=Home\">PropertyTester</a>! (formerly the ClassTester)</li>\n<li>A new <a href=\"https://classtester.codeplex.com/wikipage?title=ConstructorTester&referringTitle=Home\">ConstructorTester</a>! (formerly part of the ClassTester)</li>\n<li>A new <a href=\"https://classtester.codeplex.com/wikipage?title=AssemblyTester&referringTitle=Home\">AssemblyTester</a>!</li></ul>\n<br />Click the links above for more information on each of the pieces.<br />\n<h1>Project Description</h1>\rThe idea is pretty simple - a way to easily test your domain classes. You know, the plain old data shapes that look something like this: <br /><br /><pre>\npublic class Person\n{\n    private string _name;\n\n    public string Name\n    {\n        get { return _name; }\n        set { _name = value; }\n    }\n\n    private DateTime _dateOfBirth;\n\n    public DateTime DateOfBirth\n    {\n        get { return _dateOfBirth; }\n        set { _dateOfBirth = value; }\n    }\n\n    // etc..\n}\n</pre><br /><br />Stuff that nobody ever tests directly because it would be so time consuming. I found this very annoying because of the loss of code coverage in my test suite and then disaster struck. I made a change to such code that accidentally broke one of the properties (two different public getters returned the same private string).<br />\n<h2><i>Something had to be done and the Automatic Class Tester project was born!</i></h2>\r<h2>What it can do:</h2>\r<ul><li>Automatically test properties, spotting any miswired getters or setters </li>\n<li>Increase code coverage, reaching parts manual tests don&#39;t even try to </li>\n<li>Supports ignoring specified properties if you have any funky logic in there that needs a manual test </li>\n<li>Tests for PropertyChanged events if your class implements INotifyPropertyChanged </li>\n<li>Tests constructors and that they map parameters to properties </li>\n<li>An exception is thrown when a problem is found which should cause your tests to fail. </li></ul>\n\n<h2>How it works</h2>\rThe PropertyTester simply uses reflection to discover the subject&#39;s properties. Random values are then injected via the property setters and the getter is invoked and the ClassTester verifies that we get the same value back. Here we test our Person class above: <br />\n<ul><li>See <a href=\"https://classtester.codeplex.com/wikipage?title=PropertyTester&referringTitle=Home\">PropertyTester</a> for more information... </li></ul>\n<br /><pre>\n[TestMethod]\npublic void TestPerson()\n{\n    ClassTester tester = new ClassTester(new Person());\n    tester.TestProperties();\n}\n</pre><br /><br />Some properties just can&#39;t be tested in this way, either because they perform some funky logic that is dependant on other state in the class or because they don&#39;t return the same value that was set. Like this nonsensical example below that we&#39;ll add to our person class: <br /><br /><pre>\nprivate int _nonsensicalProperty;\n\npublic DateTime NonsensicalProperty\n{\n    get { return 0; }\n    set { _nonsensicalProperty = value; }\n}\n</pre><br /><br />No problem, we can still use the tester by specifying that this property should be ignored. <br /><br /><pre>\n[TestMethod]\npublic void TestPerson()\n{\n    PropertyTester tester = new PropertyTester(new Person());\n    tester.IgnoredProperties.Add(&quot;NonsensicalProperty&quot;);\n    tester.TestProperties();\n}\n</pre><br />\n<h2>INotifyPropertyChanged support</h2>\rThis is perhaps the most compelling use of the tester given how easy it is to mess up firing the INotifyPropertyChanged due to the lack of compile time support (it&#39;s based on strings). <br /><br /><pre>\npublic class Person : INotifyPropertyChanged\n{\n    private string _name;\n\n    public string Name\n    {\n        get { return _name; }\n        set \n        { \n            _name = value; \n            if (PropertyChanged != null)\n                PropertyChanged(this, new PropertyChangedEventArgs(&quot;Name&quot;));\n        }\n    }\n\n    // etc..\n</pre><br /><br />Again, if a specific property doesn&#39;t support INotifyPropertyChanged for some reason, then just add it to the ignored list and test it manually. <br />\n<h2>Testing Constructors</h2>\r<ul><li>See <a href=\"https://classtester.codeplex.com/wikipage?title=ConstructorTester&referringTitle=Home\">ConstructorTester</a> for more information</li></ul>\n<br />The QualityTools library can also help you test your constructors thanks to the ConstructorTester. It&#39;s a very common practice to create a custom constructor to help inject property values at construction time. Like this: <br /><br /><pre>\npublic class Person\n{\n    public Person(string name, DateTime dateOfBirth)\n    {\n        _name = name;    \n    }\n    \n    // etc\n</pre><br /><br /><pre>\n[Test]\npublic void TestPersonConstructors()\n{\n    ConstructorTester tester = new ConstructorTester(typeof(Person));\n    tester.TestConstructors(true);\n}\n</pre><br /><br />This static method will test all constructors available on the object by creating random values for each parameter (as best it can). Again, if there are some constructors that you need to skip over because they have some funky logic you can add them to a blacklist. Maybe you have to blacklist a particular constructor because it takes a parameter that the ConstructorTester can&#39;t create, like an Interface.<br /><br /><pre>\n[Test]\npublic void TestPersonConstructors()\n{\n    ConstructorTester tester = new ConstructorTester(typeof(Person));\n    // we specify the signature of the constructor to be ignored\n    tester.IgnoredConstructors.Add(typeof(string), typeof(ISomeInterface), typeof(object));\n    tester.TestConstructors(true);\n}\n</pre><br />\n<h2>Testing whole assemblies</h2>\r<ul><li>see <a href=\"https://classtester.codeplex.com/wikipage?title=AssemblyTester&referringTitle=Home\">AssemblyTester</a> for more information</li></ul>\n<br />To help you test large numbers of classes at once there is even an assembly tester that will test all the properties and constructors, of all the classes.<br /><br /><pre>\n[Test]\npublic void AssemblyTester_PassWithExclusions()\n{\n    AssemblyTester tester = new AssemblyTester(&quot;ExampleAssembly&quot;);\n    // exclude a namespace from the test scope but not child namespaces\n    tester.Exclusions.AddNamespace(&quot;ExampleAssembly.SomeNamespace&quot;, false);\n    // first parameters says test properties, second parameter says test constructors\n    tester.TestAssembly(true, true);\n}\n</pre><br /><br />In this example we&#39;re going to test all the types within the ExampleAssembly (obviously, it uses the PropertyTester and ConstructorTester under the covers). We also specifically exclude the ExampleAssembly.SomeNamespace so any types belonging to that namespace won&#39;t be tested.<br /><br /><b>Remember kids!</b> This is just a helper and isn&#39;t intended to remove the need to write unit tests. It&#39;s only there to cover the basic stuff that people don&#39;t normally test. If you exclude a namespace, type, property or constructor then you should consider adding a manual test. </div><div class=\"ClearBoth\"></div>",
  "TagList": "TDD,nunit,C#,vsts,Testing,Unit Test,Unit Testing,testing framework,WPF QA,",
  "LastEdited": "2008-01-04T05:06:26.853-08:00"
}