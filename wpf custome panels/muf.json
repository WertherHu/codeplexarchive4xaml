{
  "ProjectName": "muf",
  "Title": "Monitored Undo Framework",
  "Description": "Monitored Undo Framework is an Undo / Redo framework for .NET applications.",
  "MovedLink": "https://github.com/nathanaw/muf",
  "HomeWiki": "<div class=\"wikidoc\">\r\n<p><span style=\"color:#800000\"><em><strong>(Feb 7, 2013)<br>\r\nRepository Rebased<br>\r\n</strong></em><span style=\"color:#000000\">With the help of </span></span><a href=\"http://www.codeplex.com/site/users/view/mwisnicki\">mwisnicki</a><span style=\"color:#800000\"><span style=\"color:#000000\">, I rebased the source tree to make it more appropriate\r\n for Git. This is completed. If you had a clone or fork of the code, please be aware that the\r\n<span style=\"color:#800000\"><em>history of master has changed</em></span>. It will be stable going forward.</span></span></p>\r\n<p><span style=\"color:#800080\"><em><strong>&nbsp;</strong></em></span></p>\r\n<p><span style=\"color:#800080\"><em><strong></strong></em></span></p>\r\n<hr>\r\n<p><em><strong></strong></em><span style=\"color:#800000\"><em><strong>(Feb 1, 2013</strong></em></span><span style=\"color:#800000\"><em><strong>)</strong></em></span><span style=\"color:#800000\"><em><strong><br>\r\n</strong></em></span><span style=\"color:#800000\"><em><strong>Repository converted to Git&nbsp;</strong></em></span><span style=\"color:#800000\"><em><strong>&nbsp;</strong></em></span>\r\n<br>\r\nThe source code repository for this project has been converted to Git. this should make it simpler and easier for everyone who wants to submit patches and features.</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<hr>\r\n<p><strong>Monitored Undo Framework</strong><br>\r\nMonitored Undo is an Undo / Redo framework that makes it simple for .NET developers to add Undo capabilities to an application. The framework &quot;monitors&quot; changes to the model, keeps a history of undo / redo operations, and assists with applying an undo back\r\n to the model.</p>\r\n<p>&nbsp;</p>\r\n<p><strong>Quick Start...</strong><br>\r\nTo get a quick idea of how it works, check out the <a title=\"Unit Tests\" href=\"SourceControl/changeset/view/124#13930\">\r\nunit tests</a> and the <a href=\"SourceControl/changeset/view/124#13937\">sample model classes</a>.</p>\r\n<p><strong>Sample Application...</strong><br>\r\nThere is a WPF Sample application in the source code tree. This is a very simple app that shows a couple features of the undo framework. It does not follow best practices, but does illustrate how to hook things up.</p>\r\n<p><strong>Reference Application...</strong><br>\r\nFor a more complete example application, please check out my Photo Tagger app. I created this for a .NET Special Interest Group presentation. It covers my &quot;WPF Tales from the Trenches&quot;, including Undo. You can find the\r\n<a title=\"Photo Tagger Reference App\" href=\"http://blog.alner.net/archive/2010/10/13/wpf_ef_4_sig_presentation_2010.aspx\">\r\nPhoto Tagger reference app</a> on my <a title=\"Nathan's Blog\" href=\"http://blog.alner.net\">\r\nblog</a>.</p>\r\n<p><strong>Now on NuGet...</strong><br>\r\nMUF is available on NuGet. You can view details on the <a href=\"http://nuget.org/List/Packages/MUF\">\r\nNuGet Gallery</a> or search for it in the Add Library Reference... dialog via Visual Studio. For you command line types, it's on NuGet as &quot;MUF&quot;.&nbsp; PM&gt; Install-Package MUF</p>\r\n<p>&nbsp;</p>\r\n<hr>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p><em><span style=\"font-size:14pt\">Design</span></em></p>\r\n<p><strong>Design Goals</strong></p>\r\n<p>The implementation has the following design attributes:</p>\r\n<ol>\r\n<li>Flexible design... can be used with a variety of applications. </li><li>Simple usage patterns. </li><li>A &ldquo;change monitoring&rdquo; approach, rather than a &ldquo;command model&rdquo; approach.\r\n</li></ol>\r\n<p>&nbsp;</p>\r\n<p><strong>Change Monitoring vs. Command Model</strong></p>\r\n<p>&ldquo;Change Monitoring&rdquo; is an approach that captures the changes that result from a given action. This is kind of like putting a net under the tree, shaking it, and catching what falls out. The benefit to this approach is simplicity. It requires\r\n relatively straight forward changes to the codebase, minimal up-front design impact, and robust change handling.</p>\r\n<p>The &ldquo;Command Model&rdquo; is the more traditional model for undo, which prescribes that all actions against a system should be done via an object that knows how to perform the action. The assumption is that this object can also include a method that\r\n would undo the action. While this is a better approach from a theoretical perspective, it requires up-front design consideration, and careful implementation. The challenges are:</p>\r\n<p style=\"text-indent:-0.25in\">-<span style=\"font:7pt &quot;Times New Roman&quot;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n</span>Creating command objects that fully understand the downstream consequences of an action, and how to undo them. In a &ldquo;reactive&rdquo; system, this can be challenging to implement since one action could result in a domino-effect of changes throughout\r\n the system.</p>\r\n<p style=\"text-indent:-0.25in\">-<span style=\"font:7pt &quot;Times New Roman&quot;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n</span>Using command objects for all changes to a system prevents usage of other patterns, like WPF&rsquo;s binding system for two-way bindings. A pure command based implementation would only be able to use one-way bindings, preferring to push updates through\r\n a command rather than a binding.</p>\r\n<p>The above discussion provides the background for the decision to use &ldquo;change monitoring&rdquo; in this implementation.<em><span style=\"font-size:14pt\">\r\n</span></em></p>\r\n<p>&nbsp;</p>\r\n<hr>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p><em><span style=\"font-size:14pt\">Classes</span></em></p>\r\n<p><strong>UndoService</strong></p>\r\n<p><span><span style=\"font-size:10pt\">UndoService</span></span> is the top level of the undo / redo system. It contains one or more\r\n<span><span style=\"font-size:10pt\">UndoRoot</span></span>s, accessible via the indexer on the\r\n<span><span style=\"font-size:10pt\">UndoService</span></span>.</p>\r\n<p><span><span style=\"font-size:10pt\">UndoService.Current</span></span> property will return the singleton instance of the\r\n<span><span style=\"font-size:10pt\">UndoService</span></span>. Use this when interacting with the undo service.</p>\r\n<p><span><span style=\"font-size:10pt\">UndoService.Current[modelRoot]</span></span> will return an instance of\r\n<span><span style=\"font-size:10pt\">UndoRoot</span></span> for the specified <span>\r\n<span style=\"font-size:10pt\">modelRoot</span></span>.</p>\r\n<p>&nbsp;</p>\r\n<p><strong>UndoRoot</strong></p>\r\n<p><span><span style=\"font-size:10pt\">UndoRoot</span></span> collects changes related to a specific document or instance of a model. This allows an application to track multiple, distinct undo stacks. This class has most of the public API methods that you&rsquo;ll\r\n use to undo, redo, and add changes.</p>\r\n<p>Contains FIFO stacks of <span><span style=\"font-size:10pt\">ChangeSet</span></span>s for undo and redo actions. Includes the logic to manage the undo and redo stacks. For example, the redo stack is cleared whenever a new undo\r\n<span><span style=\"font-size:10pt\">ChangeSet</span></span> is added.</p>\r\n<p><span><span style=\"font-size:10pt\">UndoRoot.Undo()</span></span> will undo the last operation. (Overloads available)</p>\r\n<p><span><span style=\"font-size:10pt\">UndoRoot.Redo()</span></span> will redo the last operation. (Overloads available)</p>\r\n<p><span><span style=\"font-size:10pt\">UndoRoot.AddChange()</span></span> will add a new\r\n<span><span style=\"font-size:10pt\">Change</span></span> to the system. <span><span style=\"font-size:10pt\">ChangeSets</span></span> are automatically created as needed.</p>\r\n<p><span><span style=\"font-size:10pt\">UndoRoot.Clear()</span></span> will clear the undo and redo stacks.</p>\r\n<p><strong>&nbsp;</strong></p>\r\n<p><strong>ChangeSet</strong></p>\r\n<p><span><span style=\"font-size:10pt\">ChangeSet</span></span> has a collection of\r\n<span><span style=\"font-size:10pt\">Change</span></span> instances. It represents a unit of undo or redo work.</p>\r\n<p><span><span style=\"font-size:11.5pt\">&nbsp;</span></span></p>\r\n<p><span><span style=\"font-size:11.5pt\">Change</span></span></p>\r\n<p>Change is an individual action to perform when undoing or redoing a <span><span style=\"font-size:10pt\">ChangeSet</span></span>. The Change class contains\r\n<span><span style=\"font-size:10pt\">Action()</span></span> delegates (or lambdas) that perform the undo and redo operations.</p>\r\n<p>&nbsp;</p>\r\n<p><strong>UndoBatch </strong></p>\r\n<p>Is a &quot;scope based&quot; helper that can group changes into a single <span><span style=\"font-size:10pt\">ChangeSet</span></span>. It detects new\r\n<span><span style=\"font-size:10pt\">Change</span></span>s that occur and automatically groups them into a single\r\n<span><span style=\"font-size:10pt\">ChangeSet</span></span>.</p>\r\n<p><span><span style=\"font-size:10pt\">UndoBatch</span></span> is designed similarly to the\r\n<span><span style=\"font-size:10pt\">TransactionScope</span></span> class in the .NET framework. It is most useful via a\r\n<span><span style=\"font-size:10pt\">using</span></span> block that contains a set of changes.\r\n<span><span style=\"font-size:10pt\">UndoBatch</span></span> will start a new batch at the start of the\r\n<span><span style=\"font-size:10pt\">using</span></span> block and then close that batch at the end of the\r\n<span><span style=\"font-size:10pt\">using</span></span> statement, when the <span>\r\n<span style=\"font-size:10pt\">Dispose</span></span> method is called.</p>\r\n<p><span><span style=\"font-size:10pt\">UndoBatch</span></span> supports nested usage, but will only ever start a single\r\n<span><span style=\"font-size:10pt\">ChangeSet</span></span>. This means that the top-most\r\n<span><span style=\"font-size:10pt\">UndoBatch</span></span> controls the batching boundary.</p>\r\n<p><span><span style=\"font-size:11.5pt\">&nbsp;</span></span></p>\r\n<p><span><span style=\"font-size:11.5pt\">DefaultChangeFactory</span></span></p>\r\n<p><span><span style=\"font-size:10pt\">DefaultChangeFactory</span></span> is a static utility class that helps populate the undo system with\r\n<span><span style=\"font-size:10pt\">ChangeSet</span></span> and <span><span style=\"font-size:10pt\">Change</span></span> instances. The default implementation uses reflection to access the properties of a class.</p>\r\n<p>If implemented, the DefaultChangeFactory will take advantage of the interfaces (mentioned below) to allow more control over the undo / redo process.</p>\r\n<p><em><span style=\"font-size:14pt\">&nbsp;</span></em></p>\r\n<p><em><span style=\"font-size:14pt\">Interfaces </span></em></p>\r\n<p>The following are used by the <span><span style=\"font-size:10pt\">DefaultChangeFactory</span></span> and other change factories. The interfaces make it simple for these factories to create the undo / redo actions and provide the class a way to intercept or\r\n influence this process.</p>\r\n<p><strong>ISupportsUndo</strong></p>\r\n<p>Should be implemented on classes that want to participate in undo / redo operations.</p>\r\n<p><span><span style=\"font-size:10pt\">ISupportsUndo.GetUndoRoot()</span></span> should be implemented and return a reference to the &ldquo;model root&rdquo; or &ldquo;document root&rdquo; that represents the undo boundary.</p>\r\n<p>This is not required to use the undo system, but is required by the <span><span style=\"font-size:10pt\">DefaultChangeFactory</span></span>.</p>\r\n<p><strong>ISupportsUndoNotification </strong></p>\r\n<p>An optional interface that helps classes react to undo and redo operations.</p>\r\n<p>This is not required to use the undo system, but is required by the <span><span style=\"font-size:10pt\">DefaultChangeFactory</span></span>.</p>\r\n<p><strong>IUndoMetadata </strong></p>\r\n<p>Allows a class to influence whether a given property or collection change should be tracked for undo.</p>\r\n<p>This is not required to use the undo system, but is required by the <span><span style=\"font-size:10pt\">DefaultChangeFactory</span></span>.</p>\r\n<p><em><span style=\"font-size:14pt\">&nbsp;</span></em></p>\r\n<p><em><span style=\"font-size:14pt\">&nbsp;</span></em></p>\r\n<p><em><span style=\"font-size:14pt\">Class Diagram</span></em></p>\r\n<p><a href=\"http://download.codeplex.com/download?ProjectName=muf&DownloadId=155349\"><img title=\"UndoClassDiagram\" src=\"http://download.codeplex.com/download?ProjectName=muf&DownloadId=155350\" border=\"0\" alt=\"UndoClassDiagram\" width=\"662\" height=\"722\" style=\"padding-left:0px; padding-right:0px; display:inline; padding-top:0px; border:0\"></a></p>\r\n<p><em><span style=\"font-size:14pt\">&nbsp; </span></em></p>\r\n<p><em>&nbsp;</em></p>\r\n<p><em>&nbsp;</em></p>\r\n<hr>\r\n<p><em>&nbsp;</em></p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p><em><span style=\"font-size:14pt\">Notes and Common Issues</span></em></p>\r\n<p><strong>Step Zero&hellip; Review the Unit Tests!</strong></p>\r\n<p>The <span style=\"text-decoration:underline\">unit tests</span> for the Undo system is a great place to start. It will show you the way that the classes are supposed to be used, and you can even step through them in debug to understand how things work.</p>\r\n<p><strong>&ldquo;Undo doesn&rsquo;t seem to work&hellip;&rdquo;</strong></p>\r\n<p>If you are hitting &ldquo;Undo&rdquo;, but your user interface isn&rsquo;t changing, then the problem might be with your\r\n<span><span style=\"font-size:10pt\">INotifyPropertyChanged</span></span> (aka INPC) implementation. Often times, the Undo service is actually undoing the changes by updating the model and/or view models. However, if your UI is bound to a property that doesn&rsquo;t\r\n raise the <span><span style=\"font-size:10pt\">PropertyChanged</span></span> or <span>\r\n<span style=\"font-size:10pt\">CollectionChanged</span></span> event when the underlying model changes, then the UI won&rsquo;t update.</p>\r\n<p>One way to check this is to undo some actions, save the model, and then re-open the model. If the values are undone, then there is an &ldquo;INotifyPropertyChanged&rdquo; gap between the UI&rsquo;s bound property and the underlying model.</p>\r\n<p><strong>&ldquo;I need to group a set of changes together&hellip;&rdquo;</strong></p>\r\n<p>In some cases, you want to click &ldquo;Undo&rdquo; and have it undo a set of changes, not just one change. To do this, you&rsquo;ll need to use the\r\n<span><span style=\"font-size:10pt\">UndoBatch</span></span> class to group these changes.</p>\r\n<p>Example:</p>\r\n<p style=\"margin-bottom:0pt\"><span style=\"font-family:consolas; font-size:10pt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<span style=\"color:#2b91af\">TestMethod</span>]\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">public</span>&nbsp;<span style=\"color:blue\">void</span> UndoRoot_Supports_Starting_a_Batch_Of_Changes()\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">\r\nvar</span> orig = Document1.A.Name; <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">\r\nvar</span> firstChange = <span style=\"color:#a31515\">&quot;First Change&quot;</span>; <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">\r\nvar</span> secondChange = <span style=\"color:#a31515\">&quot;Second Change&quot;</span>; <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">\r\nvar</span> root = <span style=\"color:#2b91af\">UndoService</span>.Current[Document1];\r\n<br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:blue\">\r\nusing</span> (<span style=\"color:blue\">new</span>&nbsp;<span style=\"color:#2b91af\">UndoBatch</span>(Document1,\r\n<span style=\"color:#a31515\">&quot;Change Name&quot;</span>, <span style=\"color:blue\">false</span>))\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Document1.A.Name = firstChange;\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Document1.A.Name = secondChange;\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:#2b91af\">\r\nAssert</span>.AreEqual(1, root.UndoStack.Count()); <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:#2b91af\">\r\nAssert</span>.AreEqual(0, root.RedoStack.Count()); <br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root.Undo(); <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:#2b91af\">\r\nAssert</span>.AreEqual(orig, Document1.A.Name); <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:#2b91af\">\r\nAssert</span>.AreEqual(0, root.UndoStack.Count()); <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:#2b91af\">\r\nAssert</span>.AreEqual(1, root.RedoStack.Count()); <br>\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root.Redo(); <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:#2b91af\">\r\nAssert</span>.AreEqual(secondChange, Document1.A.Name); <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:#2b91af\">\r\nAssert</span>.AreEqual(1, root.UndoStack.Count()); <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color:#2b91af\">\r\nAssert</span>.AreEqual(0, root.RedoStack.Count()); <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>\r\n<p>&nbsp;</p>\r\n<p><strong>&ldquo;I&rsquo;m doing a mouse operation or a calculation that is changing the same field multiple times within the same undo batch. I only need the last value.&rdquo;</strong></p>\r\n<p>If you have a mouse based operation, then your model or view model might be changing repeatedly as the user drags the mouse around. This can result in one\r\n<span><span style=\"font-size:10pt\">Change</span></span> for each discrete position of the mouse.</p>\r\n<p>Typically, the system and the undo service only need to remember the last value. Undoing the operation reverts to the original value before dragging the mouse. Redoing applies the value from when they stopped dragging the mouse. All intermediate values are\r\n irrelevant.</p>\r\n<p>To handle this scenario, the top level <span><span style=\"font-size:10pt\">UndoBatch</span></span> constructor takes the\r\n<span><span style=\"font-size:10pt\">bool</span></span> <span><span style=\"font-size:10pt\">consolidateChangesForSameInstance</span></span> parameter. This parameter will tell the undo system that it should only keep the last value for each changed property within\r\n the batch.</p>\r\n<p><em><span style=\"text-decoration:underline\">Note:</span> <br>\r\nThis functionality takes a little more processing time, but reduces the memory used.</em></p>\r\n<p><em><span style=\"text-decoration:underline\">Note:</span> <br>\r\nThis functionality requires that the </em><span><em><span style=\"font-size:10pt\">Change</span></em></span><em> instance have a reliable &ldquo;token&rdquo; to uniquely identify the property that it is for. The built-in\r\n</em><span><em><span style=\"font-size:10pt\">DefaultChangeFactory</span></em></span><em> class handles this automatically, but if you are manually creating\r\n</em><span><em><span style=\"font-size:10pt\">Change</span></em></span><em> instances, you&rsquo;ll need to ensure that you have a unique &ldquo;token&rdquo; for the property. A simple implementation is to use the\r\n</em><span><em><span style=\"font-size:10pt\">Tuple&lt;&gt;</span></em></span><em> class with a sufficient number of parameters to uniquely identify the object instance, and the property on that instance. See the\r\n</em><span><em><span style=\"font-size:10pt\">DefaultChangeFactory</span></em></span><em> for an example of this.</em></p>\r\n<p>&nbsp;</p>\r\n<p><em><span style=\"font-size:14pt\">&nbsp;</span></em></p>\r\n<p><em><span style=\"font-style:normal; letter-spacing:0pt; color:windowtext; font-size:14pt; font-weight:normal\">&nbsp;</span></em></p>\r\n</div><div class=\"ClearBoth\"></div>",
  "TagList": ".net,Undo,undo redo,.NET 4.0,WPF,redo,monitoring,Undo Framework,",
  "LastEdited": "2013-02-07T11:36:50.493-08:00"
}