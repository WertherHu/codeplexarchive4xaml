{
  "ProjectName": "usefultools",
  "Title": "UsefulTools for .NET and WPF",
  "Description": "A collection of useful extension methods and utility classes for .NET in general and WPF.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><h1>Project Description</h1>\rA collection of useful extension methods and utility classes for .NET in general and WPF.<br /><br /><b>Get it from nuget:</b><br /><a href=\"https://www.nuget.org/packages/UsefulTools/\">https://www.nuget.org/packages/UsefulTools/</a><br /><a href=\"https://www.nuget.org/packages/UsefulTools.Wpf/\">https://www.nuget.org/packages/UsefulTools.Wpf/</a><br />\n<h1>Features</h1>\r\n<b>Checkboxed tree with state</b><br /><br />A customizable tree data structure with parent-child relationship for checkboxes and custom state.\n<ul><li>Check events propagate changes up and down in hierarchy</li>\n<li>State change events may propagate up or down the hierarchy as defined by user</li>\n<li>Supports NotifyPropertyChanged</li></ul>\nHere is an example scenario:<br />There is a tree structure with several states: Idle, Working, Error. Any parent node should change state according to its children, and sometimes all children should change state according to parent.\n<ol><li>Idle is the initial state, so (for easy setup) setting it on a root node should propagate down to all children.</li>\n<li>Working is a state of individual leaf and it should propagate up the hierarchy to indicate that some node in that sub-tree is working.</li>\n<li>Error is a state of individual leaf and should propagate up the hierarchy, but it is of higher importance than Working. A parent should have an Error state even if some of its children are Working and one has an Error.</li></ol>\n<br /><b>Functional switch</b><br /><br />Based on an idea by Bart de Smet: <a href=\"http://bartdesmet.net/blogs/bart/archive/2008/03/30/a-functional-c-type-switch.aspx\">http://bartdesmet.net/blogs/bart/archive/2008/03/30/a-functional-c-type-switch.aspx</a><br /><br />A switch-like construct for general purpose use:\n<ul><li>Might be an expression (has a value) instead of a statement</li>\n<li>Allows any type to compare against</li>\n<li>Allows delegates as results </li>\n<li>Can throw exception if no match is found</li>\n<li>Is strongly typed</li></ul>\n<br />Functional switch with constants as results:<br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> state = State.Active;\n<span style=\"color:Blue;\">string</span> message = Switch.Into&lt;<span style=\"color:Blue;\">string</span>&gt;().From(state)\n    .Case(State.Active, <span style=\"color:#A31515;\">&quot;Working.&quot;</span>)\n    .Case(State.Inactive, State.Idle, <span style=\"color:#A31515;\">&quot;Not working.&quot;</span>)\n    .Case(State.Error, <span style=\"color:#A31515;\">&quot;Broken.&quot;</span>)\n    .Default(<span style=\"color:#A31515;\">&quot;No info&quot;</span>);\n\nAssert.AreEqual(<span style=\"color:#A31515;\">&quot;Working.&quot;</span>, message);\r\n</pre></div><br />Switch as statement with actions or no operation on match. Throws an exception if no match:<br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> state = State.Active;\nSwitch.On(state)\n    .Case(State.Active, DoWork)\n    .CaseNop(State.Inactive, State.Idle)\n    .Case(State.Error, () =&gt; ShowError(<span style=\"color:#A31515;\">&quot;Bad.&quot;</span>))\n    .ThrowIfNoMatch();\r\n</pre></div><br />Cascading &quot;collection&quot; switch:\n<ul><li>Result is based on prioritized cases that match some or all items in a collection</li>\n<li>Useful if scenarios with state values hierarchy (e.g. TreeView)</li></ul>\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> strings = <span style=\"color:Blue;\">new</span>[] { <span style=\"color:#A31515;\">&quot;A&quot;</span>,<span style=\"color:#A31515;\">&quot;C&quot;</span>, <span style=\"color:#A31515;\">&quot;A&quot;</span>,<span style=\"color:#A31515;\">&quot;C&quot;</span>,<span style=\"color:#A31515;\">&quot;B&quot;</span>,<span style=\"color:#A31515;\">&quot;A&quot;</span>,<span style=\"color:#A31515;\">&quot;A&quot;</span>,};\n\nString result1 = Switch.Into&lt;<span style=\"color:Blue;\">string</span>&gt;().AsCascadingCollectiveOf(strings)\n    .CaseAny(<span style=\"color:#A31515;\">&quot;B&quot;</span>, <span style=\"color:#A31515;\">&quot;B&quot;</span>) <span style=\"color:Green;\">// This (first CaseAny) has the heighest priority.</span>\n    .CaseAny(<span style=\"color:#A31515;\">&quot;C&quot;</span>, <span style=\"color:#A31515;\">&quot;C&quot;</span>) <span style=\"color:Green;\">// This has a lower priority.</span>\n    .CaseAll(<span style=\"color:#A31515;\">&quot;A&quot;</span>, <span style=\"color:#A31515;\">&quot;A&quot;</span>) <span style=\"color:Green;\">// Only one CaseAll allowed. Lowest priority.</span>\n    .GetValue();\nAssert.AreEqual(<span style=\"color:#A31515;\">&quot;B&quot;</span>, result1);\n\nString result2 = Switch.Into&lt;<span style=\"color:Blue;\">string</span>&gt;().AsCascadingCollectiveOf(strings)\n    .CaseAny(<span style=\"color:#A31515;\">&quot;D&quot;</span>, <span style=\"color:#A31515;\">&quot;D&quot;</span>) \n    .CaseAny(<span style=\"color:#A31515;\">&quot;C&quot;</span>, <span style=\"color:#A31515;\">&quot;C&quot;</span>) \n    .CaseAll(<span style=\"color:#A31515;\">&quot;B&quot;</span>, <span style=\"color:#A31515;\">&quot;B&quot;</span>) \n    .GetValue();\nAssert.AreEqual(<span style=\"color:#A31515;\">&quot;C&quot;</span>, result2);\r\n</pre></div><br /><b>Threading</b><br /><br />Thought as a handy way for scheduling asynchronous tasks from GUI (WPF) before .NET 4.5, it can still be useful for some cases. Like &#39;async&#39; feature, it can be used to schedule some work on background thread and when it&#39;s done, invoke some actions on the GUI thread. It also provides an easy way to handle any exceptions on GUI thread even when they originated on background thread. <br /><br />Typical usage. Parameters onGui, onException, onFinally are optional:<br /><div style=\"color:Black;background-color:White;\"><pre>\r\n_threading.ScheduleAsync(() =&gt;\n{\n    <span style=\"color:Green;\">//Invoke background operations for result</span>\n    <span style=\"color:Blue;\">return</span> DownloadResult();\n},\nonGui: result =&gt;\n{\n    <span style=\"color:Green;\">//Do something with result on gui thread</span>\n    ShowOnGui(result);\n},\nonException: () =&gt;\n{\n    <span style=\"color:Green;\">//Do cleanup on gui thread</span>\n    DoCleanup();\n},\nonFinally: () =&gt;\n{\n    <span style=\"color:Green;\">//Always invoked, on gui thread</span>\n    CloseResources();\n});\r\n</pre></div><br /><b>Progress counter</b><br /><br />A progress counter with percent complete indication:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">int</span> currentValue = 0;\n<span style=\"color:Blue;\">var</span> progressCounter = ProgressCounter.Invoking(percentCompleted =&gt;\n{\n    currentValue = percentCompleted;\n});\n\n<span style=\"color:Green;\">// Initialize with max value</span>\nprogressCounter.Initialize(20);\n\ncurrentValue.ShouldEqual(0);\n\nprogressCounter.Progress();\ncurrentValue.ShouldEqual(5);\r\n</pre></div>\n<h2>Support for Model-View-ViewModel-Controller pattern</h2>\r\n<ul><li>ModelElement base class - supports property change notification</li>\n<li>Controller base class - should contain application logic. Governs one or more viewmodels, may use and create other controllers.</li>\n<li>ViewModel base class - encompasses dependency properties and possibly data presentation logic. Governs one view, but may also contain sub-viewmodels.</li>\n<li>IView interface - implemeted by a custom WPF window or user control.</li></ul>\n<br /><b>The ModelElement base class</b><br />\n<ul><li>A SetAndRise method as a convenient way for invoking property change notification</li></ul>\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">public</span> ReadOnlyCollection&lt;TestNodeNamespace&gt; Namespaces\n{\n    <span style=\"color:Blue;\">get</span>\n    {\n        <span style=\"color:Blue;\">return</span> _namespaces;\n    }\n    <span style=\"color:Blue;\">set</span>\n    {\n        SetAndRise(<span style=\"color:Blue;\">ref</span> _namespaces, value, () =&gt; Namespaces);\n    }\n}\r\n</pre></div><br /><b>The ViewModel base class (derived from ModelElement)</b>\n<ul><li>A strongly typed View property for accessing the corresponding view</li>\n<li>A RegisterPropertyChanged method for capturing a property change as IObservable</li></ul>\n<div style=\"color:Black;background-color:White;\"><pre>\r\n_viewModel.RegisterPropertyChanged(_=&gt;_.SelectedTabHeader)\n    .Where(header =&gt; _currentMutant != <span style=\"color:Blue;\">null</span>)\n    .Subscribe(LoadData);\r\n</pre></div><br /><b>SmartCommand</b><br /><br />A bindable command class for WPF with additional features:\n<ul><li>The update of its CanExecute state may be bound to a dependency property change - no need to raise the CanExecuteChanged event.</li>\n<li>Its execution may be bound to a dependency property change.</li>\n<li>Supports fluent configuration</li></ul>\n<div style=\"color:Black;background-color:White;\"><pre>\r\n_viewModel.CommandCreateMutants = <span style=\"color:Blue;\">new</span> SmartCommand(AcceptChoices,\n    () =&gt; _viewModel.TypesTreeMutate.Assemblies.Count != 0\n        &amp;&amp; _viewModel.TypesTreeToTest.Namespaces.Count != 0\n        &amp;&amp; _viewModel.MutationsTree.MutationPackages.Count != 0)\n        .UpdateOnChanged(_viewModel.TypesTreeMutate, _ =&gt; _.Assemblies)\n        .UpdateOnChanged(_viewModel.TypesTreeToTest, _ =&gt; _.Namespaces)\n        .ExecuteOnChanged(_viewModel, _ =&gt; _.RunRequest);\r\n</pre></div>\n<h2>Other</h2>\r\n<b>Extension methods</b><br /><br />SelectManyRecursive - a method of selecting nodes in a tree structure by several criteria:<br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> o = <span style=\"color:Blue;\">new</span> Node(0, <span style=\"color:#A31515;\">&quot;o&quot;</span>);\n    <span style=\"color:Blue;\">var</span> a = <span style=\"color:Blue;\">new</span> Node(1, <span style=\"color:#A31515;\">&quot;a&quot;</span>);\n        <span style=\"color:Blue;\">var</span> ab = <span style=\"color:Blue;\">new</span> Node(0, <span style=\"color:#A31515;\">&quot;ab&quot;</span>);\n            <span style=\"color:Blue;\">var</span> aba = <span style=\"color:Blue;\">new</span> Node(1, <span style=\"color:#A31515;\">&quot;aba&quot;</span>);\n    <span style=\"color:Blue;\">var</span> b = <span style=\"color:Blue;\">new</span> Node(0, <span style=\"color:#A31515;\">&quot;b&quot;</span>);\n        <span style=\"color:Blue;\">var</span> ba = <span style=\"color:Blue;\">new</span> Node(0, <span style=\"color:#A31515;\">&quot;ba&quot;</span>);\n            <span style=\"color:Blue;\">var</span> baa = <span style=\"color:Blue;\">new</span> Node(1, <span style=\"color:#A31515;\">&quot;baa&quot;</span>);\n            <span style=\"color:Blue;\">var</span> bab = <span style=\"color:Blue;\">new</span> Node(0, <span style=\"color:#A31515;\">&quot;bab&quot;</span>);\n            <span style=\"color:Blue;\">var</span> bac = <span style=\"color:Blue;\">new</span> Node(1, <span style=\"color:#A31515;\">&quot;bac&quot;</span>);\n                <span style=\"color:Blue;\">var</span> baca = <span style=\"color:Blue;\">new</span> Node(1, <span style=\"color:#A31515;\">&quot;baca&quot;</span>);\n\no.Children.AddRange(<span style=\"color:Blue;\">new</span>[] {a, b});\na.Children.AddRange(<span style=\"color:Blue;\">new</span>[] {ab});\nab.Children.AddRange(<span style=\"color:Blue;\">new</span>[] {aba});\nb.Children.AddRange(<span style=\"color:Blue;\">new</span>[] {ba});\nba.Children.AddRange(<span style=\"color:Blue;\">new</span>[] {baa, bab, bac});\nbac.Children.AddRange(<span style=\"color:Blue;\">new</span>[] {baca});\n\n<span style=\"color:Green;\">// Traverse all nodes in the tree by following Children property and follow and select only if Val == 0</span>\n<span style=\"color:Blue;\">var</span> result = <span style=\"color:Blue;\">new</span>[] {o}.SelectManyRecursive(n =&gt; n.Children, n =&gt; n.Val == 0).ToList();\nCollectionAssert.AreEquivalent(<span style=\"color:Blue;\">new</span>[] { <span style=\"color:#A31515;\">&quot;o&quot;</span>, <span style=\"color:#A31515;\">&quot;b&quot;</span>, <span style=\"color:#A31515;\">&quot;ba&quot;</span>, <span style=\"color:#A31515;\">&quot;bab&quot;</span> }, result.Select(_ =&gt; _.Text));\n<span style=\"color:Green;\">// The &quot;ab&quot; element was not selected because its parent&#39;s Val != 0</span>\n\r\n</pre></div><br /><b>Paths</b><br />Largely based on NDepend.Helpers.FileDirectoryPath by SMACCHIA.COM SARL: <a href=\"http://filedirectorypath.codeplex.com/\">http://filedirectorypath.codeplex.com/</a><br /><br />Utility classes providing abstractions and methods for dealing with paths.<br />\n<h1>Configuration</h1>\r\nExample configuration for Ninject (<a href=\"http://www.ninject.org/\">http://www.ninject.org/</a>):<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\nBind&lt;IMessageService&gt;().To&lt;MessageService&gt;().InSingletonScope();\nBind&lt;IEventService&gt;().To&lt;EventService&gt;().InSingletonScope();\nBind&lt;IThreading&gt;().To&lt;Threading&gt;().InSingletonScope();\nBind&lt;CommonServices&gt;().ToSelf().InSingletonScope();\nBind&lt;IFileSystem&gt;().To&lt;FileSystemService&gt;().InSingletonScope();\nBind&lt;IThreadPoolExecute&gt;().To&lt;ThreadPoolExecute&gt;();\n\n<span style=\"color:Blue;\">var</span> exe = <span style=\"color:Blue;\">new</span> DispatcherExecute();\nexe.InitializeWithDispatcher();\nBind&lt;IDispatcherExecute&gt;().ToConstant(exe);\r\n</pre></div><br />I would appreciate any suggestions!\n<hr />--------------<br />by Piotr Trzpil</div><div class=\"ClearBoth\"></div>",
  "TagList": ".NET,C#,Functional,MVVM,WPF,useful,tools,utils,utility,library,switch,tree,",
  "LastEdited": "2013-11-11T08:30:31.877-08:00"
}