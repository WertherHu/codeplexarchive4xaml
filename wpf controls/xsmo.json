{
  "ProjectName": "xsmo",
  "Title": "SQL Management Objects Versioning Control (xSMO)",
  "Description": "script TO and FROM a SQL server database with a command line tool",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><b>SQL Server Database Build Utility (SMO)</b><br /><br />Quite a few years ago, I was working on a large scale ETL project with some large scale databases that had thousands of objects that needed to be versioned for conversion runs happening in parallel.<br /><br />There were a few requirements about keeping these objects under source control, being able to build databases from source along with being able to script a database to file. The whole database scripting engine supplied in SSMS was great -- but wouldn&#39;t make the mark as an administrative task each time around. At the time, using a toolset like RedGate wasn&#39;t an option.<br /><br /> I wrote this little component to do two jobs using the SQL Server Management Objects (SMO) assemblies:<br />\n<ul><li>Consume a SQL server database to script, each object to a logical file in a typed folder hierarchy:</li>\n<li>Produce a SQL server database, from loose object scripts in a typed folder hierarchy</li></ul>\n<br /><b>Implementation</b><br /><br />Given that I&#39;m picky when it comes to naming, I created a naming schema of {schema}.{object}.{type}.sql to be able to power script through my objects as necessary, or visually identify them in a snap.<br /><br /><b>Object naming examples: </b><br />\n<ul><li>Reference.ConfigurationNameingSchemas.Table.sql  </li>\n<li>Reference.uspCOREGetConfigurationNamingChanges.StoredProcedure.sql </li>\n<li>PK<i>Core</i>ConfigurationNamingSchemas.ClusteredIndex.sql  </li></ul>\n<br />Also ended up creating a simple folder hierarchy like so: \n<ul><li>Database Name\n<ul><li>Schema  </li>\n<li>Synonym  </li>\n<li>Table  </li>\n<li>Constraint </li>\n<li>View  </li>\n<li>Stored Procedure  </li>\n<li>Function  </li>\n<li>Index  </li>\n<li>Clustered Index  </li>\n<li>Foreign Key  </li>\n<li>Trigger  </li>\n<li>UserType </li>\n<li>UserTypeTable  </li>\n<li>SetupScript </li></ul></li></ul>\n<br /><b>Getting Started:</b><br /><br />You have two dependencies,\n<ul><li>will need Microsoft Sql Management Objects installed.  </li>\n<li>need the source provided.  </li></ul>\n<br />The source is attached and for the most part does pretty much what the SQL server scripting utility does with a few extra features like indexing a database, removing all indexes in a database.<br /><br />Once you build the project, one would call the executable in the following scenarios: \n<ul><li><i>myDatabaseName = keyname in the app.config for your dbConnection</i></li>\n<li><i>targetFolderName = name of folder to script files</i></li></ul>\n<br /><u>Script FROM a DATABASE to FOLDER STRUCTURE</u>\n<ul><li>SMOOperator mode=from connectionName=myDatabaseName logicalName=targetFolderName </li></ul>\n<br /><u>Script TO a DATABASE from a FOLDER STRUCTURE (it will drop all objects in the catalog)</u>\n<ul><li>SMOOperator mode=to connectionName=myDatabaseName logicalName=sourceFolderName  </li></ul>\n<br />Be warned, scripting TO a database will drop all of the contents in the database. <br /><br />There is some other functionality for indexing a database (applying all of the clustered / non-clustered indexes in the source folder) to a database, if they don&#39;t already exist.<br /><br />Also, there is a loose folder called &#39;SetupScripts&#39; which has it&#39;s contents executed after the TO scripting job is finished -- so if you had some data insert scripts needed, this is a good place to put them. </div><div class=\"ClearBoth\"></div>",
  "TagList": "SMO,Database scripting,SQL scripting,",
  "LastEdited": "2014-02-06T13:07:59.743-08:00"
}