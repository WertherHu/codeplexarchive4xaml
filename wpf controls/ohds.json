{
  "ProjectName": "ohds",
  "Title": "Object Hierarchical Data Source",
  "Description": "ObjectHierarchicalDataSource is to hierarchical data sources what ObjectDataSource is to tabular data sources. It enables the page developer to declaratively bind hierarchical controls such as Menu and TreeView to almost any object graph.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><b>Project Description</b><br />ObjectHierarchicalDataSource is to hierarchical data sources what ObjectDataSource is to tabular data sources. It enables the page developer to declaratively bind hierarchical controls such as Menu and TreeView to almost any object graph.<br /><br />While there is a very handy ObjectDataSource control in ASP.NET 2.0, it does not have a hierarchical equivalent. Basically, the idea would be to declaratively bind a hierarchical control to an arbitrary object graph.<br /> <br />Enter the ObjectHierarchicalDataSource, which transfers many of the nice ideas in ObjectDataSource to the hierarchical realm.<br />Here&#39;s how you can use it:<br /> <br /><pre>\n&lt;my:ObjectHierarchicalDataSource runat=server ID=ObjectInstance1 TypeName=&quot;Categories&quot;&gt;\n  &lt;SelectMethods&gt;\n    &lt;my:SelectMethod TypeName=&quot;CatsCategory&quot; Method=&quot;GetCats&quot; /&gt;\n    &lt;my:SelectMethod TypeName=&quot;Cat&quot; PropertyNames=&quot;Color,Gender&quot; /&gt;\n  &lt;/SelectMethods&gt;\n&lt;/my:ObjectHierarchicalDataSource&gt;\n\n&lt;asp:TreeView Runat=Server ID=categoryTree DataSourceID=ObjectInstance1\n    ExpandDepth=0 PopulateNodesFromClient=true&gt;\n  &lt;DataBindings&gt;\n    &lt;asp:TreeNodeBinding TextField=&quot;#&quot; ValueField=&quot;#&quot; ToolTipField=&quot;#&quot; PopulateOnDemand=true /&gt;\n    &lt;asp:TreeNodeBinding DataMember=&quot;CatsCategory&quot; TextField=&quot;Name&quot; ValueField=&quot;Name&quot;\n      ToolTipField=&quot;Name&quot; PopulateOnDemand=true /&gt;\n    &lt;asp:TreeNodeBinding DataMember=&quot;Cat&quot; TextField=&quot;Name&quot; ValueField=&quot;Name&quot;\n      ToolTipField=&quot;Description&quot; PopulateOnDemand=true /&gt;\n    &lt;asp:TreeNodeBinding DataMember=&quot;Color&quot; FormatString=&quot;Color: {0}&quot; PopulateOnDemand=&quot;true&quot;\n      SelectAction=&quot;None&quot; TextField=&quot;Name&quot; ValueField=&quot;Name&quot; ToolTipField=&quot;#&quot; /&gt;\n    &lt;asp:TreeNodeBinding DataMember=&quot;Gender&quot; PopulateOnDemand=&quot;true&quot; SelectAction=&quot;None&quot;\n      TextField=&quot;#&quot; ValueField=&quot;#&quot; ToolTipField=&quot;#&quot; /&gt;\n  &lt;/DataBindings&gt;\n&lt;/asp:TreeView&gt;\n</pre><br /><br />We&#39;re giving the data source a type name that will be the root of the graph. This type must have a default parameterless constructor. We don&#39;t have to specify a select method on this type because it is enumerable and if you don&#39;t specify a select method on an enumerable object, the data source will just assume the enumeration is describing the next level.<br /><br />CatsCategory, on the other hand, is not directly enumerable, so we must provide the name of a method that will get us the enumeration of objects in the next level: GetCats().<br /><br />Finally, the third way to describe the children of an object is a list of properties. That&#39;s what we&#39;re doing for Cat: its children are simply the Color and Gender properties.<br /><br />Now, all there is to do is to tell the TreeView that will consume the data source (Menu would work in just the same way) how to bind itself to the data. We&#39;re using the DataBindings property for that, and for each type (DataMember) that will be present in the object graph, we tell the tree which properties to use for the text, value, tooltip or format string. We also have a default binding for types that we don&#39;t want to special-case (such as string).<br />The &quot;#&quot; bindings express that the &quot;field&quot; we want is not a property but the return value of the ToString() method.<br />Notice how the tree will populate on demand even with this exotic data source (which could be an absolute must if your data source is infinitely deep).<br /><br />One of the most interesting parts of the implementation is the way we wrap the objects of the graph in objects that know how to expose their children in the hierarchy in a standardized way but still show all the properties of the wrapped object under Reflection (which the data source of course uses intensively, this is the price of extreme flexibility and ease of declaration). The way it does that is by implementing ICustomTypeDescriptor, which is an amazingly useful interface. Have a look at the ObjectHierarchyData source code if you want more details.</div><div class=\"ClearBoth\"></div>",
  "TagList": ".NET,data,Data Access,DataSource,Wouter,hierarchical,data source,treeview,menu,Interesting,",
  "LastEdited": "2007-07-03T17:24:29.883-07:00"
}