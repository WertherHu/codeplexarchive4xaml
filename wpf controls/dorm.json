{
  "ProjectName": "dorm",
  "Title": "Dorm (beta) - .Net ORM",
  "Description": "Itâ€™s a light-weight ORM framework for .Net.\r\nThe idea is to provide all the productivity of an ORM tool without abstracting entirely the database, therefore giving the developer a finer degree of control on data manipulation.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\">\r\n<p><br>\r\n<strong>&nbsp;</strong><span style=\"font-size:20px; font-weight:bold\"><strong>Dorm .Net (beta version)</strong></span></p>\r\n<p><br>\r\n<strong>What is Dorm?</strong><br>\r\nIt&rsquo;s a light-weight ORM framework for .Net.<br>\r\nThe idea is to provide all the productivity of an ORM tool without abstracting entirely the database, therefore giving the developer a finer degree of control on data manipulation.<br>\r\nSince it&rsquo;s not meant to be a tool pluggable in any type of situations, it has a set of conventions for its use (listed below).</p>\r\n<p>&nbsp;</p>\r\n<p><em><span style=\"text-decoration:underline\">It DOES support:</span></em></p>\r\n<p>- POCO / DDD approach;<br>\r\n- Fluent Mapping of entity meta-data;<br>\r\n- Relations One To Many and Many To Many;<br>\r\n- Component mapping (One To One);<br>\r\n- Saving and Deleting with Cascade for related objects;<br>\r\n- Object Oriented Querying with several options;<br>\r\n- Query generation at debug time;<br>\r\n- Eager Load and Paging helpers;<br>\r\n- Generation of Database scripts and Integration Tests;<br>\r\n- Implicit transactions;<br>\r\n- SQL Server 2005 or higher.</p>\r\n<p><br>\r\n<em><span style=\"text-decoration:underline\">It DOES NOT support:</span></em><br>\r\n- Linq queries (but there&rsquo;s a fine fluent interface instead);<br>\r\n- Lazy Loading (just load whatever you want!);<br>\r\n- Dirty tracking (just save whenever you want!);<br>\r\n- Custom column mapping (not intended for existing systems);<br>\r\n- Session ID Maps (it&rsquo;s just too much!);<br>\r\n- Table per Class Hierarchy (Inheritance Strategy);<br>\r\n- Concurrence control (not yet!).<br>\r\n<br>\r\n<strong>Why not NHibernate?</strong><br>\r\nAlthough NHibernate is a very complete and mature framework, its complete abstraction of the database usually implies on a very large learning curve for adapting with a few features that some may find &ldquo;awkward&rdquo;, like Proxy classes used for Lazy\r\n Loading or the lack of control of the moments that Updates are triggered to the database.<br>\r\nAnyway, is also a conceptual project, and yet another ORM alternative approach purposed!</p>\r\n<p>&nbsp;</p>\r\n<p><strong>A simple example</strong></p>\r\n<p>Imagine a domain for a simple Access Control application. You&rsquo;ll have:<br>\r\n- People (Users),<br>\r\n- Profiles (such as &ldquo;Admin&rdquo; or &ldquo;Common user&rdquo;),<br>\r\n- Permissions (like &ldquo;User can access screen XPTO&rdquo;),<br>\r\n- User Type (such as &ldquo;Internal&rdquo; or &ldquo;External&rdquo; access).</p>\r\n<p>The Database usage is made through the Database class. A few examples:</p>\r\n<p><span style=\"text-decoration:underline\">// Opens a new Connection</span><br>\r\nvar db = new Database();<br>\r\n<br>\r\n<span style=\"text-decoration:underline\">// Getting a specific user, eager loading profiles and permissions</span><br>\r\nvar user = db.First(new Query&lt;SystemUser&gt;().GetID(1).LoadAll());<br>\r\n<br>\r\nuser.Name = &quot;Test&quot;;<br>\r\nuser.Profiles.RemoveAll();<br>\r\nuser.Permissions.Add(new Permission {ScreenName = &quot;XPTO&quot;});<br>\r\n<br>\r\n<span style=\"text-decoration:underline\">// Updating an user</span><br>\r\ndb.Save(user);<br>\r\n<br>\r\n<span style=\"text-decoration:underline\">// Deleting an user</span><br>\r\ndb.Delete(user);<br>\r\n<br>\r\n<span style=\"text-decoration:underline\">// Selecting all users named &ldquo;John&rdquo;, order by id</span><br>\r\nvar query = new Query&lt;SystemUser&gt;()<br>\r\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.Filter(u =&gt; u.Nome).StartsWith(&quot;John&quot;)<br>\r\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.Order(u =&gt; u.ID);<br>\r\n<br>\r\nList&lt;SystemUser&gt; users = db.List(query);<br>\r\n<br>\r\n<span style=\"text-decoration:underline\">// Or just the first page</span><br>\r\nlong totalRecords;<br>\r\nList&lt;SystemUser&gt; usersPage = db.ListPage(query, 1, out totalRecords);<br>\r\n<br>\r\n<span style=\"text-decoration:underline\">// Or just users with at least one Permission (child queries)</span><br>\r\nvar query = new Query&lt;Person&gt;()<br>\r\n.Filter(p =&gt; p.Permissions).IsNotNull();<br>\r\n<br>\r\nvar users = db.List(query);<br>\r\n<br>\r\n<span style=\"text-decoration:underline\">// Closes the connection</span><br>\r\ndb.Dispose();<br>\r\n<br>\r\n</p>\r\n<p>&nbsp;</p>\r\n<p>Now, we'll see the entities and mapping behind the scene:</p>\r\n<p>The <strong>POCO classes</strong> would look like this:</p>\r\n<p>public class Entity<br>\r\n{<br>\r\n&nbsp;&nbsp;public long ID { get; set; }<br>\r\n}<br>\r\n<br>\r\npublic class Person : Entity<br>\r\n{<br>\r\n&nbsp;&nbsp;public string Name { get; set; }<br>\r\n&nbsp;&nbsp;public UserType Type { get; set; }<br>\r\n&nbsp;&nbsp;public List&lt;Profile&gt; Profiles { get; set; }<br>\r\n&nbsp;&nbsp;public List&lt;Permission&gt; Permissions { get; set; }<br>\r\n&nbsp;&nbsp;public Address HomeAddress { get; set; }<br>\r\n}<br>\r\n<br>\r\npublic class Address<br>\r\n{<br>\r\n&nbsp;&nbsp;public string Street { get; set; }<br>\r\n&nbsp;&nbsp;public int Number { get; set; }<br>\r\n&nbsp;&nbsp;public string City { get; set; }<br>\r\n}<br>\r\n<br>\r\npublic class UserType : Entity<br>\r\n{<br>\r\n&nbsp;&nbsp;public string Name { get; set; }<br>\r\n}<br>\r\n<br>\r\npublic class Profile : Entity<br>\r\n{<br>\r\n&nbsp;&nbsp;public string Name { get; set; }<br>\r\n&nbsp;&nbsp;public List&lt;Person&gt; Users { get; set; }<br>\r\n&nbsp;&nbsp;public List&lt;Permission&gt; Permissions { get; set; }<br>\r\n}<br>\r\n<br>\r\npublic class Permission : Entity<br>\r\n{<br>\r\n&nbsp;&nbsp;public Profile Profile { get; set; }<br>\r\n&nbsp;&nbsp;public Person SystemUser { get; set; }<br>\r\n&nbsp;&nbsp;public string ScreenName { get; set; }<br>\r\n}<br>\r\n<br>\r\n<br>\r\nThen, the<strong> Mapping classes</strong>:</p>\r\n<p><br>\r\npublic class UserMap : EntityMap&lt;Person&gt;<br>\r\n{<br>\r\n&nbsp;&nbsp;public UserMap()<br>\r\n&nbsp;&nbsp;{<br>\r\n&nbsp;&nbsp; &nbsp;Map(x =&gt; x.Name);<br>\r\n&nbsp;&nbsp; &nbsp;References(x =&gt; x.Type);<br>\r\n&nbsp;&nbsp; &nbsp;HasManyToMany(x =&gt; x.Profiles).Cascade();<br>\r\n&nbsp;&nbsp; &nbsp;HasMany(x =&gt; x.Permissions).Cascade();<br>\r\n&nbsp;&nbsp; &nbsp;HasComponent(x =&gt; x.HomeAddress);<br>\r\n&nbsp;&nbsp;}<br>\r\n}<br>\r\n<br>\r\npublic class AddressMap : ComponentMap&lt;Address&gt;<br>\r\n{<br>\r\n&nbsp;&nbsp;public AddressMap()<br>\r\n&nbsp;&nbsp;{<br>\r\n&nbsp;&nbsp; &nbsp;Map(x =&gt; x.Street);<br>\r\n&nbsp;&nbsp; &nbsp;Map(x =&gt; x.Number);<br>\r\n&nbsp;&nbsp; &nbsp;Map(x =&gt; x.City);<br>\r\n&nbsp;&nbsp;}<br>\r\n}<br>\r\n<br>\r\npublic class ProfileMap : EntityMap&lt;Profile&gt;<br>\r\n{<br>\r\n&nbsp;&nbsp;public ProfileMap()<br>\r\n&nbsp;&nbsp;{<br>\r\n&nbsp;&nbsp; &nbsp;Map(x =&gt; x.Name);<br>\r\n&nbsp;&nbsp; &nbsp;HasManyToMany(x =&gt; x.Users).Cascade();<br>\r\n&nbsp;&nbsp; &nbsp;HasMany(x =&gt; x.Permissions).Cascade();<br>\r\n&nbsp;&nbsp;}<br>\r\n}<br>\r\n<br>\r\npublic class PermissionMap : EntityMap&lt;Permission&gt;<br>\r\n{<br>\r\n&nbsp;&nbsp;public PermissionMap()<br>\r\n&nbsp;&nbsp;{<br>\r\n&nbsp;&nbsp; &nbsp;References(x =&gt; x.Profile);<br>\r\n&nbsp;&nbsp; &nbsp;References(x =&gt; x.SystemUser);<br>\r\n&nbsp;&nbsp; &nbsp;Map(x =&gt; x.ScreenName);<br>\r\n&nbsp;&nbsp;}<br>\r\n}<br>\r\n<br>\r\npublic class UserTypeMap : EntityMap&lt;UserType&gt;<br>\r\n{<br>\r\n&nbsp;&nbsp;public UserTypeMap()<br>\r\n&nbsp;&nbsp;{<br>\r\n&nbsp;&nbsp; &nbsp;Map(x =&gt; x.Name);<br>\r\n&nbsp;&nbsp;}<br>\r\n}<br>\r\n<br>\r\n<br>\r\n<strong>Main Conventions</strong><br>\r\n- All entities have an ID column, auto-numerated and PK;<br>\r\n- In One To Many relations, children should reference parents;<br>\r\n- When querying an entity, all reference and component properties are eager loaded;<br>\r\n- All collection properties must be explicitly loaded (no lazy-load, remember?);<br>\r\n- When saving or deleting an entity, cascading will occur only on the loaded collection properties (not null).<br>\r\n- Conventions for all table, fields and constraints names, based on entity meta-data &ndash; that&rsquo;s why it&rsquo;s recommended the use of database generation scripts.<br>\r\n<br>\r\n<strong>Running the Test Project</strong><br>\r\n- Download the Test Project from the source control;<br>\r\n- Create a Database on your SQL Server and update the project&rsquo;s Connection String;</p>\r\n<p>- Generate the data base scripts and run in your Database for creating the table structure;</p>\r\n<p>- Run the Insert Tests, which contains the generation of the test data.<br>\r\n- Run All Query and Save tests!</p>\r\n<p><br>\r\nFor running your own tests, follow the steps:<br>\r\n- Reference the assembly Dorm.dll on your Infra/Data layer;<br>\r\n- Besides the Connection String, add a key named &ldquo;MapsAssemblyName&rdquo; with the name of the project that contains the entities mapping classes.<br>\r\n- Create your domain and mappings</p>\r\n<p>- Generate the Database scripts and you&rsquo;re good to go!<br>\r\n<br>\r\nCurrently, it&rsquo;s a beta version and is only available for testing purposes. It should not be used on a production system.<br>\r\nSuggestions, critics and feedbacks are welcome! Enjoy!</p>\r\n</div><div class=\"ClearBoth\"></div>",
  "TagList": "",
  "LastEdited": "2011-01-24T10:26:34.39-08:00"
}