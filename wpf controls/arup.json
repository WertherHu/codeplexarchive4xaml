{
  "ProjectName": "arup",
  "Title": "Practical System Design using MEF MVVM RX MOQ Unit Tests in WPF",
  "Description": "The project is a simple Temperature Converter WPF Application which will allow user to convert from Celsius to Fahrenheit and vice versa.  The objective however",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\">\r\n<p>&nbsp;</p>\r\n<p>Practical System Design using MEF MVVM RX MOQ Unit Tests in WPF | Odyssey to knowledge</p>\r\n<div id=\"wrapper\">\r\n<div id=\"header\">\r\n<div id=\"masthead\">\r\n<div id=\"branding\"><img src=\"http://www.alanaamy.net/wp-content/themes/twentyten/images/headers/path.jpg\" alt=\"\" width=\"940\" height=\"198\"></div>\r\n</div>\r\n</div>\r\n<div id=\"main\">\r\n<div id=\"container\">\r\n<div id=\"content\">\r\n<div id=\"post-441\"><br>\r\n<br>\r\n<br>\r\n<br>\r\n<br>\r\n<br>\r\n<br>\r\n<br>\r\n<br>\r\n<br>\r\n<h1>Practical System Design using MEF MVVM RX MOQ Unit Tests in WPF</h1>\r\n<div>Posted on <a title=\"9:57 am\" href=\"http://www.alanaamy.net/rx/practical-system-design-using-mef-mvvm-rx-moq-unit-tests-in-wpf/\" rel=\"bookmark\">\r\nMay 21, 2015</a> by <a title=\"View all posts by Arup Banerjee\" href=\"http://www.alanaamy.net/author/arupalan/\">\r\nArup Banerjee</a></div>\r\n<div>\r\n<h2 style=\"text-align:left\"><span style=\"color:#ff9900\">Prelude</span></h2>\r\n<p style=\"text-align:left\">The project is a simple Temperature Converter WPF Application which will allow<br>\r\nuser to convert from Celsius to Fahrenheit and vice versa. The objective however is<br>\r\nto demonstrate techniques that are important when building large-scale front-end<br>\r\nenterprise software. I will walk you through initial project inception, system analysis,<br>\r\nrequirements gathering and a top level conceptual logical diagram. Thereafter I&rsquo;ll<br>\r\ndiscuss how the conceptual logical design will guide us with the choice of<br>\r\nFramework. Subsequently I&rsquo;ll dig deep into the world of coding while all the while<br>\r\nkeeping MVVM and SOLID patterns as the guiding torch.<br>\r\nAlong the way we&rsquo;ll learn how in production code we use WPF, MEF Discovery<br>\r\nComposition and IOC, Rx Concurrency and Data Modelling around it and its useful<br>\r\nside effects, Custom Dependency Properties, Control Templates and Style Template<br>\r\nand Style Triggers. All the above techniques are to facilitate MVVM (with a word of<br>\r\ncaution, as to not to make the converters too intelligent as we cannot unit test<br>\r\nthose). We&rsquo;ll also write a simple Log4Net Appender to provide us with useful inmemory<br>\r\nlog messages. Finally we see practical Rx-Testing Virtual Time Scheduling MOQ Unit Testing in play.</p>\r\n<h2 style=\"text-align:left\"><span style=\"color:#ff9900\">System Analysis</span></h2>\r\n<p style=\"text-align:left\">I looked at various temperature converters and finally settled with the google<br>\r\ntemperature converter for its simplicity, sleek design and more usability with<br>\r\nminimum clicks. The Google Temperature Converter looks like below.</p>\r\n<p><span style=\"color:#ff9900\"><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/GoogleTempCon1.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/GoogleTempCon1.png\" alt=\"GoogleTempCon\" width=\"605\" height=\"187\"></a></span></p>\r\n<h2>&nbsp;</h2>\r\n<h2 style=\"text-align:left\"><span style=\"color:#ff9900\">Our Final System</span></h2>\r\n<p><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/ArupTempConv.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/ArupTempConv.png\" alt=\"ArupTempConv\" width=\"621\" height=\"534\"></a></p>\r\n<p>&nbsp;</p>\r\n<h2 style=\"text-align:left\"><span style=\"color:#ff9900\">Functional Requirements.</span></h2>\r\n<p style=\"text-align:left\">By playing around I noted the functional requirement as below.</p>\r\n<p style=\"padding-left:30px\"><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/FunctionaRequirements.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/FunctionaRequirements.png\" alt=\"FunctionaRequirements\" width=\"864\" height=\"347\"></a></p>\r\n<p>&nbsp;</p>\r\n<h2 style=\"text-align:left\"><span style=\"color:#ff9900\">Non Functional Requirements</span></h2>\r\n<p style=\"padding-left:30px\"><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/NonFunctionaRequirements.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/NonFunctionaRequirements.png\" alt=\"NonFunctionaRequirements\" width=\"866\" height=\"188\"></a></p>\r\n<h2 style=\"text-align:left\"><span style=\"color:#ff9900\">Conceptual Design</span></h2>\r\n<p style=\"text-align:left\">I personally prefer top level conceptual design. It allows to more naturally understand the appropriate design patterns and accordingly help us model the system. Once we understand the relevant pattern and the associated design pattern\r\n we can design relevant data model, service models and relevant frameworks to be used.</p>\r\n<p style=\"text-align:left\"><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/Conceptualdesign.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/Conceptualdesign.png\" alt=\"Conceptualdesign\" width=\"624\" height=\"392\"></a></p>\r\n<p style=\"text-align:left\">We see that the right text box observes on the sequence of input on the left text box and reacts to the changes. Similarly we see that when the user inputs on the right text box, the left text box observes on the sequence of input\r\n and reacts to it.<br>\r\nWhat we see here is an Observer Pattern in play. There are two observers, the left sequence Observer and the right sequence Observer. Well from technical point of view one may argue why two observers and why not simply let the ViewModel have one observer which\r\n handles the conversion logic. Why have observer at all and instead simply implement the logic using databinding and WPF behaviours. Well the argument goes one. There are no just right answer to anything. The way I look at things is to unbias my mind from technology\r\n and look at the system at its pure natural form.<br>\r\nThe Text Boxes are like two observers which observes the data thrown by the user. The job of the Data Model is only to hold the data and provide the observable orchestration. The actual processing of the data is done by the controller who decide who gets a\r\n point and who loses. The ViewModel walks up and informs the View about the decision taken by the controller and asks the view to display the decision. The reason for two observers is because it more naturally depicts the system we are handling and SOLID pattern\r\n insist separation of concern as its guiding 1st principal. Following these principles helps to alleviate future problems and issues with design while the product matures.<br>\r\nBoth of these observers react to the changes to the subject data sequence. We will further like to handle the reaction action concurrently without blocking the UI Main Thread. Moreover if you decide to handle concurrency in UI, we have a restriction such that\r\n anytime you update a Visual, the work is to be sent through the Dispatcher to the UI thread. The control itself can only be touched by it&rsquo;s owning thread. If you try to do anything with a control from another thread, you&rsquo;ll get a runtime unsupported\r\n operation exception. Overall concurrency may be an overkill for this simple Temperature converter, but the objective here is to show techniques for building large-scale front-end enterprise system. Therefore given we have decided our requirement for concurrency,\r\n there are many patterns at our disposal to run a piece of work in the background:<br>\r\n<a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/ConcurrentPattern.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/ConcurrentPattern.png\" alt=\"ConcurrentPattern\" width=\"617\" height=\"148\"></a>Rx, has abstracted all the above mechanisms\r\n for concurrency using a single interface called <span style=\"color:#0b929e\">IScheduler</span>. Given RX facilitates Observable sequence and also abstracts concurrency, it is therefore an ideal framework of choice. The observers naturally involve a sequence\r\n of data which are input by the user.</p>\r\n<h2 style=\"text-align:left\"><span style=\"color:#ff9900\">Data Model Design</span></h2>\r\n<p>As discussed above, the Data Model primarily observes a sequence of numbers thereby inheriting from IObservable&lt;T&gt; where T is the sequence type. The Model does not persist the sequence of result except for the result of the latest calculated sequence\r\n value. This result is therefore represented by the property Value. The Data Model is also a Subject for observation and hence it aggregates a _innerObservable Subject&lt;T&gt; of type T, in our case decimal. The logical unit of the result &ldquo;Value&rdquo;\r\n is represented by logical unit U.</p>\r\n<p><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/DataModelDesignCode.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/DataModelDesignCode.png\" alt=\"DataModelDesignCode\" width=\"697\" height=\"555\"></a></p>\r\n<p>Note that this Data Model is a generic base implementation hence the IObservable&lt;T&gt; interface is also exposed as method GetObservable(), which will then allow the Observable to be exposed through upper stack interfaces ILeftSequenceObserverModel and\r\n IRightSequenceObserverModel. The upper stack interfaces are composed by MEF , IOC injected and orchestrated in the MVVM play. As will be shown in the unit tests, the GetObservable() interface will allow us to inject TestScheduler which facilitates virtual\r\n time scheduling and is absolute necessity for any RX related testing . In the MVVM paradigm, while ViewModel may not be directly using the controls but ViewModel runs and updates the UI using WPF databinding on the UI Dispatcher Thread Context. However when\r\n we will unit test the ViewModel there will be no dispatcher thread context. Therefore we will use bridge pattern to decouple abstraction from implementation. Rx has already abstracted the concurrency via the IScheduler interface as discussed above and we will\r\n leverage that as below.</p>\r\n<p><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/Rewire.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/Rewire.png\" alt=\"Rewire\" width=\"738\" height=\"60\"></a></p>\r\n<p><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/SchedulerUsage1.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/SchedulerUsage1.png\" alt=\"SchedulerUsage1\" width=\"752\" height=\"690\"></a>Now above is a test Setup, but there is\r\n a subtle &ldquo;bug&rdquo;. Hint the above Test will work in debug Test but will fail in Test using release code. I leave this for you to think or else see my actual code.</p>\r\n<p><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/SchedulerUsage2.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/SchedulerUsage2.png\" alt=\"SchedulerUsage2\" width=\"728\" height=\"324\"></a></p>\r\n<p>Note below that the data Model also exposes events to loosely notify changes to value and unit. One thing of interest is that I&rsquo;m not checking if reference equals null for the event delegate. The reference check is not necessary because I&rsquo;m initializing\r\n the event delgates to no-op delegate {}. There is yet one more thing of interest which is I&rsquo;ve not applied double check lock pattern on the Value Setter. That is a potential bug because although OnNext gurantees that it will not overlap; but that gurantee\r\n makes sense within the perspective of RX implementation. When we are implementing our own logic we should ensure that the RX Grammer is intact else we can have surprises in the production code. We can easily achieve that by implementing double check lock pattern\r\n over the Setters. Alternately a lock free implementation will be you assign the event delegate to a local delegate and then invoke on the local event delegate. As because delegates are immutable and thread has its own private stack , we are naturally guarded\r\n without implementing any lock. I have said many words but the implementation is quite simple like below.</p>\r\n<p><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/ThreadSafeEvent1.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/ThreadSafeEvent1.png\" alt=\"ThreadSafeEvent1\" width=\"357\" height=\"333\"></a></p>\r\n<p>Now you can argue that _value is not guarded. But that is not a worry in this critical section of the code because we are instead using stack\r\n<span style=\"color:#3366ff\">value</span> which is thread safe anyway.</p>\r\n<p>I&rsquo;m logging the sequence as a side effect using Do extension which does not change the sequence, and also called prior to OnNext.</p>\r\n<p><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/SchedulerUsage3.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/SchedulerUsage3.png\" alt=\"SchedulerUsage3\" width=\"543\" height=\"265\"></a></p>\r\n<h2><span style=\"color:#ff9900\">Observable Sequence Controller</span></h2>\r\n<p>As per the use case when the user inputs the left textbox; the left textbox becomes subject and the input sequence is observed by the right textbox and vice versa.<br>\r\nThe Observable Sequence Controller does the job of wiring and unwiring the appropriate Observable Sequence data Model. Note specifically in the Toggle Event, the controllers unwires both the observers, because any changes subsequent are due to change in the\r\n unit of conversion only rather than any new data sequence. MEF composes and injects the Models into the Sequence controller.</p>\r\n<p><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/SequenceScheduler.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/SequenceScheduler.png\" alt=\"SequenceScheduler\" width=\"734\" height=\"389\"></a></p>\r\n<h2><span style=\"color:#ff9900\">ViewModel Design</span></h2>\r\n<p>The MainPageViewModel is the ViewModel for the view MainWindow.xaml. This ViewModel is located by the ViewModel Locator and injected as the DataContext of the view. The Models and controller are IOC injected into the ViewModel constructor. The KeyBoardFocussed\r\n property is implemented as behaviour attached property so we can associate with a bindable command and command parameter. Note if otherwise we had used IsKeyBoardFocussed as Trigger, we would not be able to use our viewModel in setters because only dependency\r\n properties could be use in setters.</p>\r\n<p><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/ViewModelDesign.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/ViewModelDesign.png\" alt=\"ViewModelDesign\" width=\"743\" height=\"400\"></a></p>\r\n<p><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/ViewModelInject.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/ViewModelInject.png\" alt=\"ViewModelInject\" width=\"719\" height=\"358\"></a></p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<h2><span style=\"color:#ff9900\">Unit Tests</span></h2>\r\n<p>Some crucial Unit Tests techniques and design have been discussed above. These below test covers the functional specification Testing. You can check the details of implementation in the code included.</p>\r\n<p><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/UnitTest.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/UnitTest.png\" alt=\"UnitTest\" width=\"619\" height=\"596\"></a></p>\r\n<p>&nbsp;</p>\r\n<h2><span style=\"color:#ff9900\">Code Coverage</span></h2>\r\n<p>Code Coverage is an important tool, which gives an idea how our code is being used. But we should not get biased with the overall percentage. For example I do not use attached code and hence InitializeComponent can be safely removed. Similarly I use only\r\n the generic version of the RelayCommand&lt;T&gt; as I&rsquo;m using commandParameter. However keeping the non Generic within the libray does not harm even though it is not use in this ViewModel. ViewModelLocator shows coverage 0%, but that is not exactly true,\r\n because the ViewModelLocator is only used once to inject the MainView . The coverage and snapshot starts well after the View appears, by which time the ViewModelLocator has already done its job. Hence Code coverage is very useful, but we should use the figures\r\n judiciously.</p>\r\n<p><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/Coverage.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/Coverage.png\" alt=\"Coverage\" width=\"615\" height=\"664\"></a></p>\r\n<p>&nbsp;</p>\r\n<h2><span style=\"color:#ff9900\">Nuget Packages</span></h2>\r\n<p>Nuget is a versatile package management tool and has been used in this project.</p>\r\n<p><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/Nuget.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/05/Nuget.png\" alt=\"Nuget\" width=\"626\" height=\"447\"></a></p>\r\n<h2><span style=\"color:#ff9900\">Download Code</span></h2>\r\n<p>You can download the code <a href=\"http://www.alanaamy.net/wp-content/uploads/2015/05/AlanAamy.Net_.TemperatureConverter.zip\">\r\nAlanAamy.Net.TemperatureConverter</a>. Note that the package binaries are not included. You will need to be online while building the solution which will automatically restore the required packages.</p>\r\n<p>&nbsp;</p>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div><div class=\"ClearBoth\"></div>",
  "TagList": "MEF MVVM RX MOQ Unit,",
  "LastEdited": "2015-05-27T20:11:49.357-07:00"
}