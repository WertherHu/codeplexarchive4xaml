{
  "ProjectName": "trollr",
  "Title": "trollr.net - remotely configure & control your .Net applications",
  "Description": "trollr.net provides a remote configuration and control network to the .Net apps in your enterprise. App configuration becomes centralised and live/runtime changes are pushed to each application - no restart required to pick up the change. Cache control commands can also be sent!",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><b>Project Description</b><br />trollr.net provides a remote configuration and control network to the .Net apps in your enterprise. App configuration becomes centralised and live&#47;runtime changes are pushed to each application - no restart required to pick up the change. Cache control commands can also be sent&#33;<br /><br /><div style=\"clear:both;height:0;\">&nbsp;</div><img style=\"float:left;padding-right:.5em;\" src=\"/projects/trollr/cb4b4c80-0a62-4fd0-a4c1-c425011ffe38\" alt=\"trollr-problem.png\" title=\"trollr-problem.png\" />\n<h2>What problem does it solve?</h2>\rIn short - application configuration and cache invalidation. Any .Net application (Asp.net, Console, Windows Service, Winform, WPF, etc) using Castle/Windsor (other IoC containers to be supported later) can use trollr.net to manage its configuration and local cache store. <br /><br />In an enterprise platform there are often many apps sharing the same configuration values, usually stored in an isolated xml configuration file that is updated with the correct environment values at build/deploy time. Each app would have a copy of these configuration property files and an update means updating all instances. Ultimately you have multiple isolated xml files containing duplicates of the same configuration value - and you have to manage <i>all</i> of these instances.<br /><br />Similarly with local caches - each application may utilise a local cache that has a (stale) copy of a piece of data - how do you manage invalidation when the actual master piece of data is changed by an update?<br /><br /><br /><br /><br /><br /><div style=\"clear:both;height:0;\">&nbsp;</div><img style=\"float:left;padding-right:.5em;\" src=\"/projects/trollr/51df48bb-ed60-401e-a4e0-8d0ac26820ec\" alt=\"trollr-solution.png\" title=\"trollr-solution.png\" />\n<h2>What does it do?</h2>\rTrollr.Net provides a radical new way to manage your application configuration! With Trollr.Net <b>no</b> configuration values are deployed with an application, instead they are stored in a central configuration store; this also means they can be shared across applications. Each application loads its required configuration at startup and then trollr will manage any changes over the lifecycle of the application - updates to the central configuration store are sent to each application as they happen without needing to restart the application.\n<ul><li><b>Out</b> goes the numerous xml files.</li>\n<li><b>In</b> comes a single centralised configuration store with notification changes pushed to each application in realtime.</li>\n<li>Provides a bi-directional command channel between each application and a central configuration and control service.</li>\n<li>Applications can subscribe for configuration and cache updates and will receive notification when any happen.</li>\n<li>No restart/recycle of the application is required to pick up the configuration change - the new value is immediately available to the running code.</li>\n<li>Central config &amp; control service continuously checks for updates and pushes them to each subscribed application as they are committed to a central configuration store (currently SqlServer is supported).</li>\n<li>Overrides for specific configuration properties can be applied at either an application or machine or more finer, targeting a single machine/app combo.</li>\n<li><b>Future Feature</b> Configuration changes can also be scheduled - a start/end date can be attached to a configuration value and this is automatically pushed to the subscribed applications at the correct time. Eg: You could schedule an elevation in logging level for a specific part of the day. </li></ul>\n\n<h2>How does it work?</h2>\rIt&#39;s based around a central windows service that manages configuration and cache changes. A WCF pub/sub mechanism allows your app to &quot;pull&quot; it&#39;s configuration from a central configuration store at startup - a reciprocal channel is then be used to push runtime configuration changes to all subscribed applications along with commands to invalidate any in-process caches when data state has changed.<br /><br /><b>PLEASE READ</b> The initial release of trollr.net utilises the capability of the Castle/Windsor IoC container in order to work. So for you to use trollr.net <b>your application must use Castle/Windsor for DI/IoC</b> - if it doesn&#39;t then <b>trollr.net cannot be used</b>. Now the good news! The important aspect that trollr.net leverages from Castle/Windsor is interception - any IoC container that has equivalent functionality can be used. Trollr.net is designed to allow other IoC containers to be plugged in - it initially ships with a Castle/Windsor adapter but I&#39;m sure in time other container wrappers will be implemented or if you are up for a challenge write an adapter for your container (and even contribute it back to the project for big kudos). It&#39;s written against the .Net 4.0 framework in case you were wondering...<br /><br /><img src=\"/projects/trollr/58ef7f1a-3051-4231-b39c-7834ac66a6cd\" alt=\"trollr-overview.png\" title=\"trollr-overview.png\" /><br /><br />When your application starts trollr.net installs a WCF net.tcp servicehost that can be called by the central service; it will also contact the central service with details of your application including the callback address of the servicehost and a list of configuration values required. This list of configuration values is gathered by the trollr infrastructure using reflection - all you need do is mark any object requiring trollr configuration with a special trollr interface and each public property on the object needs a trollr attribute (this allows you to override the property name with a more descriptive configuration label for it). The central service gathers the current configuration values for the properties requested and replies to the application which in turn stores these in the system.web.cache (HttpCache) for super fast local access by trollr.<br /><br />The central service is also responsible for managing the distribution of configuration changes. When a trollr.net enabled client starts up and requests its configuration values the central service automatically subscribes the client - a record is created in a &quot;subscriptions&quot; table and this holds the machine, app id and callback address (uri) of the WCF service running on the client. The central service is continually monitoring the configuration store for changes and when it detects a change it will attempt to cross-reference subscribers to ensure that only the applicable ones are notified of the change.<br /><br />There is only one special requirement (that hopefully shouldn&#39;t be a barrier for you adopting trollr to manage your configuration) - the object that contains the properties to manage must be a dependency of another object in your IoC container. The reason for this is that trollr works by creating a proxy to the object and intercepting the property calls - in order for this to work there must be an object to proxy in the first place. This is actually how I would setup my objects/components for IoC anyway but it might be different to how you do things. Here is an example (taken from the demo project code) to demonstrate this approach and hopefully you will agree that a) it&#39;s a good approach in general and b) that trollr.net creates almost no &quot;disruption&quot; in using it.<br /><br />1. Here is our business component interface and implementation. Notice the <b>BusinessOperationConfig</b> property - this is a dependency that will automatically be handled by the IoC container. This property is to our component that holds all the configuration properties this component needs; note this could also be created as a constructor parameter.<br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">interface</span> IBusinessOperation\n{\n    <span style=\"color:Blue;\">string</span> DoSomethingImportant();\n}\n\n<span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">class</span> BusinessOperation : IBusinessOperation\n{\n    <span style=\"color:Green;\">// This will be injected automatically by the IoC container</span>\n    <span style=\"color:Green;\">// and contains all the properties we want trollr.net to </span>\n    <span style=\"color:Green;\">// control the configuration of</span>\n    <span style=\"color:Blue;\">public</span> BusinessOperationConfig Config { <span style=\"color:Blue;\">get</span>; <span style=\"color:Blue;\">set</span>; }\n\n    <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">string</span> DoSomethingImportant()\n    {\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">string</span>.Format(<span style=\"color:#A31515;\">&quot;Url:={0}; Action:={1}&quot;</span>, Config.Url, Config.Action);\n    }\n}\r\n</pre></div><br />2. Here is our configuration component. Notice it implements the <b>ITrollrConfigurable</b> interface <br />and that each auto property has a <b>TrollrConfigured</b> attribute and is <b>virtual</b> (this is a requirement for proxy/interception).<br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">class</span> BusinessOperationConfig : ITrollrConfigurable\n{\n    [TrollrConfigured(Name = <span style=\"color:#A31515;\">&quot;ModifiedUrl&quot;</span>)]\n    <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">virtual</span> <span style=\"color:Blue;\">string</span> Url { <span style=\"color:Blue;\">get</span>; <span style=\"color:Blue;\">set</span>; }\n\n    [TrollrConfigured]\n    <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">virtual</span> <span style=\"color:Blue;\">string</span> Action { <span style=\"color:Blue;\">get</span>; <span style=\"color:Blue;\">set</span>; }        \n}\r\n</pre></div><br />3. Bootstrap your application&#39;s Windsor container and load the business component into it against the <b>IBusinessOperation</b> interface. So far, so normal, however here is where trollr.net kicks in. In a normal application you would also have to register the dependent <b>BusinessOperationConfig</b> configuration component in order for the container to inject it into our BusinessOperation implementation. With trollr.net you don&#39;t have to register the <b>BusinessOperationConfig</b> component - it will take care of this for us so cutting down on container configuration. <br /><div style=\"color:Black;background-color:White;\"><pre>\r\nmyInstance =  <span style=\"color:Blue;\">new</span> WindsorContainer()\n    .Register(AllTypes.FromThisAssembly()\n    <span style=\"color:Green;\">// register only the business component - no need to register</span>\n    <span style=\"color:Green;\">// the configuration component as Trollr will do this for us</span>\n    .BasedOn(<span style=\"color:Blue;\">typeof</span>(IBusinessOperation)).WithService.Base()\n    .Configure(c =&gt; c.LifeStyle.Transient));\r\n</pre></div><br />4. Start trollr.net. It will register the <b>BusinessOperationConfig</b> and all other <b>ITrollrConfigurable</b> components for you; it scans all assemblies loaded into the AppDomain to discover all <b>ITrollrConfigurable</b> components and does two things...\n<ol><li>Creates a proxy for each <b>ITrollrConfigurable</b> component and registers it into your IoC container. When your application asks to resolve the <b>IBusinessOperation</b> component the container will inject the trollr.net proxy into the <b>BusinessOperation</b> instead of the actual <b>BusinessOperationConfig</b> component. This proxy provides the interception hook for trollr.net to take control over the property value. </li>\n<li>The public properties of each <b>ITrollrConfigurable</b> component are scanned and any that are decorated with the <b>TrollrConfigured</b> attribute are added to a list. Once scanning is complete this list is sent to the central server which will reply with the current configuration values.</li></ol>\nThe parameters required are...\n<ol><li>The application name - a descriptive name to identify this application within the configuration store.</li>\n<li>The tcp port to host the trollr.net service within your application.</li>\n<li>Container.Current is a helper property to your Windsor Container instance (IWindsorContainer).</li></ol>\n<div style=\"color:Black;background-color:White;\"><pre>\r\nCore.Trollr.Run(<span style=\"color:#A31515;\">&quot;Test-Console&quot;</span>, 17002, Container.Current);\r\n</pre></div><br />5. That&#39;s it as far as your application and the impact trollr.net has on your codebase. All that remains is for the the central configuration service  to be installed and loaded with your configuration values. Read on to understand this service better.<br />\n<h2>Central Configuration Service</h2>\rThis is implemented as a windows service and utilises another of my open-source projects <a href=\"http://monitorwang.codeplex.com\">MonitorWang</a> to provide the service infrastructure; trollr.net server functionality is simply a MonitorWang plug-in. In order to get the trollr.net central service up and running you will need to download and install MonitorWang first, then drop in the trollr.net plug-in. The complete soup-to-nuts instructions to get trollr.net up and running are <a href=\"https://trollr.codeplex.com/wikipage?title=Getting%20Started&referringTitle=Home\">here</a>.</div><div class=\"ClearBoth\"></div>",
  "TagList": "",
  "LastEdited": "2011-02-10T04:13:20.453-08:00"
}