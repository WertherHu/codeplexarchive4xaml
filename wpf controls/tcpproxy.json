{
  "ProjectName": "tcpproxy",
  "Title": "C++ TCP Proxy Server",
  "Description": "The C++ TCP Proxy server is a simple utility using the ASIO networking library, for proxying (tunneling or redirecting) connections from external clients to a specific server. The TCP Proxy server can be used to easily and efficiently.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><b>Project Description</b><br />The C++ TCP Proxy server is a simple utility using the ASIO networking library, for proxying (tunneling or redirecting) connections from external clients to a specific server. The TCP Proxy server can be used to easily and efficiently:<br />\n<ul><li>Limit the number of client connections to the server</li>\n<li>Load balance client connections between multiple server instances</li>\n<li>Provide IP or connection time based filtering and access control mechanisms</li>\n<li>Inspect (log), filter or otherwise modify data flowing between the clients and the server</li></ul>\n<br /><img src=\"http://www.partow.net/images/tcpproxy_server_diagram.png\" alt=\"TCP Proxy Server Diagram - Copyright Arash Partow\" title=\"TCP Proxy Server Diagram - Copyright Arash Partow\" /><br /><br /><b>Project Site</b><br /><a href=\"http://www.partow.net/programming/tcpproxy/index.html\">http://www.partow.net/programming/tcpproxy/index.html</a><br /><br />\n<hr />\n<b>Internals Of The Proxy</b><br />The proxy from an implementation aspect is primarily composed of three components named the <b>Acceptor</b>, <b>Session</b> and the ASIO I/O Service proactor. The Acceptor and Session components register with the I/O service requests and associated completion handlers <i>(callbacks)</i> for reading and writing from socket(s). The state diagram below depicts the the various completion handlers and their relationship to the I/O service component. The turquoise blocks are associated with the <b>Acceptor</b>, where as the purple blocks are associated with the <b>Session</b>. For exposition purposes let&#39;s assume that the completion handlers and the I/O service component are each a unique state in a state machine that represents the TCP proxy.<br /><br /><img src=\"http://www.partow.net/images/tcpproxy_state_diagram.png\" alt=\"TCP Proxy State Diagram - Copyright Arash Partow\" title=\"TCP Proxy State Diagram - Copyright Arash Partow\" /><br /><br />The TCP proxy server is broken down into three functional <i>&#39;groupings&#39;</i> denoted in the diagram by the colours blue, green and red attached to the transitions between the states <i>(completion handlers)</i> and the I/O service. The groupings are summarised as follows:<br /><br /><table><tr><th> Phase </th><th> Transitions </th><th> Definition                                             </th></tr>\n<tr><td> Blue   </td><td> 1 - 8        </td><td> Start-up and client connection instantiation phase.      </td></tr>\n<tr><td> Green  </td><td> A1 - A4      </td><td> Process data flow from remote server to proxy to client. </td></tr>\n<tr><td> Red    </td><td> B1 - B4      </td><td> Process data flow from client to proxy to remote server. </td></tr></table><br /><br /><b>The Blue Phase - Startup and Initialisation</b><br />Associated completion handlers:\n<ul><li><span class=\"codeInline\">handle_accept</span></li>\n<li><span class=\"codeInline\">handle_upstream_connect</span></li></ul>\nIn this phase the proxy itself is setup, which includes instantiating the Acceptor, binding-to and listening in on the given IP and port number, and invoking the <b>accept_connections</b> method, which in turn will register a completion handler with the I/O service, that will later on be invoked when new connections are made to the proxy server.<br /><br />When a client makes a connection to the proxy server, the <b>handle_accept</b> completion handler will be invoked by the I/O service. This handler will then proceed to instantiate and start a client session (bridge) instance. Once that is complete, it will then invoke <b>accept_connections</b> which will complete the cycle by re-registering the <b>handle_accept</b> method with the I/O service as the completion handler for any new connections.<br /><br />Meanwhile when the start method on the client session was invoked during the <b>handle_accept</b> call, it immediately attempted to asynchronously establish a connection with the remote server. When the remote server accepts the connection, the I/O service will then invoke the <b>handle_upstream_connect</b> completion handler. This handler will in turn proceed to register two asynchronous read requests coupled with the completion handlers <b>handle_downstream_read</b> and <b>handle_upstream_read</b> with the I/O service, one for data coming from the client, the other being for data coming from the remote server respectively. <br /><br /><img src=\"http://www.partow.net/images/tcpproxy_state_bluephase_diagram.png\" alt=\"TCP Proxy Blue Phase Diagram - Copyright Arash Partow\" title=\"TCP Proxy Blue Phase Diagram - Copyright Arash Partow\" /><br /><br />Based on which end-point data arrives at the proxy, one of the following phases will be engaged:\n<ol><li>Green Phase</li>\n<li>Red Phase</li></ol>\n<br /><b>The Green Phase - Remote Server To Proxy To Client Data Flow</b><br />Associated completion handlers:\n<ul><li><span class=\"codeInline\">handle_upstream_read</span></li>\n<li><span class=\"codeInline\">handle_downstream_write</span></li></ul>\nThis phase is engaged when data from the Remote Server (aka up-stream end point) arrives at the proxy. Once some amount of data is ready, the I/O service will invoke the <b>handle_upstream_read</b> completion handler. This handler will in turn take the data and register an asynchronous write request with the I/O service in order to send the data to the Client end point. Once the write request has completed, the I/O service will invoke the <b>handle_downstream_write</b> completion handler. This handler will complete the cycle for the green phase by re-registering with the I/O service an asynchronous read request from the upstream end-point coupled with the <b>handle_upstream_read</b> method as the associated completion handler. <br /><br /><br /><img src=\"http://www.partow.net/images/tcpproxy_state_greenphase_diagram.png\" alt=\"TCP Proxy Green Phase Diagram - Copyright Arash Partow\" title=\"TCP Proxy Green Phase Diagram - Copyright Arash Partow\" /><br /><br /><br /><b>The Red Phase - Client To Proxy To Remote Server Data Flow</b><br />Associated completion handlers:\n<ul><li><span class=\"codeInline\">handle_downstream_read</span></li>\n<li><span class=\"codeInline\">handle_upstream_write</span></li></ul>\nThis phase is engaged when data from the Client <i>(aka down-stream end point)</i> arrives at the proxy. Once some amount of data is ready, the I/O service will invoke the <b>handle_downstream_read</b> completion handler. This handler will in turn take the data and register an asynchronous write request with the I/O service in order to send the data to the Remote Server end point. Once the write request has been completed, the I/O service will invoke the <b>handle_upstream_write</b> completion handler. This handler will complete the cycle for the red phase by re-registering with the I/O service an asynchronous read request from the downstream end-point coupled with the <b>handle_downstream_read</b> method as the associated completion handler. <br /><br /><br /><img src=\"http://www.partow.net/images/tcpproxy_state_redphase_diagram.png\" alt=\"TCP Proxy Red Phase Diagram - Copyright Arash Partow\" title=\"TCP Proxy Red Phase Diagram - Copyright Arash Partow\" /><br /><br /><br /><b>Bridge Shutdown Process</b><br />When either of the end points terminate their respective connection to the proxy, the proxy will proceed to close (or shutdown) the other corresponding connection. This includes releasing any outstanding asynchronous requests, culminating in the reference count of the bridge (client session) reaching zero at which point the bridge instance itself will subsequently have its destructor called.<br /><br />\n<hr />\n<br /></div><div class=\"ClearBoth\"></div>",
  "TagList": "tcp,proxy,c++,asio,network,server,tunnel,connection,redirect,load balancing,access control,udp,ip,partow,partow.net,low latency,data,datagram,socket,reactor,select,epoll,kqueue,peer,stl,boost,transport,broadcast,multicast,distributed,ip address,algorithm,Concurrency,concurrent,Parallel,Parallel Programming,module,component,address,source,template,",
  "LastEdited": "2017-03-04T16:17:28.807-08:00"
}