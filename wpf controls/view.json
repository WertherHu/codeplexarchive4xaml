{
  "ProjectName": "view",
  "Title": "Database View-plug-ins Framework",
  "Description": "View-plug-ins Programming on database is an interface-oriented to simplify the design of complex batches processing. Useful for ETL, reporting and DWH solutions",
  "MovedLink": "https://github.com/AbelCheng/View-plug-ins",
  "HomeWiki": "<div class=\"wikidoc\">\r\n<p><strong>Project Description</strong></p>\r\n<p>The View-Plug-Ins Programming on database development is an interface-oriented programming. This methodology has been practiced widely in many fields (e.g. OOP programming) for a long time. Here just focus on database development and introduce a few meta-tables\r\n and helper packages (for Oracle, or set of stored procedures for SQL Server). The purpose is to simplify the design of many complex batches processing, useful for ETL, reporting and DWH solutions.</p>\r\n<p>The central motive behind View-Plug-Ins is also a Branches-Leaves model of database development. Branches are stored procedures of flowchart while leaves are views of particular implementation. It helps to remind people\r\n<strong>pruning</strong> fruit trees during the growing season (in early stages of software lifecycle, from the system requirement analysis to design stage). Then in later maintenance stage, it would be more clear to organize/see the whole picture from the\r\n root to branches if the program structure of SQL scripts like a deciduous tree in winter.</p>\r\n<p><strong>Interface Design</strong></p>\r\n<p>The process of interface designing prefers more converse thinking. Especially in realization phase, the whole programming steps is from Target (output) Model to Source (input) Models, as shown following:<br>\r\n<img src=\"/Download?ProjectName=view&DownloadId=463344\" alt=\"Figure1\" width=\"545\" height=\"118\" style=\"vertical-align:middle\"></p>\r\n<p>Once we get a clear and clean data requirement, then to abstract, induce and simplify into a unified target model is a prerequisite of interface-oriented designing.</p>\r\n<ul>\r\n<li>The Target Model (above figure) defines the data model; </li><li>A Interface defines a cluster node to approach one kind of required data; </li><li>A view-plug-in defines a method model of data extraction. </li></ul>\r\n<p><img src=\"/Download?ProjectName=view&DownloadId=463345\" alt=\"Figure2\" width=\"689\" height=\"376\" style=\"vertical-align:middle\"></p>\r\n<p>Two basic aims of bringing in the Interface and the Plug-ins:</p>\r\n<p><span style=\"text-decoration:underline\">Isolation</span></p>\r\n<p>To isolate the differences of data model, transform different model from many sources to a common target model, follow by classification, labeling/tagging etc. It helps the code to be loose-coupled while the data keep tightly-coupled. To test each independent\r\n view can be much clearer than to test a tangled of steps in sp, make the test-driven database development simple.</p>\r\n<p><span style=\"text-decoration:underline\">Unification</span></p>\r\n<p>A complex system can always be divided into a few clear-cut sub-systems with logical loose coupling integration. For database system design, the principle of division depends on the induction of data model. Then each target sub-system can be treated as one\r\n data model, the differences have been transformed into just some attributes in the same model.</p>\r\n<p><strong>Meta Tables</strong></p>\r\n<p>There are only 4 tables about meta data need to be maintained for above designed model:</p>\r\n<ol>\r\n<li>EXTRACT_SERVICE </li><li><strong>EXTRACT_INTERFACE</strong> </li><li>EXTRACT_PLUGIN </li><li>EXTRACT_RULE </li></ol>\r\n<div><img src=\"/Download?ProjectName=view&DownloadId=471665\" alt=\"db_diagram\" width=\"646\" height=\"450\"></div>\r\n<p>1. EXTRACT_SERVICE</p>\r\n<div>An Extraction Service encapsulates a set of related Interfaces in the form of a service layer:</div>\r\n<ul>\r\n<li>In design-time, the Service is used to organize interfaces into application domains (projects). A Service is a management unit to build code generation and for Pre-deployment (see the later section [Pre-deployment] for detail).\r\n</li><li>In run-time, all Interfaces under a Service share the same session context for each Batch.\r\n</li></ul>\r\n<p>2. EXTRACT_INTERFACE</p>\r\n<div>Sample:</div>\r\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border:1px solid #C0C0C0\">\r\n<tbody>\r\n<tr align=\"center\" bgcolor=\"gainsboro\" style=\"font-weight:bold\">\r\n<td>INTERFACE_ID</td>\r\n<td>SERVICE_ID</td>\r\n<td>UNION_VIEW</td>\r\n<td>SELECT_LIST</td>\r\n<td>DESCRIPTION_</td>\r\n</tr>\r\n<tr>\r\n<td>PRD_CLS</td>\r\n<td>APP_DOMAIN</td>\r\n<td>XYZ.VIEW_ALL_PROD</td>\r\n<td>BATCH_ID, SEC_ID, PROD_NAME</td>\r\n<td>Prod Identification</td>\r\n</tr>\r\n<tr>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<div><span style=\"text-decoration:underline\">Columns</span><br>\r\n- INTERFACE_ID: The unique identifier for the interface, consider a naming convention within the enterprise.<br>\r\n- SERVICE_ID: The extract service (application) of this interface.<br>\r\n- UNION_VIEW: (Also called Hub-View). The name of view which will union all plug-ins under the same interface.<br>\r\n- SELECT_LIST: The select list in the select statement, every plug-in view of the same interface will follow this signature.<br>\r\n- DESCRIPTION_:<br>\r\n&nbsp;</div>\r\n<p>3. EXTRACT_PLUGIN</p>\r\n<div>Sample:</div>\r\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border:1px solid #C0C0C0\">\r\n<tbody>\r\n<tr align=\"center\" bgcolor=\"gainsboro\" style=\"font-weight:bold\">\r\n<td>PLUGIN_ID</td>\r\n<td>INTERFACE_ID</td>\r\n<td>PLUGIN_VIEW</td>\r\n<td>PLUGIN_ORDER</td>\r\n<td>DESCRIPTION_</td>\r\n</tr>\r\n<tr>\r\n<td>PRD_CLS_SRM</td>\r\n<td>PRD_CLS</td>\r\n<td>XYZ.VIEW_PROD_CLS_SRM</td>\r\n<td>1</td>\r\n<td>Identify prods from Srm</td>\r\n</tr>\r\n<tr>\r\n<td>PRD_CLS_SCM</td>\r\n<td>PRD_CLS</td>\r\n<td>XYZ.VIEW_PROD_CLS_SCM</td>\r\n<td>2</td>\r\n<td>Identify prods from Scm</td>\r\n</tr>\r\n<tr>\r\n<td>PRD_CLS_DEA</td>\r\n<td>PRD_CLS</td>\r\n<td>XYZ.VIEW_PROD_CLS_DEA</td>\r\n<td>3</td>\r\n<td>Identify prods from Dea</td>\r\n</tr>\r\n<tr>\r\n<td>PRD_CLS_BSK</td>\r\n<td>PRD_CLS</td>\r\n<td>XYZ.VIEW_PROD_CLS_BSK</td>\r\n<td>4</td>\r\n<td>Identify prods from Bsk</td>\r\n</tr>\r\n<tr>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<div><span style=\"text-decoration:underline\">Columns</span><br>\r\n- PLUGIN_ID: The unique identifier for the plug-in, consider a naming convention within the enterprise.<br>\r\n- INTERFACE_ID: The interface of the plug-in belongs to.<br>\r\n- PLUGIN_VIEW: The view which will implement the plug-in.<br>\r\n- PLUGIN_ORDER: The order where the plug-in will be assembled in the interface union view.<br>\r\n- DESCRIPTION_:<br>\r\n&nbsp;</div>\r\n<p>4. EXTRACT_RULE</p>\r\n<div>Sample:</div>\r\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border:1px solid #C0C0C0\">\r\n<tbody>\r\n<tr align=\"center\" bgcolor=\"gainsboro\" style=\"font-weight:bold\">\r\n<td>RULE_ID</td>\r\n<td>PLUGIN_ID</td>\r\n<td>TAG$01</td>\r\n<td>TAG$02</td>\r\n<td>TAG$03</td>\r\n<td>TAG$04</td>\r\n<td>...</td>\r\n</tr>\r\n<tr>\r\n<td>1</td>\r\n<td>PRD_CLS_BSK</td>\r\n<td>PC</td>\r\n<td>Flat Code A</td>\r\n<td>SWAP</td>\r\n<td>BASKET</td>\r\n<td>&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td>2</td>\r\n<td>PRD_CLS_SCM</td>\r\n<td>PC</td>\r\n<td>Flat Code B</td>\r\n<td>LST_OPT</td>\r\n<td>INDEX</td>\r\n<td>&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td>3</td>\r\n<td>PRD_CLS_SCM</td>\r\n<td>PC</td>\r\n<td>Flat Code C</td>\r\n<td>OTC_OPT</td>\r\n<td>INDEX</td>\r\n<td>&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td>4</td>\r\n<td>PRD_CLS_SCM</td>\r\n<td>PC</td>\r\n<td>Flat Code D</td>\r\n<td>FUTURE</td>\r\n<td>DEBT</td>\r\n<td>&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td>5</td>\r\n<td>PRD_CLS_DEA</td>\r\n<td>PC</td>\r\n<td>Flat Code E</td>\r\n<td>SWAP</td>\r\n<td>INDEX</td>\r\n<td>&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td>6</td>\r\n<td>PRD_CLS_DEA</td>\r\n<td>PC</td>\r\n<td>Flat Code F</td>\r\n<td>FORWARD</td>\r\n<td>INDEX</td>\r\n<td>&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td>7</td>\r\n<td>PRD_CLS_DEA</td>\r\n<td>PC</td>\r\n<td>Flat Code G</td>\r\n<td>FUTURE</td>\r\n<td>INDEX</td>\r\n<td>&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td>8</td>\r\n<td>PRD_CLS_SRM</td>\r\n<td>PC</td>\r\n<td>Flat Code H</td>\r\n<td>E</td>\r\n<td>ADR</td>\r\n<td>&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td>9</td>\r\n<td>PRD_CLS_SRM</td>\r\n<td>PC</td>\r\n<td>Flat Code I</td>\r\n<td>E</td>\r\n<td>COM</td>\r\n<td>&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td>10</td>\r\n<td>PRD_CLS_SRM</td>\r\n<td>PC</td>\r\n<td>Flat Code J</td>\r\n<td>E</td>\r\n<td>GDR</td>\r\n<td>&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<div><span style=\"text-decoration:underline\">Columns</span><br>\r\n- RULE_ID: The primary key of this table is pointless, it just means one unique rule. The business key should be in one or some of TAG$... columns. The integrity of rules configuration must be checked manually.<br>\r\n- PLUGIN_ID: This rule will be applied to which plug-in.<br>\r\n- TAG$01: A constant parameter to be used by the extraction plug-in view.<br>\r\n- TAG$02: ..<br>\r\n- TAG$03: ..<br>\r\n- TAG$04: ..<br>\r\n- TAG$05: ..<br>\r\n- TAG$06: ..<br>\r\n- TAG$07: ..<br>\r\n- TAG$08: ..<br>\r\n- TAG$09: ..<br>\r\n- TAG$10: ..<br>\r\n- TAG$11: ..<br>\r\n- TAG$12: ..<br>\r\n- TAG$13: ..<br>\r\n- TAG$14: ..<br>\r\n- TAG$15: ..<br>\r\n- TAG$16: ..<br>\r\n&nbsp;</div>\r\n<p>These TAG$## columns look a bit ugly in the practice. From the viewpoint of applied business, all rules under a interface are in the same category. So create a rule-view for each interface specially can solve the ugliness.<br>\r\nA trigger will create a new declaration of columns alias in EXTRACT_RULE_TAG_ALIAS table while a new interface is being added into EXTRACT_INTERFACE table, please assign intelligible alias to corresponding appliable columns.</p>\r\n<div>EXTRACT_RULE_TAG_ALIAS Sample:</div>\r\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border:1px solid #C0C0C0\">\r\n<tbody>\r\n<tr align=\"center\" bgcolor=\"gainsboro\" style=\"font-weight:bold\">\r\n<td>INTERFACE_ID</td>\r\n<td>RULE_VIEW</td>\r\n<td>TAG$01</td>\r\n<td>TAG$02</td>\r\n<td>TAG$03</td>\r\n<td>TAG$04</td>\r\n<td>...</td>\r\n</tr>\r\n<tr>\r\n<td>PRD_CLS</td>\r\n<td>XYZ.VIEW_CLASS_RULE</td>\r\n<td>PROD_NAME</td>\r\n<td>PLATFORM</td>\r\n<td>CLS_TYPE</td>\r\n<td>SEC_TYPE</td>\r\n<td>&nbsp;</td>\r\n</tr>\r\n<tr>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<div><span style=\"text-decoration:underline\">Columns</span><br>\r\n- INTERFACE_ID: The interface of the rule-view.<br>\r\n- RULE_VIEW: The updatable view of EXTRACT_RULE which will assign intelligible alias to appliable TAG$## columns.<br>\r\n- TAG$01: Alias of EXTRACT_RULE.TAG$01 column (if appliable).<br>\r\n- TAG$02: Alias of EXTRACT_RULE.TAG$02 column (if appliable).<br>\r\n- TAG$03: Alias of EXTRACT_RULE.TAG$03 column (if appliable).<br>\r\n- TAG$04: Alias of EXTRACT_RULE.TAG$04 column (if appliable).<br>\r\n- TAG$05: Alias of EXTRACT_RULE.TAG$05 column (if appliable).<br>\r\n- TAG$06: Alias of EXTRACT_RULE.TAG$06 column (if appliable).<br>\r\n- TAG$07: Alias of EXTRACT_RULE.TAG$07 column (if appliable).<br>\r\n- TAG$08: Alias of EXTRACT_RULE.TAG$08 column (if appliable).<br>\r\n- TAG$09: Alias of EXTRACT_RULE.TAG$09 column (if appliable).<br>\r\n- TAG$10: Alias of EXTRACT_RULE.TAG$10 column (if appliable).<br>\r\n- TAG$11: Alias of EXTRACT_RULE.TAG$11 column (if appliable).<br>\r\n- TAG$12: Alias of EXTRACT_RULE.TAG$12 column (if appliable).<br>\r\n- TAG$13: Alias of EXTRACT_RULE.TAG$13 column (if appliable).<br>\r\n- TAG$14: Alias of EXTRACT_RULE.TAG$14 column (if appliable).<br>\r\n- TAG$15: Alias of EXTRACT_RULE.TAG$15 column (if appliable).<br>\r\n- TAG$16: Alias of EXTRACT_RULE.TAG$16 column (if appliable).<br>\r\n&nbsp;</div>\r\n<p>Then a rule-view named XYZ.VIEW_CLASS_RULE (above sample) will be generated, it's a updatable view and can be used as a substitute of EXTRACT_RULE table for a specific area (interface).</p>\r\n<p>Above example is extracting and classifying hundreds of different product type from various source systems.</p>\r\n<ul>\r\n<li>The table EXTRACT_RULE induces them into a few extraction models, and centralizes all constant parameters (tags) to minimize hard-code queries.\r\n</li><li>Each extraction model expresss as a plug-in view. The table EXTRACT_PLUGIN describes which view presents the realization of each plug-in and which interface need to follow.\r\n</li><li>The table EXTRACT_INTERFACE declares the view signature of each interface (like delegate in C#), and the union view which assembles all its plug-in views. The code of union views and rule views can be generated by following helper view:\r\n</li></ul>\r\n<div style=\"padding-left:20px\">SELECT * FROM <span style=\"color:#808080\">VPI.</span>VIEW_EXTRACT_CODE</div>\r\n<div><img src=\"/Download?ProjectName=view&DownloadId=471646\" alt=\"view_code_generation\" width=\"689\" height=\"29\"></div>\r\n<div style=\"padding-left:20px\">Click the &lt;CLOB&gt;..., the generated code will be show in a pop-up window of PL/SQL.<br>\r\n&nbsp;</div>\r\n<p><strong>Session Context</strong></p>\r\n<p>In order to pass some parameters to a batch processing of views (like a OOP class with a parameterless constructor only), the session context is introduced in each batch of extraction processing. The package VPI.EXTRACT_UTILITY provides some functions/procedures\r\n to operate the session context.</p>\r\n<ol>\r\n<li>CREATE_BATCH: The constructor of batch session, this function return a new BATCH_ID.\r\n</li><li>SET_PARAMS: Set properties in a batch session for passing variables cross views. These variables are stored in table EXTRACT_BATCH.\r\n</li></ol>\r\n<p>For most batch processings, people would like to trace the progress updates during the processing, such as elapsed time, current status, % in progress bar, etc.</p>\r\n<ol>\r\n<li>PROGRESS_START: This procedure initializes how many steps will the batch process.\r\n</li><li>PROGRESS_UPDATE: This procedure updates current status. </li></ol>\r\n<div>For example (Oracle version):</div>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">PROCEDURE</span> ETL_MAIN\r\n(\r\n    inDate  <span style=\"color:blue\">DATE</span>\r\n) <span style=\"color:blue\">IS</span>\r\ntBatch_ID   PLS_INTEGER := <span style=\"color:#c0c0c0\">VPI.</span><span style=\"color:#808080\">EXTRACT_UTILITY.</span>CREATE_BATCH(<span style=\"color:#a31515\">'CO.GRP.PRD.ETL'</span>);\r\n<span style=\"color:blue\">BEGIN</span>\r\n    <span style=\"color:#c0c0c0\">VPI.</span><span style=\"color:#808080\">EXTRACT_UTILITY.</span>SET_PARAMS(tBatch_ID, <span style=\"color:#a31515\">'2012-07-31'</span>);\r\n\r\n    <span style=\"color:#c0c0c0\">VPI.</span><span style=\"color:#808080\">EXTRACT_UTILITY.</span>PROGRESS_START(12, 1, <span style=\"color:#a31515\">'Preloading(cleaning) some crucial slow sources ...'</span>);\r\n    PRELOAD_CACHE_SCM(tBatch_ID);\r\n\r\n    <span style=\"color:#c0c0c0\">VPI.</span><span style=\"color:#808080\">EXTRACT_UTILITY.</span>PROGRESS_UPDATE(<span style=\"color:#808080\">inProgress_Description =&gt;</span>\r\n        <span style=\"color:#a31515\">'Loading positions ...'</span>);\r\n    LOAD_POSITIONS(tBatch_ID);\r\n\r\n    <span style=\"color:#c0c0c0\">VPI.</span><span style=\"color:#808080\">EXTRACT_UTILITY.</span>PROGRESS_UPDATE(<span style=\"color:#808080\">inProgress_Description =&gt;</span>\r\n        <span style=\"color:#a31515\">'Loading top level securities and classifying product types ...'</span>);\r\n    LOAD_TOP_LEVEL_SECURITIES(tBatch_ID);\r\n\r\n    <span style=\"color:#c0c0c0\">VPI.</span><span style=\"color:#808080\">EXTRACT_UTILITY.</span>PROGRESS_UPDATE(<span style=\"color:#808080\">inProgress_Description =&gt;</span>\r\n        <span style=\"color:#a31515\">'Loading middle level securities ...'</span>);\r\n    LOAD_MID_LEVEL_SECURITIES(tBatch_ID);\r\n\r\n    <span style=\"color:#c0c0c0\">VPI.</span><span style=\"color:#808080\">EXTRACT_UTILITY.</span>PROGRESS_UPDATE(<span style=\"color:#808080\">inProgress_Description =&gt;</span>\r\n        <span style=\"color:#a31515\">'Loading bottom level securities ...'</span>);\r\n    LOAD_BTM_LEVEL_SECURITIES(tBatch_ID);\r\n\r\n    <span style=\"color:#c0c0c0\">VPI.</span><span style=\"color:#808080\">EXTRACT_UTILITY.</span>PROGRESS_UPDATE(<span style=\"color:#808080\">inProgress_Description =&gt;</span> <span style=\"color:#a31515\">'Loading issuers ...'</span>);\r\n    LOAD_ISSUERS(tBatch_ID);\r\n\r\n    ...\r\n\r\n    <span style=\"color:#c0c0c0\">VPI.</span><span style=\"color:#808080\">EXTRACT_UTILITY.</span>PROGRESS_UPDATE(<span style=\"color:#808080\">inProgress_Description =&gt;</span> <span style=\"color:#a31515\">'Done.'</span>);\r\n<span style=\"color:blue\">END</span> MAIN;</pre>\r\n</div>\r\n<p>Then the view VIEW_EXTRACT_BATCH_LOG or VIEW_LAST_BATCH_LOG can be used to mornitor the whole batch progress in background.<br>\r\nOr, UI can use the procedure EXTRACT_UTILITY.POLLING_PROGRESS to display a progress bar.</p>\r\n<p><strong>Query Optimization</strong></p>\r\n<p>Avoid/minimize using dynamic SQL and temp tables for extraction, SQL expression errors should be discovered at compile-time. Database view provides a facility for this, the execution plan is prepared when compiling the query, every query can be clearly optimized\r\n in advance.</p>\r\n<p><strong>Data Quality</strong></p>\r\n<p>The quality of source data always affects queries' performance disastrously.<br>\r\nBad data: missing, duplicate, impossible values ...<br>\r\nFor instance,<br>\r\n- Data missing requires you have to use OUTER JOIN instead of INNER JOIN; <br>\r\n- Data duplication requires you to have a extra MIN/MAX...GROUP BY...;<br>\r\n...<br>\r\nYou are not allowed to use straightforward SQL in these situations, but to complicate and slow down queries everywhere painfully! Some romantic business requirements even would ask you to split a regular JOIN SQL into several broken steps and check potential\r\n data error at every step, mark error flags, try this side, try that side and continue... Imagine there are some land mines were laid along the highway, then every vehicles are required to be mine-clearing vehicles!<br>\r\nIt is utterly opposed to the principle of using Structured Query Language efficiently.<br>\r\nEveryone known in theory, &quot;there is no bad data, but only bad applications(producers)&quot;. But in some companies for some reasons, once a new case of data exception was exposed, the requirements always ask downstream applications/reports to handle new error logic,\r\n instead of putting constraints in database and fixing upstream applications of data producer to prevent such case happend again. - Isn't it the Emperor's New Clothes, every eyewitness have to draw a new clothes on their own glasses!<br>\r\nAs a downstream application/report, normally it's also difficult to ask those tables in source systems to add proper indexes for optimizing high frequency queries or bottleneck queries of data consumers.<br>\r\n... All thus limitation of fact prompted us to own a isolated clean data environment, we should no longer to drive mine-clearing vehicles on the highway. So a preprocess of source data clean-up becames very helpful for the performance of all follow-up batch\r\n extractions. Base on the thinking of view-plug-ins, a Relationship Clean-up Engine has been introduced in\r\n<a href=\"http://datawashroom.codeplex.com/\" target=\"_self\">http://datawashroom.codeplex.com/</a>, since in most cases of bad data, the bad relationship is the most headache of headaches.</p>\r\n<p><strong>Pre-deployment</strong></p>\r\n<p>According to above metadata, all hub-views (union of plug-ins views) and rule-views need to be generated and pre-deployed in early stages of development cycle.</p>\r\n<p>The package <span style=\"color:#808080\">VPI.</span>PRE_DEPLOY provides following utilities:</p>\r\n<ul>\r\n<li>BUILD_SERVICE<br>\r\nGenerate source code of all rule-views and hub-views of all interfaces for a service.<br>\r\nEach time a service is built, a new version will be associated with the service. Behind the method BUILD_SERVICE, two tables PRE_DEPLOY_VERSION and PRE_DEPLOY_SCRIPT keep track of all historical versions.\r\n</li><li>PUBLISH_SERVICE<br>\r\nDeploy the latest version which generated by BUILD_SERVICE to the database. The publishing is actually the database engine compiles the generated code. Compilation errors will be recorded in PRE_DEPLOY_SCRIPT table and also be displayed on DBMS Output window\r\n of PL/SQL.<br>\r\nAs an option, all old objects (views) deployed by previous version can be dropped before the new deployment.\r\n</li><li>BUILD_AND_PUBLISH_SERVICE<br>\r\nDuring the development cycle, BUILD_SERVICE and PUBLISH_SERVICE usually would be run several rounds (once the metadata has a complete change). For the sake of convenience, BUILD_AND_PUBLISH_SERVICE simply combines BUILD_SERVICE and PUBLISH_SERVICE into one\r\n step. </li></ul>\r\n<p><strong>Metadata Deployment</strong></p>\r\n<p>In essence, the production deployment is to deploy metadata. Please see also the [<span style=\"color:#000080\">Build and Deploy</span>] section in\r\n<a href=\"http://datawashroom.codeplex.com/\" target=\"_blank\">http://datawashroom.codeplex.com/</a> for detail deployment mechanism.</p>\r\n<p>The view <span style=\"color:#008080\">VIEW_EXTRACT_METADATA</span> presents the Metadata Manifest for each service.</p>\r\n<p><strong>Supported Databases</strong></p>\r\n<ul>\r\n<li>Oracle<br>\r\n- Currently support. </li><li>SQL Server<br>\r\n- In the plan ... </li></ul>\r\n</div><div class=\"ClearBoth\"></div>",
  "TagList": "View-plug-ins,Database,Programming,Helper,Interface,Model,meta-tables,MetaData,Oracle,View,Plugin,interface-oriented,induction,simplify,clean,clear,Isolation,Unification,test-driven,loose-coupled,data model,classification,labeling,tagging,batch processing,ETL,reporting,DWH,extraction,rules,Data Warehouse,Hub-view,Rules Engine,code generation,Version Control,SQL,Inversion of Control,IoC,Dependency Injection,",
  "LastEdited": "2012-11-21T22:49:20.9-08:00"
}