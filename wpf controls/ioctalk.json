{
  "ProjectName": "ioctalk",
  "Title": "IOC-Talk",
  "Description": "The library supports interprocess communication using dependency injection.",
  "MovedLink": "https://github.com/bennil/ioctalk",
  "HomeWiki": "<div class=\"wikidoc\"><div style=\"clear:both;height:0;\">&nbsp;</div><img style=\"float:right;padding-left:.5em;\" src=\"/projects/ioctalk/9dec3841-faa9-4981-a3d7-c42f9ba7aefb\" alt=\"BSAGLogo2.png\" title=\"BSAGLogo2.png\" /><br />\n<h1>IOC-Talk</h1>\r\nThe IOC-Talk library supports interprocess communication using dependency injection. This allows you to design communication service interfaces without any dependencies to the underlying transfer technology. Besides the session concept (to know with whom you are talking) a remote call is done in the same way as a local dependency import method call. <br />\n<h2>Concept Overview</h2>\r<img src=\"/projects/ioctalk/feaec2ca-641b-44f6-a935-aaf67578bacc\" alt=\"ConceptOverview.png\" title=\"ConceptOverview.png\" /> <br />This diagram shows the architectural design of the IOC-Talk layers.<br />\n<h2>Remote Invoke Round-trip</h2>\r<img src=\"/projects/ioctalk/13d49154-53e0-4ba6-b7dd-636f593bfca0\" alt=\"InvokeRoundTrip.png\" title=\"InvokeRoundTrip.png\" /><br /> <br />If Component A calls a service interface method implemented in Component B, the dependency import in the business logic A will automatically be assigned to a proxy implementation of the target service interface B. The method invoke parameters will be serialized under the hood (JSON is default) and send to Component B. Component B will de-serialize the message and ask the local dependency container for the target interface implementation instance. Then the method is called and the return values (incl. out parameters) will be sent back to the origin on Component A. <br />\n<h2>Session Management</h2>\rThe physical communication session is fundamental on all layers to distinguish the remote counterparties. Every connection is represented by a session contract. The session contract is a custom class implementation that contains the supported local and remote services (interface imports). During session creation IOC-Talk assigns all new contract import instances to the session (connection). This is how IOC-Talk knows the recipient if the local business logic calls a remote service method. <br />\n<h4>Session Interface</h4>\rThe ISessionStateChanged interface can be implemented in your session contract or/and the service implementations. There are also session create/terminate events on the communication host.<br /><br />\n<h2>Project</h2>\rIOC-Talk was invented by <a href=\"https://www.boerse-stuttgart.de\">Boerse Stuttgart</a> (Germany’s second largest stock exchange) software division. It is published under the Apache Open License 2.0.<br />\n<h1>Sample Application</h1>\rDownload the “Sample Communication” application to try IOC-Talk in real life.<br /><br />\n<h2>Security</h2>\rThe communication can be secured using TLS encryption certificates (see sample app config).<br />\n<h2>Library</h2>\rThe IOC-Talk library is designed to support seamless exchange of the communication layer, message serializer and dependency container. The interfaces are all specified in the BSAG.IOCTalk.Common assembly. <br /><br />The current IOC-Talk .NET 4 library contains the following assemblies: \n<ul><li><b>BSAG.IOCTalk.Common Assembly</b>\n<ul><li>Contains common interfaces and default classes</li></ul></li>\n<li><b>BSAG.IOCTalk.Communication.Common Assembly</b>\n<ul><li>Contains the common communication service implementation</li></ul></li>\n<li><b>BSAG.IOCTalk.Communication.Tcp Assembly</b>\n<ul><li>TCP client/service communication library using message type and length header as encapsulation format.</li></ul></li>\n<li><b>BSAG.IOCTalk.Container.MEF Assembly</b>\n<ul><li>MEF dependency injection container host implementation (.NET 4 System.ComponentModel.Composition)</li></ul></li>\n<li><b>BSAG.IOCTalk.Logging Assembly</b>\n<ul><li>Default trace and data stream logger</li></ul></li>\n<li><b>BSAG.IOCTalk.Serialization.Json Assembly</b>\n<ul><li>JSON message serializer implementation. Because of performance reasons it&#39;s a custom implementation using the <a href=\"http://code.google.com/p/fast-member/\">FastMember</a> library instead of reflection.</li></ul></li></ul>\n</div><div class=\"ClearBoth\"></div>",
  "TagList": "dependency injection,interprocess,Inversion of Control,RPC,microservices,",
  "LastEdited": "2015-10-17T13:11:56-07:00"
}