{
  "ProjectName": "iocwrap",
  "Title": "IoCWrap",
  "Description": "Provides a wrapper to the various IoC container implementations so that it is possible to switch to a different provider without changing any application code.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><h1>Welcome to the IoCWrap project!</h1>\r\n<h2><i>NOTE:</i> This project is no longer maintained here. Please visit <a href=\"https://bitbucket.org/virtualstaticvoid/iocwrap\">IoCWrap@Bitbucket</a>.</h2>\r\nThe IoCWrap project provides a set of interfaces and boiler plate base classes to provide a standard way to wrap to the various IoC container implementations.<br /><br />Unlike the <a href=\"http://commonservicelocator.codeplex.com\">CommonServiceLocator</a>, IoCWrap includes a fluent interface, similar to that found in Autofac and StructureMap, for the configuration of the container.<br />It is therefore possible to configure and use an inversion of control container without be tied into a specific implementation in your code and provides the ability to switch to a different container without any impact.<br />\n<h1>Supported Implementations</h1>\r<ul><li><a href=\"http://code.google.com/p/autofac\">Autofac</a> - Completed</li>\n<li><a href=\"http://www.castleproject.org/container\">Castle Windsor</a></li>\n<li><a href=\"http://github.com/enkari/ninject\">NInject</a></li>\n<li><a href=\"http://www.springframework.net\">Spring.Net</a></li>\n<li><a href=\"http://structuremap.github.com/structuremap\">StructureMap</a></li>\n<li><a href=\"http://unity.codeplex.com\">Unity</a></li></ul>\n\n<h1>Usage</h1>\r\nConfiguration via the fluent interface, where <i>&lt;ContainerProvider&gt;</i> is the provider of the desired container implementation, as follows:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\nIContainerBuilder builder = &lt;ContainerProvider&gt;.CreateBuilder();\n\nbuilder.Register&lt;Instance&gt;()\n  .As&lt;IInstance&gt;()\n  .FactoryScoped();\n\nbuilder.Register&lt;SingleInstance&gt;()\n  .As&lt;ISingleInstance&gt;()\n  .SingletonScoped();\n\nbuilder.Register&lt;NamedInstance&gt;()\n  .Named&lt;INamedInstance&gt;(<span style=\"color:#A31515;\">&quot;NamedInstance&quot;</span>)\n  .FactoryScoped();\n\nbuilder.Register&lt;NamedSingleInstance&gt;()\n  .Named&lt;INamedSingleInstance&gt;(<span style=\"color:#A31515;\">&quot;NamedSingleInstance&quot;</span>)\n  .SingletonScoped();\n\nbuilder.Register&lt;ICustomService&gt;(c =&gt; <span style=\"color:Blue;\">new</span> CustomService())\n  .FactoryScoped();\r\n</pre></div><br />In addition, registrations can be done by implementing the <i>IRegistry</i> interface:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">class</span> TestRegistry : IRegistry\n{\n  <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">void</span> Configure(IContainerBuilder builder)\n  {\n    builder.Register&lt;Instance&gt;()\n      .As&lt;IInstance&gt;()\n      .FactoryScoped();\n  }\n}\r\n</pre></div><br />The builder can load implementations of the <i>IRegistry</i> interface, and invoke the <i>Configure()</i> method to perform registrations.<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">// loads the given registry</span>\nbuilder.AddRegistry&lt;TestRegistry&gt;();\n\n<span style=\"color:Green;\">// loads the given registry</span>\nbuilder.AddRegistry(<span style=\"color:Blue;\">new</span> TestRegistry());\n\n<span style=\"color:Green;\">// loads registries found in the given assembly</span>\nbuilder.AddRegistriesFromAssembly(Assembly.GetExecutingAssembly());\n\n<span style=\"color:Green;\">// loads registries found in a list of assemblies</span>\nbuilder.AddRegistriesFromAssemblies(AppDomain.CurrentDomain.GetAssemblies());\n\n<span style=\"color:Green;\">// loads registries found in the given type&#39;s assembly</span>\nbuilder.AddRegistriesFromAssemblyOf&lt;Program&gt;();\r\n</pre></div><br />Once the required types have been registered with the builder, the container can be created, and services resolved via the various <i>Resolve()</i> method overloads:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\nIContainer container = builder.Build();\n\n<span style=\"color:Blue;\">var</span> service = container.Resolve&lt;Instance&gt;();\r\n</pre></div>\n<h1>Implementing you own ContainerProvider</h1>\rTo implement your own container provider, there are four interfaces that will need to be implemented.<br /><br />The <i>IContainerProvider</i> provides an instance of the builder for your container.<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">interface</span> IContainerProvider\n{\n  IContainerBuilder CreateBuilder();\n}\r\n</pre></div><br />The <i>IContainerBuilder</i> interface provides the means to register types and to ultimately build the container.<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">interface</span> IContainerBuilder\n{\n  IContainer Build();\n  IContainerRegistration Register(Type type);\n  IContainerRegistration Register&lt;TType&gt;();\n  IContainerRegistration Register&lt;TType&gt;(TType instance) <span style=\"color:Blue;\">where</span> TType : <span style=\"color:Blue;\">class</span>;\n  IContainerRegistration Register&lt;TType&gt;(ContainerComponentActivator&lt;TType&gt; activator);\n}\r\n</pre></div><br />For fluent configuration of the container, the <i>IContainerRegistration</i> interface provides the most common requirements.<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">interface</span> IContainerRegistration\n{\n  IContainerRegistration As&lt;TService&gt;();\n  IContainerRegistration As(Type serviceType);\n  IContainerRegistration As(<span style=\"color:Blue;\">params</span> Type[] serviceTypes);\n\n  IContainerRegistration Named&lt;TService&gt;(<span style=\"color:Blue;\">string</span> serviceName);\n  IContainerRegistration Named(<span style=\"color:Blue;\">string</span> serviceName, Type serviceType);\n\n  IContainerRegistration SingletonScoped();\n  IContainerRegistration FactoryScoped();\n  IContainerRegistration ContainerScoped();\n\n  IContainerRegistration ExternallyOwned();\n  IContainerRegistration OwnedByContainer();\n\n  IContainerRegistration WithExtendedProperty(<span style=\"color:Blue;\">string</span> key, <span style=\"color:Blue;\">object</span> value);\n}\r\n</pre></div><br />And the <i>IContainer</i> provides type resolution for the registered types.<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">interface</span> IContainer\n{\n  TType Resolve&lt;TType&gt;();\n  TType Resolve&lt;TType&gt;(<span style=\"color:Blue;\">string</span> serviceName);\n  TType Resolve&lt;TType&gt;(Type serviceType);\n  <span style=\"color:Blue;\">bool</span> TryResolve&lt;TType&gt;(<span style=\"color:Blue;\">out</span> TType instance);\n  <span style=\"color:Blue;\">bool</span> TryResolve&lt;TType&gt;(Type serviceType, <span style=\"color:Blue;\">out</span> TType instance);\n  <span style=\"color:Blue;\">bool</span> TryResolve&lt;TType&gt;(<span style=\"color:Blue;\">string</span> serviceName, <span style=\"color:Blue;\">out</span> TType instance);\n}\r\n</pre></div><br />Checkout the <i>IoCWrap.Autofac</i> project in the source code, for an example implementation of the <a href=\"http://code.google.com/p/autofac\">Autofac</a> IoC framework.<br /></div><div class=\"ClearBoth\"></div>",
  "TagList": "IOC,IoC/DI,container,Inversion of Control,dependency injection,",
  "LastEdited": "2013-03-20T15:53:45.857-07:00"
}