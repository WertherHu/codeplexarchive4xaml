{
  "ProjectName": "rmvvm",
  "Title": "Responsive MVVM",
  "Description": "MVVM is a great framework for Silverlight and WPF development. But the major flaw with MVVM is with its responsiveness. When the number of user controls increase beyond a certain limit, the UI gets very slow. Responsive MVVM framework aims to make the UI more responsive.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><b>Project Description</b><br />MVVM is a great framework for Silverlight and WPF development. But the major flaw with MVVM is with its responsiveness. When the number of user controls increase beyond a certain limit, the UI gets very slow. Responsive MVVM framework aims to make the UI more responsive.<br /><br /><br />\n<h1>Problems we are trying to address</h1>\r<h2>Keep the UI responsive even when the Model takes a lot of time to return</h2>\rThis is a very general case of application hang. You Model is performing a CPU intensive calculation or waiting on response from service etc. to return results. If your View-&gt;ViewModel-&gt;Model are tied up in a single thread, the View will hang until the Model returns data.<br /><br />This is demonstrated in the Source Code (Examples of need of RMVVM\\TimeConsumingProcessingProblem\\ProblemStatement) <br /><br /><img src=\"/projects/rmvvm/a7007f23-1a15-4f82-9b59-c3ce81df9458\" alt=\"TimeConsumingProcessingProblem.jpg\" title=\"TimeConsumingProcessingProblem.jpg\" /><br /><br />On click of the <b>Increment Count</b> button\n<ul><li>We should be able to see the counter value increase gradually from 0 onwards</li>\n<li>We should be able to initiate another action like <b>Decrement Count</b> while Increment Count is in progress</li></ul>\n<br />There are two solutions proposed for this situation. <br /><img src=\"/projects/rmvvm/65a3d2d4-7b30-4f72-903f-949b2757247c\" alt=\"TimeConsumingProcessingProblem-SolUsingModel.jpg\" title=\"TimeConsumingProcessingProblem-SolUsingModel.jpg\" />\n<ol><li>Make the calls to Model using a new thread <i>(Examples of need of RMVVM\\TimeConsumingProcessingProblem\\SolutionUsingThreadsInModel)</i></li>\n<li>Make the calls to ViewModel using a new thread <i>(Examples of need of RMVVM\\TimeConsumingProcessingProblem\\SolutionUsingThreadsInViewModel)</i></li></ol>\nMaking changes to ViewModel is a more elegant solution since you have to make change at only one place (RelayCommand) and you catch the problem early on before there are repercussions of it.<br /><br />\n<h2>Keep the UI responsive even when large number of items are added to a data bound collection </h2>\rWe generally use ObservableCollection in View to databind to a collection of items in ViewModel. Whenever the ViewModel collection changes the UI gets updated automatically. But when a large number of items are added in a loop (for e.g. on start of app when a huge collection is loaded based on data from service), the UI hangs until the collection creation is complete.<br />  <br />This is demonstrated in the Source Code (Examples of need of RMVVM\\HandlingThousandsOfElementsInUIProblem\\ProblemStatement) <br /><br /><img src=\"/projects/rmvvm/4f9fc1fc-b4c5-4e18-82bd-e04cdc55d419\" alt=\"HandlingThousandsOfElementsInUIProblem.jpg\" title=\"HandlingThousandsOfElementsInUIProblem.jpg\" /><br /><br />On click of the <b>Load All Small Items</b> button\n<ul><li>We should be able to see small red boxes being added to the window on a continuous basis. It should not hang the UI for some time and then show all items together at once.</li>\n<li>We should be able to initiate another action like <b>Show Message</b> to show &quot;Am alive!!&quot; message box while addition of items into collection is in progress</li></ul>\n<br />There are two solutions proposed for this situation. <br /><img src=\"/projects/rmvvm/14830b69-2b73-4ba7-8daf-903dcd28a170\" alt=\"HandlingThousandsOfElementsInUIProblem-SolUsingModel.jpg\" title=\"HandlingThousandsOfElementsInUIProblem-SolUsingModel.jpg\" />\n<ol><li>Make the calls to Model using a new thread <i>(Examples of need of RMVVM\\HandlingThousandsOfElementsInUIProblem\\SolutionUsingThreadsInModel)</i></li>\n<li>Make the calls to ViewModel using a new thread <i>(Examples of need of RMVVM\\HandlingThousandsOfElementsInUIProblem\\SolutionUsingThreadsInViewModel)</i></li></ol>\nAs before, making changes to ViewModel is a more elegant solution since you have to make change at only one place (RelayCommand) and you catch the problem early on before there are repercussions of it.<br /><br />Also ObvservableCollection will not allow you to add items to collection from a thread different from the one that created the collection. Hence you need to use a modified collection which can add items using the dispatcher thread (I have used the ObservationCollectionEx proposed at <a href=\"http://geekswithblogs.net/NewThingsILearned/archive/2008/01/16/have-worker-thread-update-observablecollection-that-is-bound-to-a.aspx\">http://geekswithblogs.net/NewThingsILearned/archive/2008/01/16/have-worker-thread-update-observablecollection-that-is-bound-to-a.aspx</a>)<br /><br /></div><div class=\"ClearBoth\"></div>",
  "TagList": "",
  "LastEdited": "2012-03-18T01:46:34.827-07:00"
}