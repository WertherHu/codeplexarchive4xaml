{
  "ProjectName": "vmbase",
  "Title": "View Model Base Extensions",
  "Description": "This is a small base framework for MVVM in winRT,Windows Phone, WPF and Silverlight. Also included some necessary extension methods.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><h1>Project Description</h1>\rThis is a small base framework for MVVM in winRT,Windows Phone, WPF and Silverlight. Also included some necessary extension methods.\n<h1>NuGet</h1>\rAlso <b>WinRT</b> (For Windows 8 Store Applciations) version is available at NuGet <a href=\"http://www.nuget.org/packages/VMBase/\">http://www.nuget.org/packages/VMBase/</a>\n<h1>Details</h1>\rAs a developer you could build your viewmodel according to the our <b>VMBase</b> and <b>VMPageBase</b>.\n<h2>VMBase</h2>\rInheriting <b>VMBase</b> to your ViewModels of your project will following abilities to your View Models:\n<ul><li><b>Marshaling</b> : VMBase objects could be marshaled as unmanaged memory bytes and could be read from unmanaged bytes.</li>\n<li><b>XML</b> : VMBase objects could be serialized to XML bytes and XML Strings and cloud deserialized form XML strings and XML bytes.</li>\n<li><b>Json</b> : VMBase objects could be serialized to JSON bytes and JSON Strings and cloud deserialized form JSON strings and JSON bytes. To do that Newtonsoft <a href=\"https://vmbase.codeplex.com/wikipage?title=http%3a%2f%2fjson.codeplex.com%2f&referringTitle=Home\">Json.NET</a> has been used.</li>\n<li><b>Storage</b>: VMBase objects could be save themselves to the local data folder as serialized XML files. Also there are static methods in VMBase could save string and byte arrays in the data folder.</li>\n<li>There are also virtual methods <b>Initialize, Suspend and Clone</b>. Those could be override in the Child class and used for registering / unregistering event handlers and resources. </li>\n<li>Also <b>INotifyPropertyChanged</b> Interface is properly implemented. With <i>public void NotifyPropertyChanged(string info)</i> method any MVVM property can be notified in the setter.</li></ul>\n<h2>ByteHelper</h2>\rThere is a static extension class called <b>Byte Helper</b> in it. There is good functions in that about Hex, Byte and String conversions and calculations.<br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">using</span> System;\n<span style=\"color:Blue;\">using</span> System.Collections.Generic;\n<span style=\"color:Blue;\">using</span> System.IO;\n<span style=\"color:Blue;\">using</span> System.IO.Compression;\n<span style=\"color:Blue;\">using</span> System.Linq;\n<span style=\"color:Blue;\">using</span> System.Threading.Tasks;\n<span style=\"color:Blue;\">using</span> sStream = Windows.Storage.Streams;\n<span style=\"color:Blue;\">using</span> storage = Windows.Storage;\n\n<span style=\"color:Blue;\">namespace</span> WinRTBase\n{\n    <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">class</span> ByteHepler\n    {\n        <span style=\"color:Blue;\">#region</span> Compression\n        <span style=\"color:Blue;\">private</span> async <span style=\"color:Blue;\">static</span> Task&lt;<span style=\"color:Blue;\">byte</span>[]&gt; compress(<span style=\"color:Blue;\">byte</span>[] raw)\n        {\n            <span style=\"color:Blue;\">using</span> (MemoryStream memory = <span style=\"color:Blue;\">new</span> MemoryStream())\n            {\n                <span style=\"color:Blue;\">using</span> (GZipStream gzip = <span style=\"color:Blue;\">new</span> GZipStream(memory, CompressionMode.Compress, <span style=\"color:Blue;\">true</span>))\n                {\n                    await gzip.WriteAsync(raw, 0, raw.Length);\n                }\n                await memory.FlushAsync();\n                <span style=\"color:Blue;\">return</span> memory.ToArray();\n            }\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> async Task&lt;<span style=\"color:Blue;\">byte</span>[]&gt; CompressAsync(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">byte</span>[] raw) { <span style=\"color:Blue;\">return</span> await compress(raw); }\n\n        <span style=\"color:Blue;\">private</span> async <span style=\"color:Blue;\">static</span> Task&lt;<span style=\"color:Blue;\">byte</span>[]&gt; decompress(<span style=\"color:Blue;\">byte</span>[] gzip)\n        {\n            <span style=\"color:Green;\">// Create a GZIP stream with decompression mode.</span>\n            <span style=\"color:Green;\">// ... Then create a buffer and write into while reading from the GZIP stream.</span>\n            <span style=\"color:Blue;\">using</span> (GZipStream stream = <span style=\"color:Blue;\">new</span> GZipStream(<span style=\"color:Blue;\">new</span> MemoryStream(gzip), CompressionMode.Decompress))\n            {\n                <span style=\"color:Blue;\">const</span> <span style=\"color:Blue;\">int</span> size = 4096;\n                <span style=\"color:Blue;\">byte</span>[] buffer = <span style=\"color:Blue;\">new</span> <span style=\"color:Blue;\">byte</span>[size];\n                <span style=\"color:Blue;\">using</span> (MemoryStream memory = <span style=\"color:Blue;\">new</span> MemoryStream())\n                {\n                    <span style=\"color:Blue;\">int</span> count = 0;\n                    <span style=\"color:Blue;\">do</span>\n                    {\n                        count = await stream.ReadAsync(buffer, 0, size);\n                        <span style=\"color:Blue;\">if</span> (count &gt; 0)\n                            await memory.WriteAsync(buffer, 0, count);\n                    }\n                    <span style=\"color:Blue;\">while</span> (count &gt; 0);\n                    <span style=\"color:Blue;\">return</span> memory.ToArray();\n                }\n            }\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> async Task&lt;<span style=\"color:Blue;\">byte</span>[]&gt; DeCompressAsync(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">byte</span>[] raw) { <span style=\"color:Blue;\">return</span> await decompress(raw); }\n        <span style=\"color:Blue;\">#endregion</span>\n        <span style=\"color:Blue;\">#region</span> Byte\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">byte</span>[] SubBytes(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">byte</span>[] bytes, <span style=\"color:Blue;\">int</span> start, <span style=\"color:Blue;\">int</span> lenght)\n        {\n            <span style=\"color:Blue;\">byte</span>[] retVal = <span style=\"color:Blue;\">new</span> <span style=\"color:Blue;\">byte</span>[lenght];\n            <span style=\"color:Blue;\">for</span> (<span style=\"color:Blue;\">int</span> i = start; i &lt; bytes.Length; i++)\n                retVal[i - start] = bytes[i];\n            <span style=\"color:Blue;\">return</span> retVal;\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> IEnumerable&lt;<span style=\"color:Blue;\">byte</span>[]&gt; SplitWithBuffer(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">byte</span>[] bytes, <span style=\"color:Blue;\">int</span> buffer = 65535)\n        {\n            <span style=\"color:Blue;\">for</span> (<span style=\"color:Blue;\">var</span> i = 0; i &lt; bytes.Length; i += buffer)\n                <span style=\"color:Blue;\">yield</span> <span style=\"color:Blue;\">return</span> bytes.SubBytes(i, Math.Min(buffer, bytes.Length - i));\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">byte</span>[] CombineFromBuffer(<span style=\"color:Blue;\">this</span> IEnumerable&lt;<span style=\"color:Blue;\">byte</span>[]&gt; byteBufferCollection)\n        {\n            List&lt;<span style=\"color:Blue;\">byte</span>&gt; retVal = <span style=\"color:Blue;\">new</span> List&lt;<span style=\"color:Blue;\">byte</span>&gt;();\n            <span style=\"color:Blue;\">foreach</span> (<span style=\"color:Blue;\">var</span> bytes <span style=\"color:Blue;\">in</span> byteBufferCollection)\n                retVal.AddRange(bytes);\n            <span style=\"color:Blue;\">return</span> retVal.ToArray();\n        }\n        <span style=\"color:Blue;\">#endregion</span>\n        <span style=\"color:Blue;\">#region</span> Hex\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">string</span> ToHex(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">byte</span>[] bytes)\n        {\n            <span style=\"color:Blue;\">char</span>[] c = <span style=\"color:Blue;\">new</span> <span style=\"color:Blue;\">char</span>[bytes.Length * 2];\n            <span style=\"color:Blue;\">byte</span> b;\n            <span style=\"color:Blue;\">for</span> (<span style=\"color:Blue;\">int</span> bx = 0, cx = 0; bx &lt; bytes.Length; ++bx, ++cx)\n            {\n                b = ((<span style=\"color:Blue;\">byte</span>)(bytes[bx] &gt;&gt; 4));\n                c[cx] = (<span style=\"color:Blue;\">char</span>)(b &gt; 9 ? b + 0x37 + 0x20 : b + 0x30);\n\n                b = ((<span style=\"color:Blue;\">byte</span>)(bytes[bx] &amp; 0x0F));\n                c[++cx] = (<span style=\"color:Blue;\">char</span>)(b &gt; 9 ? b + 0x37 + 0x20 : b + 0x30);\n            }\n            <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">new</span> <span style=\"color:Blue;\">string</span>(c);\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> IEnumerable&lt;<span style=\"color:Blue;\">string</span>&gt; ToHexWithBuffer(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">byte</span>[] bytes, <span style=\"color:Blue;\">int</span> buffer = 65535)\n        {\n            <span style=\"color:Blue;\">int</span> maxStrLen = buffer / 2;\n            <span style=\"color:Blue;\">string</span> hexStr = bytes.ToHex();\n            IEnumerable&lt;<span style=\"color:Blue;\">string</span>&gt; retVal = hexStr.SplitInParts(maxStrLen);\n            <span style=\"color:Blue;\">return</span> retVal;\n        }\n\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">byte</span>[] HexToBytes(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">string</span> str)\n        {\n            <span style=\"color:Blue;\">if</span> (str.Length == 0 || str.Length % 2 != 0)\n                <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">new</span> <span style=\"color:Blue;\">byte</span>[0];\n\n            <span style=\"color:Blue;\">byte</span>[] buffer = <span style=\"color:Blue;\">new</span> <span style=\"color:Blue;\">byte</span>[str.Length / 2];\n            <span style=\"color:Blue;\">char</span> c;\n            <span style=\"color:Blue;\">for</span> (<span style=\"color:Blue;\">int</span> bx = 0, sx = 0; bx &lt; buffer.Length; ++bx, ++sx)\n            {\n                <span style=\"color:Green;\">// Convert first half of byte</span>\n                c = str[sx];\n                buffer[bx] = (<span style=\"color:Blue;\">byte</span>)((c &gt; <span style=\"color:#A31515;\">&#39;9&#39;</span> ? (c &gt; <span style=\"color:#A31515;\">&#39;Z&#39;</span> ? (c - <span style=\"color:#A31515;\">&#39;a&#39;</span> + 10) : (c - <span style=\"color:#A31515;\">&#39;A&#39;</span> + 10)) : (c - <span style=\"color:#A31515;\">&#39;0&#39;</span>)) &lt;&lt; 4);\n\n                <span style=\"color:Green;\">// Convert second half of byte</span>\n                c = str[++sx];\n                buffer[bx] |= (<span style=\"color:Blue;\">byte</span>)(c &gt; <span style=\"color:#A31515;\">&#39;9&#39;</span> ? (c &gt; <span style=\"color:#A31515;\">&#39;Z&#39;</span> ? (c - <span style=\"color:#A31515;\">&#39;a&#39;</span> + 10) : (c - <span style=\"color:#A31515;\">&#39;A&#39;</span> + 10)) : (c - <span style=\"color:#A31515;\">&#39;0&#39;</span>));\n            }\n\n            <span style=\"color:Blue;\">return</span> buffer;\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">byte</span>[] BufferedHexToBytes(<span style=\"color:Blue;\">this</span> IEnumerable&lt;<span style=\"color:Blue;\">string</span>&gt; str, <span style=\"color:Blue;\">int</span> buffer = 65535)\n        {\n            <span style=\"color:Blue;\">string</span> myHexStr = <span style=\"color:Blue;\">string</span>.Concat(str.ToArray());\n            <span style=\"color:Blue;\">return</span> myHexStr.HexToBytes();\n        }\n        <span style=\"color:Blue;\">#endregion</span>\n        <span style=\"color:Blue;\">#region</span> Cryptology\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;str&quot;&gt;</span><span style=\"color:Green;\">Unique key for encryption/decryption&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;key&quot;&gt;</span><span style=\"color:Gray;\">&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;algorithm&quot;&gt;</span><span style=\"color:Green;\">Use Windows.Security.Cryptography.Core.SymmetricAlgorithmNames Class&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;hashAlgorithm&quot;&gt;</span><span style=\"color:Green;\">Use Windows.Security.Cryptography.Core.HashAlgorithmNames Class&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Green;\">Returns encrypted bytes.&lt;/returns&gt;</span>\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">string</span> Encrypt(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">string</span> str, <span style=\"color:Blue;\">string</span> key, <span style=\"color:Blue;\">string</span> algorithm, <span style=\"color:Blue;\">string</span> hashAlgorithm)\n        {\n            <span style=\"color:Blue;\">return</span> Cryptology.Algorithms.Encrypt(str, key, algorithm, hashAlgorithm);\n        }\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;str&quot;&gt;</span><span style=\"color:Green;\">Unique key for encryption/decryption&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;key&quot;&gt;</span><span style=\"color:Gray;\">&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;algorithm&quot;&gt;</span><span style=\"color:Green;\">Use Windows.Security.Cryptography.Core.SymmetricAlgorithmNames Class&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;hashAlgorithm&quot;&gt;</span><span style=\"color:Green;\">Use Windows.Security.Cryptography.Core.HashAlgorithmNames Class&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Green;\">Returns decrypted bytes.&lt;/returns&gt;</span>\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">string</span> Decrypt(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">string</span> str, <span style=\"color:Blue;\">string</span> key, <span style=\"color:Blue;\">string</span> algorithm, <span style=\"color:Blue;\">string</span> hashAlgorithm)\n        {\n            <span style=\"color:Blue;\">return</span> Cryptology.Algorithms.Decrypt(str, key, algorithm, hashAlgorithm);\n        }\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;str&quot;&gt;</span><span style=\"color:Gray;\">&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;key&quot;&gt;</span><span style=\"color:Green;\">Unique key for encryption/decryption&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;algorithm&quot;&gt;</span><span style=\"color:Green;\">Use Windows.Security.Cryptography.Core.SymmetricAlgorithmNames Class&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;hashAlgorithm&quot;&gt;</span><span style=\"color:Green;\">Use Windows.Security.Cryptography.Core.HashAlgorithmNames Class&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Green;\">Returns encrypted bytes.&lt;/returns&gt;</span>\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">byte</span>[] Encrypt(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">byte</span>[] bytes, <span style=\"color:Blue;\">string</span> key, <span style=\"color:Blue;\">string</span> algorithm, <span style=\"color:Blue;\">string</span> hashAlgorithm)\n        {\n            <span style=\"color:Blue;\">return</span> Cryptology.Algorithms.Encrypt(bytes, key, algorithm, hashAlgorithm);\n        }\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;str&quot;&gt;</span><span style=\"color:Gray;\">&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;key&quot;&gt;</span><span style=\"color:Green;\">Unique key for encryption/decryption&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;algorithm&quot;&gt;</span><span style=\"color:Green;\">Use Windows.Security.Cryptography.Core.SymmetricAlgorithmNames Class&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;hashAlgorithm&quot;&gt;</span><span style=\"color:Green;\">Use Windows.Security.Cryptography.Core.HashAlgorithmNames Class&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Green;\">Returns decrypted bytes.&lt;/returns&gt;</span>\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">byte</span>[] Decrypt(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">byte</span>[] bytes, <span style=\"color:Blue;\">string</span> key, <span style=\"color:Blue;\">string</span> algorithm, <span style=\"color:Blue;\">string</span> hashAlgorithm)\n        {\n            <span style=\"color:Blue;\">return</span> Cryptology.Algorithms.Decrypt(bytes, key, algorithm, hashAlgorithm);\n        }\n        <span style=\"color:Blue;\">#endregion</span>\n        <span style=\"color:Blue;\">#region</span> String\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> IEnumerable&lt;String&gt; SplitInParts(<span style=\"color:Blue;\">this</span> String s, Int32 partLength)\n        {\n            <span style=\"color:Blue;\">if</span> (s == <span style=\"color:Blue;\">null</span>)\n                <span style=\"color:Blue;\">throw</span> <span style=\"color:Blue;\">new</span> ArgumentNullException(<span style=\"color:#A31515;\">&quot;s&quot;</span>);\n            <span style=\"color:Blue;\">if</span> (partLength &lt;= 0)\n                <span style=\"color:Blue;\">throw</span> <span style=\"color:Blue;\">new</span> ArgumentException(<span style=\"color:#A31515;\">&quot;Part length has to be positive.&quot;</span>, <span style=\"color:#A31515;\">&quot;partLength&quot;</span>);\n\n            <span style=\"color:Blue;\">for</span> (<span style=\"color:Blue;\">var</span> i = 0; i &lt; s.Length; i += partLength)\n                <span style=\"color:Blue;\">yield</span> <span style=\"color:Blue;\">return</span> s.Substring(i, Math.Min(partLength, s.Length - i));\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">int</span> ToInt(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">string</span> str)\n        {\n            <span style=\"color:Blue;\">int</span> retVal;\n            <span style=\"color:Blue;\">int</span>.TryParse(str, <span style=\"color:Blue;\">out</span> retVal);\n            <span style=\"color:Blue;\">return</span> retVal;\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">double</span> ToDouble(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">string</span> str)\n        {\n            <span style=\"color:Blue;\">double</span> retVal;\n            <span style=\"color:Blue;\">double</span>.TryParse(str, <span style=\"color:Blue;\">out</span> retVal);\n            <span style=\"color:Blue;\">return</span> retVal;\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">bool</span> IsNumeric(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">string</span> str)\n        {\n            <span style=\"color:Blue;\">foreach</span> (<span style=\"color:Blue;\">char</span> c <span style=\"color:Blue;\">in</span> str)\n                <span style=\"color:Blue;\">if</span> (!<span style=\"color:Blue;\">char</span>.IsNumber(c))\n                    <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">false</span>;\n\n            <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">true</span>;\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">bool</span> IsDouble(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">string</span> str)\n        {\n            <span style=\"color:Blue;\">double</span> retVal;\n            <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">double</span>.TryParse(str, <span style=\"color:Blue;\">out</span> retVal);\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">string</span> TrimLast(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">string</span> str, <span style=\"color:Blue;\">int</span> length)\n        {\n            <span style=\"color:Blue;\">return</span> str.Length &gt; length ? str.Substring(0, length) + <span style=\"color:#A31515;\">&quot;...&quot;</span> : str;\n        }\n        <span style=\"color:Blue;\">#endregion</span>\n        <span style=\"color:Blue;\">#region</span> File\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> async Task&lt;<span style=\"color:Blue;\">byte</span>[]&gt; GetBytesAsync(<span style=\"color:Blue;\">this</span> storage.StorageFile file)\n        {\n            sStream.IRandomAccessStream fileStream = await file.OpenAsync(storage.FileAccessMode.Read);\n            <span style=\"color:Blue;\">var</span> reader = <span style=\"color:Blue;\">new</span> sStream.DataReader(fileStream.GetInputStreamAt(0));\n            await reader.LoadAsync((<span style=\"color:Blue;\">uint</span>)fileStream.Size);\n            <span style=\"color:Blue;\">byte</span>[] bytes = <span style=\"color:Blue;\">new</span> <span style=\"color:Blue;\">byte</span>[fileStream.Size];\n            reader.ReadBytes(bytes);\n            <span style=\"color:Blue;\">return</span> bytes;\n        }\n        <span style=\"color:Blue;\">#endregion</span>\n    }\n}\r\n</pre></div><h2>Cryptography</h2>\rThere is a good Cryptography wrapper for winRT. A lot of Encryption methods are implemented like static extensions. And used like <i>value.Encrypt();</i><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">using</span> System;\n<span style=\"color:Blue;\">using</span> System.Threading.Tasks;\n<span style=\"color:Blue;\">using</span> Windows.Security.Cryptography;\n<span style=\"color:Blue;\">using</span> Windows.Security.Cryptography.Core;\n<span style=\"color:Blue;\">using</span> Windows.Security.Cryptography.DataProtection;\n<span style=\"color:Blue;\">using</span> Windows.Storage.Streams;\n\n<span style=\"color:Blue;\">namespace</span> WinRTBase\n{\n    <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">class</span> Cryptology\n    {\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> .NET Framework Cryptography Model</span>\n        <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> http://msdn.microsoft.com/en-us/library/0ss79b2x.aspx</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">sealed</span> <span style=\"color:Blue;\">class</span> Algorithms\n        {\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n            <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> Encrypt bytes using dual encryption method. Returns an encrypted bytes.</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;toEncrypt&quot;&gt;</span><span style=\"color:Green;\">Bytes to be encrypted&lt;/param&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;key&quot;&gt;</span><span style=\"color:Green;\">Unique key for encryption/decryption&lt;/param&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;algorithm&quot;&gt;</span><span style=\"color:Green;\">Use Windows.Security.Cryptography.Core.SymmetricAlgorithmNames Class&lt;/param&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;hashAlgorithm&quot;&gt;</span><span style=\"color:Green;\">Use Windows.Security.Cryptography.Core.HashAlgorithmNames Class&lt;/param&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Green;\">Returns encrypted bytes.&lt;/returns&gt;</span>\n            <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">byte</span>[] Encrypt(<span style=\"color:Blue;\">byte</span>[] toEncrypt, <span style=\"color:Blue;\">string</span> key, <span style=\"color:Blue;\">string</span> algorithm, <span style=\"color:Blue;\">string</span> hashAlgorithm)\n            {\n                <span style=\"color:Green;\">// Get the MD5 key hash (you can as well use the binary of the key string)</span>\n                IBuffer keyHash = getHash(key, hashAlgorithm);\n                <span style=\"color:Green;\">// Create a buffer that contains the encoded message to be encrypted.</span>\n                IBuffer toDecryptBuffer = CryptographicBuffer.CreateFromByteArray(toEncrypt);\n                <span style=\"color:Green;\">// Open a symmetric algorithm provider for the specified algorithm.</span>\n                SymmetricKeyAlgorithmProvider provider = SymmetricKeyAlgorithmProvider.OpenAlgorithm(algorithm);\n                <span style=\"color:Green;\">// Create a symmetric key.</span>\n                CryptographicKey symetricKey = provider.CreateSymmetricKey(keyHash);\n                <span style=\"color:Green;\">// The input key must be securely shared between the sender of the cryptic message</span>\n                <span style=\"color:Green;\">// and the recipient. The initialization vector must also be shared but does not</span>\n                <span style=\"color:Green;\">// need to be shared in a secure manner. If the sender encodes a message string</span>\n                <span style=\"color:Green;\">// to a buffer, the binary encoding method must also be shared with the recipient.</span>\n                IBuffer buffEncrypted = CryptographicEngine.Encrypt(symetricKey, toDecryptBuffer, <span style=\"color:Blue;\">null</span>);\n                <span style=\"color:Green;\">// Convert the encrypted buffer to a string (for display).</span>\n                <span style=\"color:Green;\">// We are using Base64 to convert bytes to string since you might get unmatched characters</span>\n                <span style=\"color:Green;\">// in the encrypted buffer that we cannot convert to string with UTF8.</span>\n                <span style=\"color:Blue;\">byte</span>[] retVal;\n                CryptographicBuffer.CopyToByteArray(buffEncrypted, <span style=\"color:Blue;\">out</span> retVal);\n                <span style=\"color:Blue;\">return</span> retVal;\n            }\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n            <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> Encrypt a string using dual encryption method. Returns an encrypted text.</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;toEncrypt&quot;&gt;</span><span style=\"color:Green;\">String to be encrypted&lt;/param&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;key&quot;&gt;</span><span style=\"color:Green;\">Unique key for encryption/decryption&lt;/param&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;algorithm&quot;&gt;</span><span style=\"color:Green;\">Use Windows.Security.Cryptography.Core.SymmetricAlgorithmNames Class&lt;/param&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;hashAlgorithm&quot;&gt;</span><span style=\"color:Green;\">Use Windows.Security.Cryptography.Core.HashAlgorithmNames Class&lt;/param&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Green;\">Returns encrypted string.&lt;/returns&gt;</span>\n            <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">string</span> Encrypt(<span style=\"color:Blue;\">string</span> toEncrypt, <span style=\"color:Blue;\">string</span> key, <span style=\"color:Blue;\">string</span> algorithm, <span style=\"color:Blue;\">string</span> hashAlgorithm)\n            {\n                <span style=\"color:Green;\">// Get the MD5 key hash (you can as well use the binary of the key string)</span>\n                IBuffer keyHash = getHash(key, hashAlgorithm);\n                <span style=\"color:Green;\">// Create a buffer that contains the encoded message to be encrypted.</span>\n                IBuffer toDecryptBuffer = CryptographicBuffer.ConvertStringToBinary(toEncrypt, BinaryStringEncoding.Utf8);\n                <span style=\"color:Green;\">// Open a symmetric algorithm provider for the specified algorithm.</span>\n                SymmetricKeyAlgorithmProvider provider = SymmetricKeyAlgorithmProvider.OpenAlgorithm(algorithm);\n                <span style=\"color:Green;\">// Create a symmetric key.</span>\n                CryptographicKey symetricKey = provider.CreateSymmetricKey(keyHash);\n                <span style=\"color:Green;\">// The input key must be securely shared between the sender of the cryptic message</span>\n                <span style=\"color:Green;\">// and the recipient. The initialization vector must also be shared but does not</span>\n                <span style=\"color:Green;\">// need to be shared in a secure manner. If the sender encodes a message string</span>\n                <span style=\"color:Green;\">// to a buffer, the binary encoding method must also be shared with the recipient.</span>\n                IBuffer buffEncrypted = CryptographicEngine.Encrypt(symetricKey, toDecryptBuffer, <span style=\"color:Blue;\">null</span>);\n                <span style=\"color:Green;\">// Convert the encrypted buffer to a string (for display).</span>\n                <span style=\"color:Green;\">// We are using Base64 to convert bytes to string since you might get unmatched characters</span>\n                <span style=\"color:Green;\">// in the encrypted buffer that we cannot convert to string with UTF8.</span>\n                <span style=\"color:Blue;\">string</span> strEncrypted = CryptographicBuffer.EncodeToBase64String(buffEncrypted);\n                <span style=\"color:Blue;\">return</span> strEncrypted;\n            }\n\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n            <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> Decrypt a string using dual encryption method. Return a Decrypted clear string</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;cipherString&quot;&gt;</span><span style=\"color:Green;\">Encrypted string&lt;/param&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;key&quot;&gt;</span><span style=\"color:Green;\">Unique key for encryption/decryption&lt;/param&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Green;\">Returns decrypted text.&lt;/returns&gt;</span>\n            <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">string</span> Decrypt(<span style=\"color:Blue;\">string</span> cipherString, <span style=\"color:Blue;\">string</span> key, <span style=\"color:Blue;\">string</span> algorithm, <span style=\"color:Blue;\">string</span> hashAlgorithm)\n            {\n                <span style=\"color:Green;\">// Get the key hash (you can as well use the binary of the key string)</span>\n                IBuffer keyHash = getHash(key, hashAlgorithm);\n                <span style=\"color:Green;\">// Create a buffer that contains the encoded message to be decrypted.</span>\n                IBuffer toDecryptBuffer = CryptographicBuffer.DecodeFromBase64String(cipherString);\n                <span style=\"color:Green;\">// Open a symmetric algorithm provider for the specified algorithm.</span>\n                SymmetricKeyAlgorithmProvider provider = SymmetricKeyAlgorithmProvider.OpenAlgorithm(algorithm);\n                <span style=\"color:Green;\">// Create a symmetric key.</span>\n                CryptographicKey symetricKey = provider.CreateSymmetricKey(keyHash);\n                IBuffer buffDecrypted = CryptographicEngine.Decrypt(symetricKey, toDecryptBuffer, <span style=\"color:Blue;\">null</span>);\n                <span style=\"color:Blue;\">string</span> strDecrypted = CryptographicBuffer.ConvertBinaryToString(BinaryStringEncoding.Utf8, buffDecrypted);\n                <span style=\"color:Blue;\">return</span> strDecrypted;\n            }\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n            <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> </span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;cipherBytes&quot;&gt;</span><span style=\"color:Green;\">Encrypted string&lt;/param&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;key&quot;&gt;</span><span style=\"color:Gray;\">&lt;/param&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;algorithm&quot;&gt;</span><span style=\"color:Gray;\">&lt;/param&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;hashAlgorithm&quot;&gt;</span><span style=\"color:Gray;\">&lt;/param&gt;</span>\n            <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Gray;\">&lt;/returns&gt;</span>\n            <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">byte</span>[] Decrypt(<span style=\"color:Blue;\">byte</span>[] cipherBytes, <span style=\"color:Blue;\">string</span> key, <span style=\"color:Blue;\">string</span> algorithm, <span style=\"color:Blue;\">string</span> hashAlgorithm)\n            {\n                <span style=\"color:Green;\">// Get the key hash (you can as well use the binary of the key string)</span>\n                IBuffer keyHash = getHash(key, hashAlgorithm);\n                <span style=\"color:Green;\">// Create a buffer that contains the encoded message to be decrypted.</span>\n                IBuffer toDecryptBuffer = CryptographicBuffer.CreateFromByteArray(cipherBytes);\n                <span style=\"color:Green;\">// Open a symmetric algorithm provider for the specified algorithm.</span>\n                SymmetricKeyAlgorithmProvider provider = SymmetricKeyAlgorithmProvider.OpenAlgorithm(algorithm);\n                <span style=\"color:Green;\">// Create a symmetric key.</span>\n                CryptographicKey symetricKey = provider.CreateSymmetricKey(keyHash);\n                IBuffer buffDecrypted = CryptographicEngine.Decrypt(symetricKey, toDecryptBuffer, <span style=\"color:Blue;\">null</span>);\n                <span style=\"color:Blue;\">byte</span>[] retVal;\n                CryptographicBuffer.CopyToByteArray(buffDecrypted, <span style=\"color:Blue;\">out</span> retVal);\n                <span style=\"color:Blue;\">return</span> retVal;\n            }\n        }\n\n        <span style=\"color:Blue;\">#region</span> Descriptors\n        <span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">const</span> <span style=\"color:Blue;\">string</span> _LOCAL = <span style=\"color:#A31515;\">&quot;LOCAL&quot;</span>;\n        <span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">const</span> <span style=\"color:Blue;\">string</span> _WEBCREDENTIALS = <span style=\"color:#A31515;\">&quot;WEBCREDENTIALS&quot;</span>;\n\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">string</span> UserDescriptor { <span style=\"color:Blue;\">get</span> { <span style=\"color:Blue;\">return</span> _LOCAL + <span style=\"color:#A31515;\">&quot;=user&quot;</span>; } }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">string</span> MachineDescriptor { <span style=\"color:Blue;\">get</span> { <span style=\"color:Blue;\">return</span> _LOCAL + <span style=\"color:#A31515;\">&quot;=machine&quot;</span>; } }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">string</span> WebCredentialsDescriptor(<span style=\"color:Blue;\">string</span> password, <span style=\"color:Blue;\">string</span> url) { <span style=\"color:Blue;\">return</span> _WEBCREDENTIALS + <span style=\"color:#A31515;\">&quot;=&quot;</span> + password + <span style=\"color:#A31515;\">&quot;,&quot;</span> + url; }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">string</span> WebCredentialsDescriptor(<span style=\"color:Blue;\">string</span> password) { <span style=\"color:Blue;\">return</span> WebCredentialsDescriptor(password, <span style=\"color:Blue;\">string</span>.Empty); }\n        <span style=\"color:Blue;\">#endregion</span>\n        <span style=\"color:Blue;\">#region</span> Example\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> async <span style=\"color:Blue;\">void</span> ProtectExample()\n        {\n            <span style=\"color:Green;\">// Initialize function arguments.</span>\n            String strMsg = <span style=\"color:#A31515;\">&quot;This is a message to be protected.&quot;</span>;\n            String strDescriptor = <span style=\"color:#A31515;\">&quot;LOCAL=user&quot;</span>;\n            BinaryStringEncoding encoding = BinaryStringEncoding.Utf8;\n            <span style=\"color:Green;\">// Protect a message to the local user.</span>\n            IBuffer buffProtected = await SampleProtectAsync(strMsg, strDescriptor, encoding);\n            <span style=\"color:Green;\">// Decrypt the previously protected message.</span>\n            String strDecrypted = await SampleUnprotectData(buffProtected, encoding);\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> async Task&lt;IBuffer&gt; SampleProtectAsync(String strMsg, String strDescriptor, BinaryStringEncoding encoding)\n        {\n            <span style=\"color:Green;\">// Create a DataProtectionProvider object for the specified descriptor.</span>\n            DataProtectionProvider Provider = <span style=\"color:Blue;\">new</span> DataProtectionProvider(strDescriptor);\n            <span style=\"color:Green;\">// Encode the plaintext input message to a buffer.</span>\n            encoding = BinaryStringEncoding.Utf8;\n            IBuffer buffMsg = CryptographicBuffer.ConvertStringToBinary(strMsg, encoding);\n            <span style=\"color:Green;\">// Encrypt the message.</span>\n            IBuffer buffProtected = await Provider.ProtectAsync(buffMsg);\n            <span style=\"color:Green;\">// Execution of the SampleProtectAsync function resumes here</span>\n            <span style=\"color:Green;\">// after the awaited task (Provider.ProtectAsync) completes.</span>\n            <span style=\"color:Blue;\">return</span> buffProtected;\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> async Task&lt;String&gt; SampleUnprotectData(IBuffer buffProtected, BinaryStringEncoding encoding)\n        {\n            <span style=\"color:Green;\">// Create a DataProtectionProvider object.</span>\n            DataProtectionProvider Provider = <span style=\"color:Blue;\">new</span> DataProtectionProvider();\n            <span style=\"color:Green;\">// Decrypt the protected message specified on input.</span>\n            IBuffer buffUnprotected = await Provider.UnprotectAsync(buffProtected);\n            <span style=\"color:Green;\">// Execution of the SampleUnprotectData method resumes here</span>\n            <span style=\"color:Green;\">// after the awaited task (Provider.UnprotectAsync) completes</span>\n            <span style=\"color:Green;\">// Convert the unprotected message from an IBuffer object to a string.</span>\n            String strClearText = CryptographicBuffer.ConvertBinaryToString(encoding, buffUnprotected);\n            <span style=\"color:Green;\">// Return the plaintext string.</span>\n            <span style=\"color:Blue;\">return</span> strClearText;\n        }\n        <span style=\"color:Blue;\">#endregion</span>\n        <span style=\"color:Blue;\">#region</span> IBuffer\n        <span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">string</span> iBufferToString(IBuffer buff)\n        {\n            <span style=\"color:Green;\">//BinaryStringEncoding encoding = BinaryStringEncoding.Utf16BE;</span>\n            <span style=\"color:Green;\">//return CryptographicBuffer.ConvertBinaryToString(encoding, buff);</span>\n            <span style=\"color:Blue;\">return</span> CryptographicBuffer.EncodeToHexString(buff);\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">string</span> IBufferToString(<span style=\"color:Blue;\">this</span> IBuffer buff)\n        {\n            <span style=\"color:Blue;\">return</span> iBufferToString(buff);\n        }\n\n        <span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">static</span> IBuffer StringToIBuffer(<span style=\"color:Blue;\">string</span> str)\n        {\n            <span style=\"color:Green;\">//BinaryStringEncoding encoding = BinaryStringEncoding.Utf16LE;</span>\n            <span style=\"color:Green;\">//return CryptographicBuffer.ConvertStringToBinary(str, encoding);</span>\n            <span style=\"color:Blue;\">return</span> CryptographicBuffer.DecodeFromHexString(str);\n        }\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> IBuffer ToIBuffer(<span style=\"color:Blue;\">this</span> <span style=\"color:Blue;\">string</span> str)\n        {\n            <span style=\"color:Blue;\">return</span> StringToIBuffer(str);\n        }\n        <span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">static</span> IBuffer getHash(<span style=\"color:Blue;\">string</span> key, <span style=\"color:Blue;\">string</span> hashAlgo)\n        {\n            <span style=\"color:Green;\">// Convert the message string to binary data.</span>\n            IBuffer buffUtf8Msg = CryptographicBuffer.ConvertStringToBinary(key, BinaryStringEncoding.Utf8);\n            <span style=\"color:Green;\">// Create a HashAlgorithmProvider object.</span>\n            HashAlgorithmProvider objAlgProv = HashAlgorithmProvider.OpenAlgorithm(hashAlgo);\n            <span style=\"color:Green;\">// Hash the message.</span>\n            IBuffer buffHash = objAlgProv.HashData(buffUtf8Msg);\n            <span style=\"color:Green;\">// Verify that the hash length equals the length specified for the algorithm.</span>\n            <span style=\"color:Blue;\">if</span> (buffHash.Length != objAlgProv.HashLength)\n                <span style=\"color:Blue;\">throw</span> <span style=\"color:Blue;\">new</span> Exception(<span style=\"color:#A31515;\">&quot;There was an error creating the hash&quot;</span>);\n\n            <span style=\"color:Blue;\">return</span> buffHash;\n        }\n        <span style=\"color:Blue;\">#endregion</span>\n    }\n}\r\n</pre></div><h2>Analitics</h2>\rThere are good 2D calculation methods are implemented in the framework<br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">using</span> System;\n<span style=\"color:Blue;\">using</span> System.Collections.Generic;\n<span style=\"color:Blue;\">using</span> Windows.Foundation;\n<span style=\"color:Blue;\">using</span> Windows.UI.Xaml.Shapes;\n\n<span style=\"color:Blue;\">namespace</span> WinRTBase\n{\n    <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">sealed</span> <span style=\"color:Blue;\">class</span> Analitics\n    {\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> returns whether a point is on the line</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;l&quot;&gt;</span><span style=\"color:Green;\">the line&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;p&quot;&gt;</span><span style=\"color:Green;\">the point&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Gray;\">&lt;/returns&gt;</span>\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">bool</span> IsPointOnTheLine(Line l, Point p, <span style=\"color:Blue;\">int</span> precision)\n        {\n            <span style=\"color:Blue;\">return</span> Math.Round(Math.Round(l.X2 - l.X1, precision) / Math.Round(l.Y2 - l.Y1, precision), precision) == Math.Round(Math.Round(l.X2 - p.X, precision) / Math.Round(l.Y2 - p.Y, precision), precision)\n                    &amp;&amp;\n                   (l.X2 &gt;= p.X &amp;&amp; p.X &gt;= l.X1 || l.X1 &gt;= p.X &amp;&amp; p.X &gt;= l.X2)\n                    &amp;&amp;\n                   (l.Y2 &gt;= p.Y &amp;&amp; p.Y &gt;= l.Y1 || l.Y1 &gt;= p.Y &amp;&amp; p.Y &gt;= l.Y2);\n        }\n\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> Returns wether 2 lines are collided and the collision point</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;l1&quot;&gt;</span><span style=\"color:Green;\">Line 1&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;l2&quot;&gt;</span><span style=\"color:Green;\">Line 2&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;useBoundaries&quot;&gt;</span><span style=\"color:Green;\">use Lines as Line Segments&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Green;\">Point of collision&lt;/returns&gt;</span>\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> Nullable&lt;Point&gt; IntersectionPoint(Line l1, Line l2, <span style=\"color:Blue;\">bool</span> useBoundaries)\n        {\n            <span style=\"color:Blue;\">double</span>[] x = <span style=\"color:Blue;\">new</span> <span style=\"color:Blue;\">double</span>[6];\n            <span style=\"color:Blue;\">double</span>[] y = <span style=\"color:Blue;\">new</span> <span style=\"color:Blue;\">double</span>[6];\n            <span style=\"color:Blue;\">double</span>[] m = <span style=\"color:Blue;\">new</span> <span style=\"color:Blue;\">double</span>[3];\n\n            x[1] = l1.X1; x[2] = l1.X2; x[4] = l2.X1; x[5] = l2.X2;\n            y[1] = l1.Y1; y[2] = l1.Y2; y[4] = l2.Y1; y[5] = l2.Y2;\n\n\n            <span style=\"color:Blue;\">if</span> ((x[2] != x[1]) &amp;&amp; (x[5] != x[4]))\n            {\n                m[1] = (y[2] - y[1]) / (x[2] - x[1]);\n                m[2] = (y[5] - y[4]) / (x[5] - x[4]);\n                x[3] = (x[1] * m[1] - y[1] - x[4] * m[2] + y[4]) / (m[1] - m[2]);\n                y[3] = (x[3] - x[1]) * m[1] + y[1];\n            }\n            <span style=\"color:Blue;\">else</span> <span style=\"color:Blue;\">if</span> (x[1] == x[2] &amp;&amp; x[5] != x[4])\n            {\n                m[2] = (y[5] - y[4]) / (x[5] - x[4]);\n                x[3] = x[1];\n                y[3] = (x[3] - x[4]) * m[2] + y[4];\n            }\n            <span style=\"color:Blue;\">else</span> <span style=\"color:Blue;\">if</span> (x[1] != x[2] &amp;&amp; x[5] == x[4])\n            {\n                m[1] = (y[2] - y[1]) / (x[2] - x[1]);\n                x[3] = x[5];\n                y[3] = (x[3] - x[1]) * m[1] + y[1];\n            }\n            <span style=\"color:Blue;\">else</span>\n                <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">null</span>;\n\n            Point ip = <span style=\"color:Blue;\">new</span> Point(x[3], y[3]);\n\n            <span style=\"color:Blue;\">if</span> (!useBoundaries)\n                <span style=\"color:Blue;\">return</span> ip;\n            <span style=\"color:Blue;\">else</span> <span style=\"color:Blue;\">if</span> (IsPointOnTheLine(l1, ip, 1) &amp;&amp; IsPointOnTheLine(l2, ip, 1))\n                <span style=\"color:Blue;\">return</span> ip;\n            <span style=\"color:Blue;\">else</span>\n                <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">null</span>;\n        }\n\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> returns a intersection point of direction and Line segment</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;startPoint&quot;&gt;</span><span style=\"color:Green;\">direction start point&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;l&quot;&gt;</span><span style=\"color:Green;\">Line&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;dx&quot;&gt;</span><span style=\"color:Green;\">delta X&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;dy&quot;&gt;</span><span style=\"color:Green;\">delta Y&lt;/param&gt;        </span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Gray;\">&lt;/returns&gt;</span>\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> Nullable&lt;Point&gt; IntersectionPoint(Point startPoint, Line l, <span style=\"color:Blue;\">double</span> dx, <span style=\"color:Blue;\">double</span> dy)\n        {\n            Point? ip;\n\n            Line l1 = <span style=\"color:Blue;\">new</span> Line();\n            l1.X1 = startPoint.X;\n            l1.Y1 = startPoint.Y;\n            l1.X2 = l1.X1 + dx;\n            l1.Y2 = l1.Y1 + dy;\n\n            ip = IntersectionPoint(l, l1, <span style=\"color:Blue;\">false</span>);\n\n            <span style=\"color:Blue;\">if</span> (!ip.HasValue) <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">null</span>;\n\n            Line l2 = <span style=\"color:Blue;\">new</span> Line();\n            l2.X1 = startPoint.X;\n            l2.Y1 = startPoint.Y;\n            l2.X2 = ip.Value.X;\n            l2.Y2 = ip.Value.Y;\n\n            <span style=\"color:Blue;\">if</span> (IsPointOnTheLine(l2, <span style=\"color:Blue;\">new</span> Point(l1.X2, l1.Y2), 1))\n                <span style=\"color:Blue;\">return</span> ip;\n            <span style=\"color:Blue;\">else</span>\n                <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">null</span>;\n        }\n\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> distance between two points</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;p1&quot;&gt;</span><span style=\"color:Gray;\">&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;p2&quot;&gt;</span><span style=\"color:Gray;\">&lt;/param&gt;</span>\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">double</span> Distance(Point p1, Point p2)\n        {\n            <span style=\"color:Blue;\">return</span> Math.Sqrt(Math.Pow(p2.Y - p1.Y, 2) + Math.Pow(p2.X - p1.X, 2));\n        }\n\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> Converts a rectangle to 4 lines TOP, RIGHT,BOTTOM, LEFT line</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Green;\">lines of rect&lt;/returns&gt;</span>\n        <span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">static</span> Line[] RectangleLines(Rect r)\n        {\n            <span style=\"color:Green;\">//List&lt;Line&gt; retVal = new List&lt;Line&gt;(4);</span>\n            Line[] retVal = <span style=\"color:Blue;\">new</span> Line[4];\n\n            Line Line1 = <span style=\"color:Blue;\">new</span> Line();\n            Line1.X1 = r.Left; Line1.Y1 = r.Top; Line1.X2 = r.Right; Line1.Y2 = r.Top;\n\n            Line Line2 = <span style=\"color:Blue;\">new</span> Line();\n            Line2.X1 = r.Right; Line2.Y1 = r.Top; Line2.X2 = r.Right; Line2.Y2 = r.Bottom;\n\n            Line Line3 = <span style=\"color:Blue;\">new</span> Line();\n            Line3.X1 = r.Right; Line3.Y1 = r.Bottom; Line3.X2 = r.Left; Line3.Y2 = r.Bottom;\n\n            Line Line4 = <span style=\"color:Blue;\">new</span> Line();\n            Line4.X1 = r.Left; Line4.Y1 = r.Bottom; Line4.X2 = r.Left; Line4.Y2 = r.Top;\n\n            retVal[0] = Line1;\n            retVal[1] = Line2;\n            retVal[2] = Line3;\n            retVal[3] = Line4;\n\n            <span style=\"color:Blue;\">return</span> retVal;\n        }\n\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> Returns the Intersection points of Line and Rectangle</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;l&quot;&gt;</span><span style=\"color:Green;\">Line&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;r&quot;&gt;</span><span style=\"color:Green;\">Rectangle&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Green;\">Intersection Points&lt;/returns&gt;</span>\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> List&lt;Point&gt; IntersectionPoints(Line l, Rect r)\n        {\n            List&lt;Point&gt; retVal = <span style=\"color:Blue;\">new</span> List&lt;Point&gt;();\n\n            Line[] rectLines = RectangleLines(r);\n\n            <span style=\"color:Blue;\">foreach</span> (Line rl <span style=\"color:Blue;\">in</span> rectLines)\n            {\n                Point? i = IntersectionPoint(rl, l, <span style=\"color:Blue;\">true</span>);\n                <span style=\"color:Blue;\">if</span> (i.HasValue)\n                    retVal.Add(i.Value);\n            }\n\n            <span style=\"color:Blue;\">return</span> retVal;\n        }\n\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">bool</span> IsIntersected(Line l, Rect r)\n        {\n            Line[] rectLines = RectangleLines(r);\n\n            <span style=\"color:Blue;\">foreach</span> (Line rl <span style=\"color:Blue;\">in</span> rectLines)\n            {\n                Point? i = IntersectionPoint(rl, l, <span style=\"color:Blue;\">true</span>);\n                <span style=\"color:Blue;\">if</span> (i.HasValue)\n                    <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">true</span>;\n            }\n\n            <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">false</span>;\n        }\n\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> Returns the Intersection points of many rectangles</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;R&quot;&gt;</span><span style=\"color:Green;\">List Of rectange to be checked&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Green;\">Intersection Points&lt;/returns&gt;</span>\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> List&lt;Point&gt; IntersectionPoints(List&lt;Rect&gt; R)\n        {\n            List&lt;Point&gt; retVal = <span style=\"color:Blue;\">new</span> List&lt;Point&gt;();\n\n            <span style=\"color:Blue;\">foreach</span> (Rect r <span style=\"color:Blue;\">in</span> R)\n                <span style=\"color:Blue;\">foreach</span> (Rect r1 <span style=\"color:Blue;\">in</span> R)\n                    <span style=\"color:Blue;\">if</span> (r1 != r)\n                        retVal.AddRange(IntersectionPoints(r, r1));\n            <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">null</span>;\n        }\n\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> Returns the Intersection points of Rectangle and Rectangle</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;r1&quot;&gt;</span><span style=\"color:Green;\">First Rectangle&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;param name=&quot;r2&quot;&gt;</span><span style=\"color:Green;\">Second Rectangle&lt;/param&gt;</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;returns&gt;</span><span style=\"color:Green;\">Intersection Points&lt;/returns&gt;</span>\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> List&lt;Point&gt; IntersectionPoints(Rect r1, Rect r2)\n        {\n            List&lt;Point&gt; retVal = <span style=\"color:Blue;\">new</span> List&lt;Point&gt;();\n            <span style=\"color:Blue;\">foreach</span> (Line r1l <span style=\"color:Blue;\">in</span> RectangleLines(r1))\n                retVal.AddRange(IntersectionPoints(r1l, r2));\n\n            <span style=\"color:Blue;\">return</span> retVal;\n        }\n    }\n}\r\n</pre></div>Also there is a Geographic distance calculator in this framework.<br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">using</span> System;\n\n<span style=\"color:Blue;\">namespace</span> WinRTBase\n{\n    <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">class</span> GeoMath\n    {\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> The distance type to return the results in.</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">enum</span> MeasureUnits { Miles, Kilometers };\n\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> Returns the distance in miles or kilometers of any two</span>\n        <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> latitude / longitude points. (Haversine formula)</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span>\n        <span style=\"color:Blue;\">public</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">double</span> Distance(<span style=\"color:Blue;\">double</span> latitudeA, <span style=\"color:Blue;\">double</span> longitudeA, <span style=\"color:Blue;\">double</span> latitudeB, <span style=\"color:Blue;\">double</span> longitudeB, MeasureUnits units)\n        {\n            <span style=\"color:Blue;\">if</span> (latitudeA &lt;= -90 || latitudeA &gt;= 90 || longitudeA &lt;= -180 || longitudeA &gt;= 180\n                || latitudeB &lt;= -90 &amp;&amp; latitudeB &gt;= 90 || longitudeB &lt;= -180 || longitudeB &gt;= 180)\n            {\n                <span style=\"color:Blue;\">throw</span> <span style=\"color:Blue;\">new</span> ArgumentException(String.Format(<span style=\"color:#A31515;\">&quot;Invalid value point coordinates. Points A({0},{1}) B({2},{3}) &quot;</span>,\n                                                          latitudeA,\n                                                          longitudeA,\n                                                          latitudeB,\n                                                          longitudeB));\n            }\n\n            <span style=\"color:Blue;\">double</span> R = (units == MeasureUnits.Miles) ? 3960 : 6371;\n            <span style=\"color:Blue;\">double</span> dLat = toRadian(latitudeB - latitudeA);\n            <span style=\"color:Blue;\">double</span> dLon = toRadian(longitudeB - longitudeA);\n            <span style=\"color:Blue;\">double</span> a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +\n            Math.Cos(toRadian(latitudeA)) * Math.Cos(toRadian(latitudeB)) *\n            Math.Sin(dLon / 2) * Math.Sin(dLon / 2);\n            <span style=\"color:Blue;\">double</span> c = 2 * Math.Asin(Math.Min(1, Math.Sqrt(a)));\n            <span style=\"color:Blue;\">double</span> d = R * c;\n            <span style=\"color:Blue;\">return</span> d;\n        }\n\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;summary&gt;</span>\n        <span style=\"color:Gray;\">///</span><span style=\"color:Green;\"> Convert to Radians.</span>\n        <span style=\"color:Gray;\">///</span> <span style=\"color:Gray;\">&lt;/summary&gt;</span><span style=\"color:Green;\">      </span>\n        <span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">static</span> <span style=\"color:Blue;\">double</span> toRadian(<span style=\"color:Blue;\">double</span> val) { <span style=\"color:Blue;\">return</span> (Math.PI / 180) * val; }\n    }\n}\r\n</pre></div>\n<h2>follow me on twitter: <a href=\"http://twitter.com/oguzkoroglu\">twitter.com/oguzkoroglu</a></h2>\r<h2>my linked in profile : <a href=\"http://tr.linkedin.com/in/oguzkoroglu/\">http://tr.linkedin.com/in/oguzkoroglu/</a></h2>\r<h2>my personal web site : <a href=\"http://oguzkoroglu.net/\">http://oguzkoroglu.net/</a></h2></div><div class=\"ClearBoth\"></div>",
  "TagList": "winrt,windows phone,c#,WPF,windows 8,windows runtime,",
  "LastEdited": "2014-04-18T12:49:57.907-07:00"
}