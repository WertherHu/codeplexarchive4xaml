{
  "ProjectName": "WirelessRoutingDemo",
  "Title": "Wireless Routing using Dijkstra's Shortest Path Algorithm",
  "Description": "Explains Dijkstra's shortest path algorithm, for wireless network routing. The users can create a random map with dynamic transmission range  and choose a source and destination mobile node (by clicking) in the map and see the shortest path visually in the Silverlight output.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><h2>Summary</h2>\r\nExplains Dijkstra&#39;s shortest path algorithm, for wireless network routing. The users can create a random map with dynamic transmission range and choose a source and destination mobile node (by clicking) in the map and see the shortest path visually in the Silverlight output.<br />\n<h2>Silverlight Screenshot</h2>\r\n<img src=\"/projects/WirelessRoutingDemo/fb8dfb0c-06c4-427a-aeba-e46312fa901c\" alt=\"Routing-Demo-1.JPG\" title=\"Routing-Demo-1.JPG\" /><br /><br />For more explanation of how this algorithm is implemented in C# and Silverlight, and to see the live usable demo, visit: <a href=\"http://www.codeding.com/articles/dijkstras-path-finding\">http://www.codeding.com/articles/dijkstras-path-finding</a><br />\n<h2>Source Code</h2>\r\nThe <i>Node</i> class represents a mobile node. The <i>Map</i> class represents a set of nodes (wireless network).<br /><br /><pre>\npublic class Node\n{\n    public int Id { get; set; }\n    public double X { get; set; }\n    public double Y { get; set; }\n}\n\npublic class Map\n{\n    public List&lt;Node&gt; Nodes { get; set; }\n}\n</pre><br /><br />The following code implements the shortest path algorithm for a wireless network (un-directed and un-connected graph), using the transmission range. The data-structures used in this code are defined above.<br /><br /><pre>\npublic static List&lt;Node&gt; FindShortestPath(Map map, Node sourceNode, Node destinationNode, double transmissionRange)\n{\n    List&lt;Node&gt; path = new List&lt;Node&gt;();\n    path.Add(sourceNode);\n\t\n    Node currentNode = sourceNode;\n    while (true)\n    {\n        //get all neighbors of current-node (nodes within transmission range)\n        List&lt;Node&gt; allNeighbors = map.GetNeighbors(currentNode, transmissionRange);\n\t\t\n        //remove neighbors that are already added to path\n        IEnumerable&lt;Node&gt; neighbors = from neighbor in allNeighbors\n                                      where !path.Contains(neighbor)\n                                      select neighbor;\n\t\t\n        //stop if no neighbors or destination reached\n        if (neighbors.Count() == 0) break;\n        if (neighbors.Contains(destinationNode))\n        {\n            path.Add(destinationNode);\n            break;\n        }\n\t\t\n        //choose next-node (the neighbor with shortest distance to destination)\n        Node nearestNode = FindNearestNode(neighbors, destinationNode);\n        path.Add(nearestNode);\n        currentNode = nearestNode;\n    }\n\t\n    return (path);\n}\n</pre><br /></div><div class=\"ClearBoth\"></div>",
  "TagList": "",
  "LastEdited": "2012-09-26T06:23:34.35-07:00"
}