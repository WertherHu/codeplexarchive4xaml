{
  "ProjectName": "visualtagcloud",
  "Title": "Visual Tag Cloud",
  "Description": "The TagCloud Silverlight application allows a user to see a visual representation of an RSS feed. It shows a visualization of the labels used within a feed, using size to indicate frequency and closeness to other tags showing frequency of co-occurrence",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><img src=\"http://3.bp.blogspot.com/_DEP-Cchblg0/SWI4qgJ4FFI/AAAAAAAAAGE/7MkIYczSNJg/s400/tagcloud1.3.JPG\" /><br /><b>Overview</b><br />The TagCloud Silverlight application allows a user to see a visual representation of an RSS feed. It shows a visualization of the labels used within a feed, using size to indicate frequency and closeness to other tags showing frequency of co-occurrence.<br />This means that tags that occur often together (for example “Silverlight” and “Xaml”) will tend to appear next to each other, whilst tags that don’t occur together in the feed (for example “Silverlight” and “Credit Crunch”) will tend to be far apart.<br />Colour is also used to group the tag cloud, with the most frequently occurring tags taking a colour, and co-occurring tags inheriting that colour. This visually groups the cloud by colour as well.<br />Mouse-Over a tag shows lines to all other tags that it has occurred with, and clicking presents a popup menu of posts that mention that tag. Clicking on an item in the menu navigates to that post. <br />You can also click and drag a tag for fun, and watch all the other tags chase it..<br /><br /><b>Model</b><br />•\tCloud: the model of a RSS feed, separating the model from the UI. Processes an RSS feed and create subordinate Post and Tag with relationships. The cloud class is more of a management class that delegates most of the work to the Tag class.<br />•\tPost: very simple class that represents a post/entry in an RSS feed. Used to allow navigation back to a particular post.<br />•\tTag:  represents a tag (label/syndicationItem) in an RSS feed. Holds frequency count of how many times it has co-occurred with other tags. Has a SeekHarmony function that does the majority of the application “ah!” factor.<br /><br /><b>Approach</b><br />The application builds an internal model of the RSS feeds, critically in terms of tags and their co-occurrences. It then follows a simulation approach, where it tries to position each tag such that it is near tags it has co-occurred with, and far from tags it has not.<br />The algorithm for doing this does not pay attention to the overall cloud shape, but acts as an emergent system – the application of the simple harmony seeking behaviour between tags creating a global balance (generally a circle)<br /><br /><b>Code structure</b><br />Four parts<br />•\tJavaScript library to make embedding the application less error prone<br />•\tA server based proxy for getting RSS feeds to avoid cross domain issues<br />•\tA silverlight library for math functions (mostly polar calculations and some extension methiods)<br />•\tTagCloud silverlight application, with App and Page classes and three supporting classes (Cloud, Post and Tag)<br /><br /><b>Lifecycle</b><br />The silverlight application is embedded in a HTML page which passes a number of parameters via JavaScript to the Silverlight object creation code. The Silverlight application reads these settings and downloads the RSS feed via a server side proxy (to avoid cross-domain issues). The code then build an internal model of the RSS feed, with co-occurrence information about tags. On a timer basis the code then moves each tag such that it is nearer tags it co-occurred with, and further from ones it has not occurred with. Over time an order emerges which shows how the tags relate – tags that are nearer co-occur more.<br /><br /><b>Embedding the control in the page</b><br />For my blog I use JavaScript to embed the silverlight control<br /> &lt;div id=&#39;feCloud&#39; style=&#39;text-align: center;&#39;/&gt;  <br /> &lt;script src=&#39;http://www.figmentengine.com/tagCloud/feCloudv1.3.js&#39; type=&#39;text/javascript&#39;/&gt;  <br /> &lt;script type=&#39;text/javascript&#39;&gt;  <br />  var feCloudElementId = &#39;feCloud&#39;;  <br />  var feCloudFeedAddress = &#39;http://feedproxy.google.com/FigmentEngine&#39;;  <br />  var feCloudNavigateFormat = &#39;http://blog.figmentengine.com/search/label/{0}&#39;;  <br />  var feCloudSize = 400;  <br />  feTagCloudLoad(feCloudElementId, feCloudFeedAddress, feCloudNavigateFormat, feCloudSize, feCloudSize);  <br /> &lt;/script&gt; <br /><br />The function in the feCloudv1.3.js is a wrapper for the Silverlight.js createObject call:<br />function feTagCloudLoad(elementId, feed, navigateFormat, width, height)<br />{<br />  var params = &quot;&quot;;<br /><br />  if (feed != null)<br />    params += &quot;feedAddress=&quot; + feed + &quot;, &quot;;<br />  if (navigateFormat != null)<br />    params += &quot;navigateFormat=&quot; + navigateFormat + &quot;, &quot;;<br /><br />  var slWidth = 350;<br />  if (width)<br />   slWidth = width;<br />  params += &quot;width=&quot; + slWidth + &quot;, &quot;; <br /><br />  var slHeight = 350;<br />  if (height)<br />   slHeight = height;<br /><br />  var container = document.getElementById(elementId);<br />  var cloudControl = document.createElement(&#39;object&#39;);<br />  <br />  cloudControl.setAttribute(&#39;data&#39;, &#39;data:application/x-silverlight-2,&#39;);<br />  cloudControl.setAttribute(&#39;type&#39;, &#39;application/x-silverlight-2&#39;);<br />  cloudControl.setAttribute(&#39;id&#39;, &#39;feCloudControl&#39;);<br />  container.appendChild(cloudControl);<br /><br />  var host = &quot;http://www.figmentengine.com/&quot;;<br />  var source = host + &quot;tagCloud/TagCloudV1.2.xap&quot;;<br />  var parentElement = container;<br />  var callbackId = &quot;feCloud&quot;;<br />  var properties = { width: slWidth, height: slHeight, version: &quot;2.0.31005.0&quot;, enableHtmlAccess: &quot;true&quot; };<br />  var events = { };<br />  var initParams = params;<br />  Silverlight.createObject(source, parentElement,<br />   callbackId, properties, events, initParams);<br />}<br />I’ve put in bold the section that deals with passing the feed information via initParams. I also set enabledHtmlAccess to allow the Silverlight code to navigate the browser using HtmlPage.Window.Navigate.<br /><br /><b>Application startup</b><br />Reads the settings specified in the embedding JavaScript, most importantly the address of the RSS feed and how to navigate to page. It creates an instance of the Page and asks it to populate the TagCloud based on the feed address information. <br /><br /><b>Populating the cloud</b><br />Obtain the RSS feed: Due to issues in making requests to websites that the silverlight does not originate from I use the technique outlined at Franksworld (when your silverlight app needs to get data from another server that does not contain a crossdomain.xml then it proxies the call via the server)<br />•\thttp://franksworld.com/blog/archive/2008/04/15/10903.aspx<br />    protected void Page_Load(object sender, EventArgs e)<br />    {<br />        // Load the URI from the Query String<br />        string sourceUriString = Request.QueryString[&quot;Uri&quot;];<br /><br />        try<br />        {<br />            // Clear the output buffer<br />            Response.Clear();<br /><br />            // Make new WebClient <br />            WebClient webClientRequest = new WebClient();<br /><br />            // Download data from URI<br />            byte[] requestByteArray = webClientRequest.DownloadData(sourceUriString);<br /><br />            // Match the Mime Types<br />            string contentType = webClientRequest.ResponseHeaders[&quot;Content-type&quot;].ToString();<br />            Response.ContentType = contentType;<br /><br />            // Copy the Streams<br />            int requestByteArrayLength = requestByteArray.GetLength(0);<br />            Response.OutputStream.Write(requestByteArray, 0, requestByteArrayLength);<br />            Response.OutputStream.Close();<br /><br />            // Exit the Page<br />            // see http://support.microsoft.com/kb/312629<br />            //Response.End();<br />            HttpContext.Current.ApplicationInstance.CompleteRequest();<br /><br />        }<br />        catch(Exception ex)<br />        {<br />            // 5xx errors mean server error<br />            Response.StatusCode = 501;<br />            Response.StatusDescription = &quot;Error encountered. Details: &quot; + ex.Message;<br />        }<br />    }<br />Conversion of the RSS into the internal object model ignores most of the information in the feed, concentrating on posts, tags and co-occurrence.<br /><br /><b>Initializing the UI</b><br />At start-up the code creates a pool of connecter lines (to reduce the need to create them dynamically). It also create TextBlocks to represent each tag. It then start the timer to repeatedly move the tags around (seeking harmony)<br /><br /><b>Seeking Harmony</b><br />The code only works at a tag level, relying on emergent behaviour to get the UI effect. For each tag we do the following:<br />•\tEach tag calculates how near it should be to all the other tags based on frequency of co-occurrence.<br />•\tIt then uses a polar conversion to work out the vector it would need to move in to get to this position.<br />•\tWe add up all these vectors for the tag, which gives us a vector that if it applied would be the ideal location for it.<br />•\tWe then down-scale the vector:<br />1.\tSo tags don’t jump massive distances<br />2.\tTags can react to where all the other tags have moved to on the next cycle<br /><br /></div><div class=\"ClearBoth\"></div>",
  "TagList": "tagging,tag cloud,Silverlight,visualization,RSS,",
  "LastEdited": "2009-09-17T11:47:30.097-07:00"
}