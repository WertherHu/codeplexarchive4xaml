{
  "ProjectName": "ValidationToolkit",
  "Title": "Validation Toolkit for WPF & Silverlight",
  "Description": "Validation Toolkit for WPF & Silverlight displays automatically validation errors coming from both Data Annotations on the View Model and   Asynchronous calls to Web Services. The View Model  is wrapped into an object that supplies  all needed interface implementations.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\">\r\n<p><strong>Project Description</strong><br>\r\nValidation Toolkit for WPF &amp; Silverlight displays automatically validation errors coming from both Data Annotations on the View Model and Asynchronous calls to Web Services. The View Model is wrapped into an object that supplies all needed interface implementations.<br>\r\n<br>\r\n<br>\r\n<strong>Main object of the project</strong></p>\r\n<p>Enabling programmers to keep the plumbing logic needed to propagate validation errors to the User Interface as separate as possible from the Business logic, and to reduce as much as possible the code needed to perform data validation. We have chosen to use\r\n Data Annotations as the main source of validation errors because they rely on a declarative model and keep the validation code completely separated from the business logics. Another source of validation errors we allows is Validation Exceptions coming from\r\n web services once the request is submitted to the server, Web services may produce such Validation Exceptions either through data annotations in other business classes or through the interaction with data sources.</p>\r\n<p><strong>You can find documentation <a title=\"documentation\" href=\"documentation\">\r\nhere</a>, a description of the examples included in the distribution <a href=\"/wikipage?title=Examples%20explanation\">\r\nhere</a>,&nbsp;and tutorials in the <a href=\"http://www.dotnet-programming.com/post/2010/09/04/Data-Validation-1.aspx\">\r\nData Validation Series of posts in my blog</a>, and about Silverlight/Server communication(<a href=\"http://www.dotnet-programming.com/post/2010/10/21/e280a6Something-More-about-Ria-Services.aspx\">here</a>&nbsp;and\r\n<a href=\"http://www.dotnet-programming.com/post/2010/12/11/Silverlighte280a6without-Ria-Service.aspx\">\r\nhere</a>).</strong></p>\r\n<p><strong>Features</strong></p>\r\n<ul>\r\n<li>Validation Toolkit for WPF &amp; Silverlight handles both data annotations and validation exceptions coming from web services&nbsp;\r\n<ul>\r\n<li>Web services may be called also asynchronously: the user interface is updated when validation exceptions come.\r\n</li><li>Validation Exceptions specify the piece of View Model they apply to, and Validation Toolkit for\r\n<em>WPF</em> &amp; <em>Silverlight</em> uses this information to display them adequately&nbsp;\r\n</li><li>Validation Exceptions come either from Data Annotation on the server side or from the interaction of the business level with data sources.\r\n</li></ul>\r\n</li><li>The interface offered to the programmer by both the <em>Silverlight</em> and the\r\n<em>WPF</em> versions is the same in spite of the different techniques used by the two versions to communicate with the presentation layer.\r\n</li><li>The View Model that is bound to the user interface doesn't need to implement ANY interface, Validation Toolkit for WPF &amp; Silverlight deso all the job for it.\r\n<ul>\r\n<li>No need to implement<em>&nbsp;INotifyPropertyChanged</em>:&nbsp;Validation Toolkit for WPF &amp; Silverlight does it for you&nbsp;\r\n</li><li>No need to implement<em>&nbsp;INotifyDataErrorInfo </em>or&nbsp;<em>IDataErrorInfo</em>:&nbsp;Validation Toolkit for WPF &amp; Silverlight does it for you&nbsp;\r\n</li></ul>\r\n</li><li>Helper methods to pack properly Validation exceptions on the server side </li><li><strong>Endpoint Behavior</strong> to enable the Wcf endpoint to be used by Silverlight to communicate FaultExceptions whose details are accessible by the Silverlight client(see the &quot;How to use it&quot; section below for more explanations, and see&nbsp;<a href=\"http://www.dotnet-programming.com/post/2010/12/11/Silverlighte280a6without-Ria-Service.aspx\">here</a>\r\n for a discussion about this problem).&nbsp;&nbsp;&nbsp; </li><li>Observable Dictionary datatype to handle adequately dictionaries, too. </li><li>FormatError attribute to specify errors in case wrong formatted string are inserted by the user.&nbsp;\r\n</li><li>The whole tree structure of the View Model is enabled to send errors and property changed events to the UI: collections and dictionaries at any depth included.\r\n</li><li><strong>DynamicRangeAttribute</strong> that extends the standard <em>RangeAttribute\r\n</em>by allowing both Min and Max be object properties at any level in the objects subtree (the same syntax for specifying properties in bindings apply). Moreover, a Dynamic Delay can be applied to both Dynamic Minimum and Dynamic Maximum.&nbsp;\r\n</li><li><strong>DynamicAttribute.</strong>&nbsp;Base attribute for defining dynamic attributes as the&nbsp;<strong>DynamicRangeAttribute.</strong>&nbsp;\r\n</li></ul>\r\n<p><strong><span><span><strong>If the Validation Toolkit for WPF &amp; Silerlight was useful to you,&nbsp;<a href=\"http://www.dotnet-programming.com/donate.aspx\">consider doing a donation</a>, to support it!</strong></span></span></strong></p>\r\n<p><strong>How to use it.</strong></p>\r\n<p>Using&nbsp;Validation Toolkit for WPF &amp; Silverlight is very easy:</p>\r\n<ol>\r\n<li>First, you have to enable <em>ValidatesOnNotifyDataErrors</em> in Silverlight and\r\n<em>ValidatesOnDataErros</em> in WPF for the bindings you want to apply validation to.&nbsp;\r\n</li><li>Then, you need to wrap your View Model into the dynamic object <em>BindWrapper</em> with the instruction:&nbsp;<em>new BindWrapper(ViewModel, true, true)</em>;&nbsp;Setting the second parameter to\r\n<em>true</em> causes all son objects of the View Model be recursively wrapped, too. Recursive wrapping will continue also through the boundaries of\r\n<em>IEnumerables </em>if the third parameter is set to <em>true</em>&nbsp;. </li><li>If &nbsp;there is no top level View Model class but your top level structure is either a simple enumerable or a dictionary you can wrap recursively through them by calling respectively:\r\n<br>\r\n<em>static ObservableCollection&lt;BindWrapper&gt; WrapEnumerable(IEnumerable source, bool wrapDeep = false, bool wrapEnumerables=false)</em><br>\r\nor<br>\r\n<em>public static ObservableDictionary&lt;string, BindWrapper&gt; WrapDictionary&lt;TValue&gt;(IDictionary&lt;string, TValue&gt; source, bool wrapDeep = false, bool wrapEnumerables = false)</em><br>\r\nThe result is respectively either an observable collection or an observable dictionary(the observable dictionary type is implemented in the toolkit). The meaning of the parameters is the same as &nbsp;the ones of the BindWrapper constructor.\r\n</li><li>Use the wrapper in place of your original object. You can get or set a &nbsp;property of your original View Model by getting or setting a property of the wrapper with the same name: It is a dynamic object it will accept it, and it will retrive or update\r\n the original property of your View Model while triggering the adequate events to update the interface and to perform validation.\r\n</li><li>Bind the wrapper to your user interface. In Silverlight you need to enclose in square brackets the names of the properties in your Bindings, because Silverlight doesn't support dynamic object and we were forced to use a dictionary. For instance, [Age] instead\r\n of Age. In WPF you can &nbsp;write the names of the properties as if they would come from your original View Model.\r\n</li><li>Validation of the simple properties is done automatically. When you want to trigger object level validation on the whole View Model or on a part of it, you call the\r\n<em>ValidateWholeObject</em> method of the relative wrapper. If Some Validation Exceptions are already available you can pass them to\r\n<em>ValidateWholeObject</em>&nbsp;as a parameter. </li><li>Each time Validation Exceptions comes from a web service you can call&nbsp;<em>AddValidationFaultExceptionContent(IEnumerable&lt;ValidationErrorInfo&gt; errors)</em>&nbsp;&nbsp;to update the interface. Where\r\n<em>ValidationErrorInfo</em>&nbsp;is a class used by the server to pack all server side errors into a\r\n<em>FaultException&lt;<em>IEnumerable&lt;ValidationErrorInfo&gt;</em>&gt;. </em>Please note that a Wpf client can receive the details of this\r\n<em>FaultException </em>only if the interface that defines the service is decorated with the\r\n<em>[FaultContract(typeof(<em>IEnumerable&lt;ValidationErrorInfo&gt;</em>))]</em> attribute. In case of a Silverlight client we have also to define a Silverlight specific endpoint and a apply to it the endpoint behavior included in the toolkit, that in case\r\n of exceptions, updates the status code of the response to 200 because Silverlight being a plugin can receive the deail of a response only if the status code of the response is either 200 or 404. See the example included in the binary distribution for details\r\n about how to configure the Silverlight endpoint. </li><li>If for some reason you need to reset the interface from object level validation errors you can call&nbsp;<em>ResetGlobalEvaluation()</em>, but normally you don't need to do it.\r\n</li></ol>\r\n<p><strong><br>\r\n</strong></p>\r\n<ol>\r\n</ol>\r\n</div><div class=\"ClearBoth\"></div>",
  "TagList": "Data Validation,Silverlight,WPF,validation,Data Annotations,Data Annotation,INotifyDataErrorInfo,IDataErrorInfo,INotifyPropertyChang,Object level validat,",
  "LastEdited": "2011-04-24T10:53:10.933-07:00"
}