{
  "ProjectName": "proxylesswcf",
  "Title": "Proxyless WCF Client for .NET",
  "Description": "This library is intended to help developers leverage WCF without needing to add a service reference to services they control; it has been developed in C# and examples are packaged with the solution.  This library is intended to work with Silverlight 4/5 and Full Framework (.NET 4.0 and up) projects.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><h2>Project Description</h2>\rThis library is intended to help developers leverage WCF without needing to add a service reference to services they control&#59; it has been developed in C&#35; and examples are packaged with the solution.  This library is intended to work with Silverlight 4&#47;5 and Full Framework &#40;.NET 4.0 and up&#41; projects.<br />\n<h2>Updates</h2>\r<ul><li>6/1/2013\n<ul><li>Packaged for <a href=\"https://nuget.org/packages/N3P.WCF.Proxyless/\">NuGet</a></li></ul></li>\n<li>1/6/2012\n<ul><li>Changed the model for finding the appropriate way of dispatching back to the UI thread</li>\n<li>Added a download for the Silverlight 4 compatible libarary</li></ul></li></ul>\n\n<h2>How It Works</h2>\rWhen you create a new <b><i>WcfClient&lt;T&gt;</i></b> (or call <b><i>WcfClient&lt;T&gt;.CreateClientAsync()</i></b>) a check is made to determine whether or not a proxy for the service contract <b><i>T</i> </b> has been made yet.  If it has not, a new contract is generated with corresponding APM signatures and a client (reasonably similar to the one you&#39;d get by saying &quot;Add Service Reference&quot;) is generated.  A linkage is made internally between type <b><i>T</i></b> and this newly generated proxy definition so that for the rest of this execution of the program that proxy type will be used when referring to a service known by that contract and not have to generate a new one.  Similarly, each synchronous method is linked up to its corresponding Begin/End method pair immediately after generation.<br /><br />Methods calls on the service are made via the <b><i>WcfClient&lt;T&gt;.Call(...)</i></b> methods.  The method on the service to call is selected via a LINQ expression like <i>service =&gt; service.DoSomething(arg0, arg1)</i> and the result of the call is passed into the specified <b><i>Action&lt;TResult, Exception&gt;</i></b> or <b><i>Action&lt;Exception&gt;</i></b> continuation method parameter (depending on whether the service method has a return type - <b><i>TResult</i></b> - or not).  When <i>Call</i> executes it:\n<ol><li>Locates the Begin/End method pair that correspond to the method from the expression</li>\n<li>Evaluates each of the parameters given in the expression</li>\n<li>Prepares an object[] with enough elements to hold the arguments to the method plus the OnComplete callback and AsyncState</li>\n<li>Sets the OnComplete callback&#39;s slot in the array to be the End method from the pair (which will execute the continuation method - ideally on the UI thread)</li>\n<li>Invokes the Begin method with the object array as the parameters</li></ol>\n\n<h2>Example Usage</h2>\r<b>Service Contract</b><br /><pre>\n// This contract must be defined in such a way that it is accessible to both the\n// service&#39;s implementation and to the client.  In the examples, this is done by\n// using a Portable Class Library though using &quot;linked&quot; files should work just\n// as well.  Notice that the signatures for the Async Pattern Methods do not\n// need to be specified.\n[ServiceContract]\npublic interface IMyService\n{\n     [OperationContract]\n     string DoSomething(string param0, string param1);\n}\n</pre><br /><b>Service Implementation</b><br /><pre>\n// Include the following two attributes on your service if it will need to be called\n// from a Silverlight application.  That aside, the implementation of the service\n// does not have any special considerations for working with this library.\n[SilverlightFaultBehavior]\n[AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]\npublic class MyService : IMyService\n{\n     public string DoSomething(string param0, string param1)\n     {\n          return param0 + &quot; &quot; + param1;\n     }  \n}\n</pre><br /><b>Calling the Service</b><br /><pre>\npublic class Program\n{\n     static void Main()\n     {\n          // Create a new client for the service contract IMyService using the default\n          // binding for type IMyService from the configuration file for the app.\n          // Overloaded constructors are available to use named configurations, etc.\n          var client = new WcfClient&lt;IMyService&gt;();\n\n          // Call the method &quot;DoSomething&quot; on the service with parameters &quot;Hello&quot; \n          // and &quot;There&quot; and invoke the method DoSomethingResultReceived when \n          // a response from the service has been returned\n          client.Call(x =&gt; x.DoSomething(&quot;Hello&quot;, &quot;There&quot;), DoSomethingResultReceived);\n     }\n\n     // Notice that the first parameter in this method (used as the continuation for\n     // the service call made above) takes two parameters:\n     // The first (string) is the return type of the method from the service\n     // The second (Exception) is used to notify the client of any exceptions \n     //      encountered while making the call to the service\n     static void DoSomethingResultReceived(string message, Exception ex)\n     {\n          if(null == ex)\n          {\n               //The call to the server succeeded, process the result\n               ...\n          }\n          else\n          {\n               //The call to the server failed, handle the error\n               ...\n          }\n     }\n}\n</pre><br />\n<h2>More Information</h2>\r<ul><li>All service methods are invoked as their Async pattern counterparts though the APM style signatures do not need to be defined in the service contract</li>\n<li>The result of the service call is passed into the continuation method parameter in the Call method</li>\n<li>In order to open the solution from source control the following Visual Studio tools are required:\n<ul><li><a href=\"http://www.silverlight.net/downloads\">Silverlight 5</a></li>\n<li><a href=\"http://visualstudiogallery.msdn.microsoft.com/b0e0b5e9-e138-410b-ad10-00cb3caf4981\">Portable Library Tools</a></li></ul></li></ul>\n\n<h2>Links</h2>\r<ul><li><a href=\"http://msdn.microsoft.com/en-us/library/gg597391.aspx\">Portable Class Libraries</a></li>\n<li><a href=\"http://visualstudiogallery.msdn.microsoft.com/5e730577-d11c-4f2e-8e2b-cbb87f76c044\">Project Linker</a></li>\n<li><a href=\"http://www.silverlight.net\">Silverlight.NET</a></li>\n<li><a href=\"http://wcf.codeplex.com\">WCF Community Site</a></li></ul></div><div class=\"ClearBoth\"></div>",
  "TagList": "wcf,.NET 4.0,silverlight 5,silverlight 4,",
  "LastEdited": "2013-06-01T13:58:04.5-07:00"
}