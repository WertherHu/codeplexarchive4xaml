{
  "ProjectName": "SilverlightNav",
  "Title": "Silverlight Navigation With Caliburn.Micro",
  "Description": "Bring the power of the Cabliurn.Micro MVVM framework to Siliverlight 4 navigation applications.  \r\n\r\nThis sample application for CM shows how it can be used to create MVVM friendly Navigation applications which formerly required a view-first approach. ",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><h2>How to combine Silverlight Navigation with the Caliburn.Micro framework, with a bit of MEF thrown in!</h2>\r\nI created this navigation sample after trying to combine the Caliburn.Micro MVVM framework with a Silverlight navigation application that I was currently working with.  Out of the box, CM does not support this.  The whole purpose of the navigation is so that the foward and back buttons of the browser work to navigate correctly within your SL app.  If your SL app doesn&#39;t support this, and your user tries to use the back button, he will be thrown out of your app to the prior page he was on such as his home page.  Not a nice experiance and probably not what he expected.  Further, you want to be able to have a link that goes all the way down to a specific product or item.  The end user should be able to email that link to someone and have them click on it and go directly there.  Again, having the navigation enabled is the only way to accomplish this.<br /><br />The issue is that a SL nav application is required to work with a Frame inside of which all navigation is done.  The navigation is based on a URI to a specific location.  This is pretty much as far as you can get from an MVVM approach and there is no way around this.  Or so I thought.  After quite a bit of digging, I found that you there is an interface call INavigationContentLoader and by using this, you can catch the call of the navigation and do what you will with it.  <br /><br />In this sample application, I used MEF to find the page to navigate to and instantiate it, then use MEF again to find the ViewModel for the page, and then use Caliburn.Micro to bind the two together.  This gives us the best of both worlds, the Navigation benefits, and the benefits of MVVM. <br /><br />To implement this in your own project, you don&#39;t really need to know either MEF or Caliburn.Micro too deeply.  There are a couple of nuggets in implementing them, but you will find those easy to master and are covered in detail in the documentation.  But you can easily get up and running just starting with this sample application.  All the code to make it work has already been written.  This was the hard part.  All you need to do is just to use is an attribute on your Page and ViewModel so MEF can find them and marry them up.  If you have any questions, feel free to post over on the discussion page.<br /><br />Greg Gum<br /><br />See my Silverlight Blog at <a href=\"http://SilverlightDev.net\">SilverlightDev.net</a><br /><br />\n<ul><li>For the manual, check out <a href=\"http://silverlightnav.codeplex.com/documentation\">http://silverlightnav.codeplex.com/documentation</a></li></ul>\n\n<ul><li>For the source code: <a href=\"http://silverlightnav.codeplex.com/SourceControl/list/changesets\">http://silverlightnav.codeplex.com/SourceControl/list/changesets</a></li></ul>\n\n<ul><li>For the latest Caliburn.Micro, see <a href=\"http://caliburnmicro.codeplex.com\">http://caliburnmicro.codeplex.com</a> While this project includes a copy of Caliburn.Micro.Silverlight current at the time of project creation, you should obtain a copy of the latest version before implementing it in your own project.  Caliburn.Micro is updated frequently by it&#39;s author, Rob Eisenberg.</li></ul>\n<br /><br /><br /><br /><br /><br /></div><div class=\"ClearBoth\"></div>",
  "TagList": "",
  "LastEdited": "2010-11-27T09:45:50.543-08:00"
}