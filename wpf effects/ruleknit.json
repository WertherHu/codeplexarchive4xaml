{
  "ProjectName": "ruleknit",
  "Title": "RuleKnit: Function Auto-wiring for Iterative Algorithms",
  "Description": "Runtime code generator for wiring together side-effect-free functions to implement iterative algorithms.",
  "MovedLink": "https://github.com/ryascl/ruleknit",
  "HomeWiki": "<div class=\"wikidoc\"><h3>About</h3>\r\nRuleKnit provides runtime code generation for wiring together side-effect-free functions. It is intended to allow iterative algorithms to be decomposed into a series of simple functions (as static methods) that can be auto-wired together based on parameter and method naming.<br />\n<h3>Bowling sample</h3>\r\nThe sample code below is a solution to the bowling problem posed in these articles:<br /><a href=\"http://web.archive.org/web/20090925095831/http://xprogramming.com/xpmag/acsbowling/\">The Bowling Game</a><br /><a href=\"http://web.archive.org/web/20090304201612/http://xprogramming.com/xpmag/acsBowlingProcedural.htm\">Bowling Revisited</a><br /><a href=\"http://web.archive.org/web/20091220052733/http://xprogramming.com/xpmag/acsBowlingProceduralFrameScore\">Extending the Procedural Bowling Game</a><br /><a href=\"http://xprogramming.com/articles/miningbowling/\">Mining the Bowling Game</a><br />\n<h3>RuleKnit solution</h3>\r\nThe <span class=\"codeInline\">RulesetBowlingGame</span> class (and accompanying <span class=\"codeInline\">Rolls</span> class) are the <i>complete</i> solution to the bowling calculation problem. No other code is required. The rule-based approach can distill and make obvious the underlying algorithms of the problem, as demonstrated in the static methods of <span class=\"codeInline\">RulesetBowlingGame</span>. Procedural solutions to the problem frequently obscure the underlying rules, as can be seen in some of the earlier solutions above.<br /><br />An interesting result of using RuleKnit to solve this problem: the clarity of the solution you see below is similar to the final solution arrived at in the articles above after multiple iterations over time. However, using RuleKnit, this result was arrived at on the <i>first attempt</i> (without having peeked at the existing solution).<br /><br /><pre>\n    [Ruleset]\n    public abstract class RulesetBowlingGame : IBowlingGame\n    {\n        public int Score(int[] rolls)\n        {\n            return Score(new Rolls(rolls), 0, 1);\n        }\n\n        [Generated(&quot;TotalScore&quot;, IterationExitRule = &quot;Finished&quot;)]\n        protected abstract int Score(Rolls rolls, int totalScore, int frameNumber);\n\n        protected static int FrameNumber(int frameNumber)\n        {\n            return frameNumber + 1;\n        }\n\n        protected static bool Finished(int frameNumber)\n        {\n            return frameNumber == 10;\n        }\n\n        protected static int FrameSize(bool isStrike)\n        {\n            return isStrike ? 1 : 2;\n        }\n\n        protected static bool IsStrike(Rolls rolls)\n        {\n            return rolls[0] == 10;\n        }\n\n        protected static bool IsSpare(Rolls rolls)\n        {\n            return rolls[0] + rolls[1] == 10;\n        }\n\n        protected static int RollsToScore(bool isStrike, bool isSpare)\n        {\n            return isStrike || isSpare ? 3 : 2;\n        }\n\n        protected static Rolls Rolls(Rolls rolls, int frameSize)\n        {\n            return rolls.GetRange(frameSize, rolls.Count - frameSize);\n        }\n\n        protected static int FrameScore(Rolls rolls, int rollsToScore)\n        {\n            return rolls.GetRange(0, rollsToScore).Sum();\n        }\n\n        protected static int TotalScore(int totalScore, int frameScore)\n        {\n            return totalScore + frameScore;\n        }\n    }\n\n    [Immutable]\n    public class Rolls : List&lt;int&gt; \n    {\n        public new Rolls GetRange(int index, int count)\n        {\n            return new Rolls(base.GetRange(index, count));\n        }\n    }\n</pre><br />\n<h3>The generated code</h3>\r\nWhen the ruleset is created, the following code is generated and compiled at runtime to implement the abstract <span class=\"codeInline\">Score</span> method. This method runs the rules iteratively until completion, returning the result. The static methods of the class were wired together based on the names of the methods and the parameter names.<br /><br /><pre>\npublic class GeneratedRulesetBowlingGame : Examples.BowlingGameSimple.RulesetBowlingGame {\n\t\n\tprotected override int Score(Examples.BowlingGameSimple.Rolls rolls, int totalScore, int frameNumber) {\n\t\tbool finished;\n\t\tdo {\n\t\t\t\tbool isStrike = IsStrike(rolls);\n\t\t\t\tint frameSize = FrameSize(isStrike);\n\t\t\t\tbool isSpare = IsSpare(rolls);\n\t\t\t\tint rollsToScore = RollsToScore(isStrike, isSpare);\n\t\t\t\tint frameScore = FrameScore(rolls, rollsToScore);\n\t\t\t\tfinished = Finished(frameNumber);\n\t\t\t\trolls = Rolls(rolls, frameSize);\n\t\t\t\ttotalScore = TotalScore(totalScore, frameScore);\n\t\t\t\tframeNumber = FrameNumber(frameNumber);\n\t\t}\n\t\twhile(!finished);\n\t\treturn totalScore;\n\t}\n\t\n}\n</pre><br /><br />The source code for this solution is provided in the Examples project, along with the source for an algorithmic solution for comparison.<br />This project was originally published in 2007.<br /><br /></div><div class=\"ClearBoth\"></div>",
  "TagList": "",
  "LastEdited": "2014-02-16T13:37:49.82-08:00"
}