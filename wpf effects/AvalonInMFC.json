{
  "ProjectName": "AvalonInMFC",
  "Title": "Using a WPF control in a MFC application",
  "Description": "In this proof of concept we try to demonstrate how it’s possible to mix C++ MFC UI with WPF control. \nFor example, we can replace the standard View with a WPF View or we can add a WPF control to an MFC dialog box. This project is based on the same template architecture available in VC++2008, integrating the Windows Form into an MFC Application\n",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><b>Project Description</b><br />In this proof of concept we try to demonstrate how it&#8217;s possible to mix C&#43;&#43; MFC UI with WPF control. <br />For example, we can replace the standard View with a WPF View or we can add a WPF control to an MFC dialog box. This project is based on the same template architecture available in VC&#43;&#43;2008, integrating the Windows Form into an MFC Application<br /><br /><br /><br />Before to begin you need to prepare VC++2008 in order to build correctly the sample<br /><br />Setup C++ Directories <br /><br />1) Add the path to the.NET 3.0 FrameWork assemblies<br />   Choose the Tools/Options menu.<br />  In the Options Dialog Box, choose Project and solution <br /> For the reference files add the following path &quot;C:\\Program Files\\Reference <br /><br />Assemblies\\Microsoft\\Framework\\v3.0&quot;<br /><br /><br />2) In the zip file you will find the \\Integration Avalon\\BuildSolution  directory, including all the <br /><br />include, lib and dll in order to build the solution. <br />Add the \\Integration Avalon\\BuildSolution\\include directory to the path (this directory contents two <br /><br />files, evxavalon.h and evxavalon.inl)<br /><br />3) Add the \\Integration Avalon\\BuildSolution\\Lib\\win32 to the lib path and to the reference files <br /><br />path.<br /><br />Note : Only the library AvalonViewud.lib (debug and Unicode) is available in this sample. Don’t <br /><br />compile with ansi character set.<br />Important : Install the WPFCommandTarget.dll and  WPFHwndSource.dll in the Global Assemblies Cache <br /><br />(GAC) <br /> <br /><br />Using a WPF in a MFC dialog box:<br />\t<br />1)\tIn Visual Studio 2008, choose an MFC dialog box. Called it MFCTest.<br />2)\tAdd /clr compil option <br /><br />3)\tAt the end of the stdafx.h file add the following line: #include &lt;evxavalon.h&gt;<br />4)\tIn the MFCTestdlg.h add:<br /> CAvalonControl&lt;System::Windows::Controls::Button&gt; m_WPFButton ;<br /><br /><br />5)\tAdd to your MFC Dialog Box a Static Text control, and called it IDC<i>STATIC</i>WPF<br />6)\tThe add the following code <br />DDX<i>AvalonControl(pDX,IDC</i>STATIC<i>WPF,this-&gt;m</i>WPFButton); <br />in the CMFCTestDlg::DoDataExchange(…) method<br />Build the solution, and test it<br /> <br /><br />What I need now, it’s to add some extra code to react to the WPF button click event in the MFC code.<br /><br />1)\tIn the MFCTestDlg.h file add the following method declaration :<br />void SurClickBoutonWPF(System::Object^ sender, System::Windows::RoutedEventArgs^ e);<br /><br />Note : in the .NET World, the best practice for the event it’s to use the pattern, with the <br /><br />following parameters. <br />System.Object (which control is raising the event)<br />System.EventArgs, parameters that you want to pass to the subscriber.<br /><br />2) In the MFC application, you can use some .NET classes in order to subscribe to the .NET event. <br /><br />But the C++ team provides us some very helpful macros.<br />In the MFCTestDlg.h file add the lines:<br /><br />BEGIN<i>DELEGATE</i>MAP (CMFCTestDlg)<br />    EVENT<i>DELEGATE</i>ENTRY (SurClickBoutonWPF,System::Object^,System::Windows::RoutedEventArgs^); <br /><br />END<i>DELEGATE</i>MAP ()<br /><br />Don’t’ forget the &#171; ^ &#187; character which symbolize a ref class.<br /><br />3)\tIn the MFCTestDlg.cpp file, add the SurClickBoutonWPF method like this<br />void CMFCTestDlg::SurClickBoutonWPF(System::Object ^sender, System::Windows::RoutedEventArgs ^e)<br />{<br />\tAfxMessageBox(L&quot;Click d&#39;un bouton WPF ex&#233;cut&#233; dans du code MFC&quot;);<br />}<br /><br />4)\tThe last thing to do, it’s in the MFC code, subscribe to the WPF control Click Event using <br /><br />the MAKE_DELEGATE macro.<br />5)\tIn the OnInitDialog(), add the following code :<br /> m<i>WPFButton-&gt;Click+=MAKE</i>DELEGATE (System::Windows::RoutedEventHandler,SurClickBoutonWPF);<br /><br />The construction looks like the C# construction<br />6)\tBuild and test the solution <br /> <br /><br />In this sample, I used the System.Windows.Controls.Button, but it’s perfectly allowed to use a WPF <br /><br />CustomControl, as we will see in a moment.<br /><br />After this very simple example, what will we cover now, it’s replacing the CView with my own <br /><br />CavalonView which display a WPF CustomControl.<br /> <br /><br />Replacing the standard CView with the CAvalonView<br /><br /><br /><br /> <br /><br /><br />1)\tIn Visual Studio 2008, create a new MFC SDI application. Called MFCTestVue.<br />2)\tDon’t forget to add the /clr command line.<br />3)\tAdd an include #include &lt;evxavalon.h&gt; in stdafx.h<br />4)\tOpen the MFCTestVueView.h file, and inherit from CAvalonView<br />class CMFCTestVueView : public CAvalonView<br /><br />5)\tDo the same exercise in the MFCTestVueView.cpp, replace CView by CAvalonView<br />IMPLEMENT_DYNCREATE(CMFCTestVueView, CAvalonView)<br />BEGIN<i>MESSAGE</i>MAP(CMFCTestVueView, CAvalonView)<br /><br /><br />Now we need to create our first WPF UserControl.<br /><br />1) Adding a new project called TestWPFControl In VS 2008 : select the Visual C# language, then &quot;WPF <br /><br />User Control Library&quot; Template<br />add a ListBox and a button  to the surface designer<br /><br /><br />2)\tCome back to the MFC Solution<br />3)\tSelect the MFC project, and add TestWPFControl as a reference.<br />4)\tOpen the MFCTestVueView.cpp, and for the constructor add a declaration to the WPF Control <br /><br />like this :<br />CMFCTestVueView::CMFCTestVueView():CAvalonView(TestWPFControl::UserControl1::typeid)<br />5)\tBuild the solution  <br /><br /><br /><br />\t\t\t\t<br />Now I&#39;m going to show you how to interact from the MFC code with the WPF code.<br /><br />In these simples’ demos, we will see.<br />•\tHow to subscribe to the event click<br />•\tHow to interact with WPF code from MFC command<br />•\tHow to use standard command like Cut, past, undo etc…<br /><br /><br />Filling the WPF list box from the MFC code<br />1)\tIn Visual Studio 2008, open the UserControl1.xaml.cs file<br />2)\tAdd the two declaration<br />3)\tpublic Button MonButton;<br />public ListBox MaListeBox;<br />4)\tIn the constructor <br />MonButton = this.button<br />MaListBox = this.ListBox1<br /><br />5)\tOpen the MFC project and add the following code in the MFCTestVueView.h file :<br /><br />void SurClickButton(System::Object^ sender,System::Windows::RoutedEventArgs^e);<br /><br />BEGIN<i>DELEGATE</i>MAP (CMFCTestVueView)<br />\tEVENT<i>DELEGATE</i>ENTRY (SurClickButton,System::Object^, System::Windows::RoutedEventArgs^)<br />END<i>DELEGATE</i>MAP ()<br />virtual void OnInitialUpdate();<br /><br />6)\tOpen the MFCTestVueView.cpp file and implement the OnInitialUpdate and SurClickButton <br /><br />methods like this.<br /> <br />void CMFCTestVueView::OnInitialUpdate() <br />{<br />\tTestWPFControl::UserControl1^ wpfControl;<br />\twpfControl=static_cast&lt;TestWPFControl::UserControl1^&gt;(this-&gt;GetControl ());<br />\twpfControl-&gt;Button-&gt;Click +=MAKE_DELEGATE <br />          (System::Windows::RoutedEventHandler,SurClickButton);<br />}<br /><br />void CMFCTestVueView::SurClickButton(System::Object ^sender, System::Windows::RoutedEventArgs ^e) <br />{<br />\tTestWPFControl::UserControl1^ wpfControl;<br />\twpfControl=static_cast&lt;TestWPFControl::UserControl1^&gt;(this-&gt;GetControl ());<br />\tfor (int i= 0;i &lt;20;i++)<br />\t{<br />\t\tString^ sEl=String::Format (&quot;El&#233;ments {0}&quot;,i.ToString ());<br />\t\twpfControl-&gt;MaListeBox-&gt;Items-&gt;Add(sEl);<br />            }<br />}<br /><br /><br /><br />Trigger a WPF method from an MFC Command<br />1)\tAdd an new command to the MFC menu<br />2)\tNote the number of the command in the resource.h <br />#define ID_TESTNET                      32773<br />We will use it later in the WPF Project<br /><br />3)\tCome back to the WPF project, open UserControl1.xaml.cs, <br />4)\tAdd a reference to the C:\\Program Files\\Microsoft Visual Studio 8<br /><br />\\VC\\atlmfc\\lib\\mfcmifc80.dll<br /><br />5)\tInherit the UserControl from Microsoft.VisualC.MFC.ICommandTarget<br /><br />6)\tStill in the WPF project, implement the Initialize method. (Note the number of the MFC <br /><br />command) <br />public void Initialize(Microsoft.VisualC.MFC.ICommandSource src)<br />        {<br />            src.AddCommandHandler(32773,new Microsoft.VisualC.MFC.CommandHandler<br /><br />(this.OnTestCommande));<br />        }<br /><br />7)\tIn last, create the OnTestCommande() method. <br />private void OnTestCommande(uint cmdID)<br />        {<br />            MessageBox.Show(&quot;Code WPF&quot;);<br />        }<br /><br />8)\tBuild the solution<br /> <br />Using the standard MFC command<br /><br />1)\tIn the WPF Project, add a reference to<br />.\\Integration Avalon\\BuildSolution\\Lib\\win32\\WPFCommandTarget.dll <br /><br />2)\tIn the Initialize method, add the following declaration :<br />DPE.VisualC.MFC.EV.WPFCommandTarget Wp = new DPE.VisualC.MFC.EV.WPFCommandTarget();<br />Wp.Initialize(src, this);<br /><br />3)\tIn order to test the sample add two textbox in the WPF control<br />4)\tBuild the solution.<br /><br /></div><div class=\"ClearBoth\"></div>",
  "TagList": "",
  "LastEdited": "2008-07-15T09:21:43.343-07:00"
}