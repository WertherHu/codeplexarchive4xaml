{
  "ProjectName": "firefly",
  "Title": "FireFly ViewModel framework",
  "Description": "FireFly is ViewModel framework oriented to working with hierarchically-organized data.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><br />FireFly is ViewModel framework oriented to working with hierarchically-organized data.<br />\n<h3>It’s simple in use…</h3>\r\nLibrary contains less than 15 types, and you can learn how to use it less than 1 hour! Also, integration of FireFly with you application is very simple. Just create new subclass of <i>ViewModelService</i> and set its instance as value of <i>ViewModelService.Instance</i>, before framework will be used.<br />\n<h3>…”simple” – doesn’t mean “trivial”  </h3>\r\nFireFly provides powerful functionality which will be described below. And it can be easy customized for you needs.<br />\n<h3>Collection of view models – is a view model too…</h3>\r\nFireFly framework already have class for wrapping models collections – <i>CollectionViewModel</i>. And these collections – are view models too. Once you define collection view model, you don’t need to worry about synchronization between model collection and its view model. <i>CollectionViewModel</i> will do it automatically!<br />\n<h3>…and it can have user friendly visibility behavior</h3>\r\nI call it “user friendly collections”. It’s mechanism for determining visibility of the collection view model in visual tree depends on collection state. For example, if collection doesn’t have any children, it can be hidden and doesn’t appear to user. But if some element will be added to this collection, it will appear again. <br />\n<h3>Static commanding makes writing unit tests easier</h3>\r\nView models in FireFly contains commands as static fields in most cases. For example:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">#region</span> CloseProjectCommand\n        <span style=\"color:Blue;\">public</span> IRelayCommand CloseProjectCommand { <span style=\"color:Blue;\">get</span> { <span style=\"color:Blue;\">return</span> _CloseProjectCommand; } }\n        <span style=\"color:Blue;\">static</span> RelayCommand&lt;MainWindowViewModel&gt; _CloseProjectCommand = <span style=\"color:Blue;\">new</span> EditCommand&lt;MainWindowViewModel&gt;(context =&gt;\n        {\n            <span style=\"color:Blue;\">if</span>(context.ViewModel.Project == <span style=\"color:Blue;\">null</span>)\n                <span style=\"color:Blue;\">return</span>;\n            context.ViewModel.Project.Close();\n            context.ViewModel.Project = <span style=\"color:Blue;\">null</span>;\n            context.AppContext.PreviewPanel.ResetObject();\n            context.AppContext.Tree.ItemsSource = <span style=\"color:Blue;\">null</span>;\n            context.AppContext.Editor.SetXAML(<span style=\"color:Blue;\">null</span>);\n        }, <span style=\"color:#A31515;\">&quot;MainWindowViewModel.CloseProjectCommand&quot;</span>);\n<span style=\"color:Blue;\">#endregion</span>\r\n</pre></div><br />This approach makes writing unit tests for commands with rich UI logic a little easier. <br /><i>Execute()</i> and <i>CanExecute()</i> methods of <i>RelayCommand</i> takes <i>CommandExecutionContext</i> as parameter. Execution context have all information that command need for execution. All communication between command logic and application going through value of <i>CommandExecutionContext.UIContext</i> property. You can share same interface, for example <i>IUIContext</i>, between application and test environment. <br />Also, it makes view model a little more lightweight. In many cases your view model will have only link to model and links to collections (if it has) and no matter how much commands it supports.<br />\n<h3>And bonus</h3>\r\n<i>ViewModelBase</i>, <i>CollectionViewModel</i> and <i>RelayCommand</i> already have <i>Icon</i> and <i>DisplayName</i> properties that you can use for binding. All you need is override <i>ViewModelService.GetIcon()</i> and <i>ViewModelService.GetString()</i> methods. Also, <i>HierarchicalViewModel</i> implement <i>RemoveCommand</i> with common deleting scenario.<br />\n<h3>Samples</h3>\r\nSamples of using FireFly you can find in <a href=\"http://xamlstylepad.codeplex.com\">XAMLStylePad</a> project.<br /></div><div class=\"ClearBoth\"></div>",
  "TagList": "MVVM,",
  "LastEdited": "2010-08-03T16:25:53.957-07:00"
}