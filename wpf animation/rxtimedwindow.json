{
  "ProjectName": "rxtimedwindow",
  "Title": "RxTimedWindow",
  "Description": "In the previous article on this series I used a WPF application, to demonstrate RX's inbuilt ability for abstraction of concurrency. This facilitates simplifica",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\">\r\n<h2 style=\"text-align:left\"><span style=\"color:#ff9900\">Prelude</span></h2>\r\n<p style=\"text-align:left\">In the previous article on this series I used a WPF application, to demonstrate RX's inbuilt ability for abstraction of concurrency. This facilitates simplification of unit-testing of MVVM concurrency scenarios. In this article we\r\n use a real life scenario which involves observing intra-day trades. We will use this real scenario to dig more deeper into the nuts and bolts of RX and analyse how Rx simplifies handling complex concurrent scenarios, with very little code while at the same\r\n time providing granular flexibilty of handling concurency, errors and unit testing abilities. We will leverage RX testing framework's flexibility to test on the virtual time dimension. This is an absolute necessary element because invariably realtime data\r\n sequence or streaming time series entails a time dimension to it. Along the way we will see in practice the below features of Rx.</p>\r\n<h3>Functional</h3>\r\n<p>Where applicable avoid intricate stateful programs, using clean input/output functions over observable streams.</p>\r\n<h3>Less is more</h3>\r\n<p>ReactiveX's operators often reduce what was once an elaborate challenge into a few lines of code.</p>\r\n<h3>Async error handling</h3>\r\n<p>Traditional try/catch is powerless for errors in asynchronous computations, but ReactiveX is equiped with proper mechanisms for handling errors.</p>\r\n<h3>Concurrency made easy</h3>\r\n<p>Observables and Schedulers in ReactiveX allow the programmer to abstract away low-level threading, synchronization, and concurrency issues.</p>\r\n<h2 style=\"text-align:left\"><span style=\"color:#ff9900\">Scenario</span></h2>\r\n<p>The power traders require an intra-day report to give them their day ahead power position. The report should output the aggregated volume per hour to a CSV file.</p>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<th>Sl.</th>\r\n<th>Requirements</th>\r\n</tr>\r\n<tr>\r\n<td>1</td>\r\n<td>Must be implemented as a Windows service using .Net 4.5 &amp; C#.</td>\r\n</tr>\r\n<tr>\r\n<td>2</td>\r\n<td>All trade positions must be aggregated per hour (local/wall clock time). Note that for a given,day, the actual local start time of the day is 23:00 (11 pm) on the previous day. Local time is,in the GMT time zone.</td>\r\n</tr>\r\n<tr>\r\n<td>3</td>\r\n<td>CSV output format must be two columns, Local Time (format 24 hour HH:MM e.g. 13:00),and Volume and the first row must be a header row.</td>\r\n</tr>\r\n<tr>\r\n<td>4</td>\r\n<td>CSV filename must be PowerPosition_YYYYMMDD_HHMM.csv where YYYYMMDD is,year/month/day e.g. 20141220 for 20 Dec 2014 and HHMM is 24hr time hour and minutes,e.g. 1837. The date and time are the local time of extract.</td>\r\n</tr>\r\n<tr>\r\n<td>5</td>\r\n<td>The location of the CSV file should be stored and read from the application configuration file.</td>\r\n</tr>\r\n<tr>\r\n<td>6</td>\r\n<td>An extract must run at a scheduled time interval; every X minutes where the actual interval,X is stored in the application configuration file. This extract does not have to run exactly on,the minute and can be within &#43;/- 1 minute of the configured interval.</td>\r\n</tr>\r\n<tr>\r\n<td>7</td>\r\n<td>It is not acceptable to miss a scheduled extract.</td>\r\n</tr>\r\n<tr>\r\n<td>8</td>\r\n<td>An extract must run when the service first starts and then run at the interval specified as,above.</td>\r\n</tr>\r\n<tr>\r\n<td>9</td>\r\n<td>It is acceptable for the service to only read the configuration when first starting and it does,not have to dynamically update if the configuration file changes. It is sufficient to require a,service restart when updating the configuration.</td>\r\n</tr>\r\n<tr>\r\n<td>10</td>\r\n<td>The service must provide adequate logging for production support to diagnose any issues.</td>\r\n</tr>\r\n<tr>\r\n<td>11</td>\r\n<td>This should handle Daylight Saving Start and End</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n<h3 style=\"text-align:left\"><span style=\"color:#ff9900\">Additional Notes</span></h3>\r\n<p>An assembly has been provided (PowerService.dll) that must be used to interface with the &ldquo;trading system&rdquo;. A single interface is provided to retrieve power trades for a specified date. Two methods are provided, one is a synchronous implementation\r\n (<span style=\"color:#0000ff\">IEnumerable&lt;TradeAdapter&gt;</span>) and the other is asynchronous (<span style=\"color:#0000ff\">Task&lt;IEnumerable&lt;TradeAdapter&gt;&gt;</span>). The implementation has to use the async method. The classPowerService is the\r\n actual implementation of this service. The date argument should be the date to retrieve the power position (volume) for. The PowerTrade class contains an array of PowerPeriods for the given day. The period number starts at 1, which is the first period of the\r\n day and starts at 23:00 (11 pm) on the previous day.</p>\r\n<h3 style=\"text-align:left\"><span style=\"color:#ff9900\">Example</span></h3>\r\n<p>Given the call to PowerService.GetTrades returns the following two trade positions:</p>\r\n<pre>    T1 =&gt; [ P1{1,100} , P2{2,100}, P3{3,100}, P4{4,100} .. P23{23,100},P24{24,100}]\n    T2 =&gt; [ P1{1,-50} , P2{2,-20}, P3{3,-50}, P4{4,-50} .. P23{23,100},P24{24,10}]\n</pre>\r\n<h3 style=\"text-align:left\"><span style=\"color:#ff9900\">Expected Output</span></h3>\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<th>Local Time</th>\r\n<th>Volume</th>\r\n</tr>\r\n<tr>\r\n<td>23:00</td>\r\n<td>50</td>\r\n</tr>\r\n<tr>\r\n<td>00:00</td>\r\n<td>80</td>\r\n</tr>\r\n<tr>\r\n<td>01:00</td>\r\n<td>50</td>\r\n</tr>\r\n<tr>\r\n<td>02:00</td>\r\n<td>50</td>\r\n</tr>\r\n<tr>\r\n<td>....</td>\r\n<td>....</td>\r\n</tr>\r\n<tr>\r\n<td>21:00</td>\r\n<td>200</td>\r\n</tr>\r\n<tr>\r\n<td>22:00</td>\r\n<td>110</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n<h2 style=\"text-align:left\"><span style=\"color:#ff9900\">Conceptual Analysis and Design</span></h2>\r\n<p>We can conceptualise the workflow as an infinite sequence of Timer events Tm which\r\n<strong>transforms</strong> to <strong>Observable</strong> collection of Trades. During the transformation process there could be exceptions as shown as Error. In such situations we will need to\r\n<strong>Retry</strong> the source such that the Timer event sequence continues instead of dying out with an\r\n<strong>Error</strong>. This is necessary by design in this scenario because the specification 7 says that it is not acceptable to miss a scheduled extract.</p>\r\n<pre>    Tm&ndash;&gt;{ T1 {Periods[1,n], T2 {Periods[1,m] , &hellip; Tn {Periods[1,k] }&ndash;&gt;Completed\n    Tm&ndash;&gt;{ T1 {Periods[1,n], T2 {Periods[1,m] , &hellip; Tn {Periods[1,k]}&ndash;&gt;Completed\n    Tm&ndash;&gt;{ }&ndash;&gt;Error&mdash;&gt;{ T1 {Periods[1,n], T2 {Periods[1,m] , &hellip; Tn {Periods[1,k] }&ndash;&gt;Completed\n    Tm&ndash;&gt;{ T1 {Periods[1,n], T2 {Periods[1,m] , &hellip; Tn {Periods[1,k]}&ndash;&gt;Completed\n    Tm&ndash;&gt;{ T1 {Periods[1,n], T2 {Periods[1,m] , &hellip; Tn {Periods[1,k]}&ndash;&gt;Completed\n    Tm &hellip;.\n</pre>\r\n<p>All the above specifications using the conceptual design above can be implemented in as simple as 60 lines of formatted code below. Additionally the complexity of Error handling , scheduling , multi value handling , transformation and unit testing of concurrency\r\n over virtual time dimension can be easily achieved as discussed in the following sections.</p>\r\n<pre>public void Run(IPowerService svc, IScheduler scheduler, DateTime dtrunDate, TimeZoneInfo timeZoneInfo,\n int observationIntervalInMinutes, StringBuilder sbpowerpositionLines, string csvFilePath, StreamMode streamMode = StreamMode.StreamToFile)\n{\n    var dateTimeHelper = new DateTimeHelper(dtrunDate,timeZoneInfo);\n    _reporterDisposable = Observable.Interval(TimeSpan.FromMinutes(observationIntervalInMinutes), scheduler)\n        .Select(i =&gt;\n        {\n            dtrunDate = dtrunDate.AddMinutes((i &#43; 1) * observationIntervalInMinutes);\n            return Observable.FromAsync(() =&gt; svc.GetTradesAsync(dtrunDate));\n        })\n        .Subscribe(m =&gt;\n        {\n            sbpowerpositionLines.Clear();\n            sbpowerpositionLines.AppendLine(&quot;Local Time,Volume&quot;);\n            m.Catch((PowerServiceException ex) =&gt;\n            {\n                Log.Error(string.Format(&quot;PowerServiceException  {0}&quot;, ex.Message));\n                return Observable.FromAsync(() =&gt; svc.GetTradesAsync(dtrunDate));\n            })\n            .Retry()\n            .SelectMany(t =&gt; t.SelectMany(x =&gt; x.Periods))\n            .GroupBy(g =&gt; g.Period)\n            .Select(p =&gt; new {Period = p.Key, Volume = p.Sum(_ =&gt; _.Volume)})\n            .Subscribe(value =&gt;\n            {\n                value.Volume.Subscribe(volume =&gt;\n                {\n                    sbpowerpositionLines.AppendLine(string.Format(&quot;{0},{1}&quot;,\n                        dateTimeHelper.Reset(dtrunDate, timeZoneInfo).UtcIndexToLocalHourMap[value.Period], volume));\n                    Log.Info(string.Format(&quot;Period {0}, Volume {1}&quot;,\n                        value.Period,\n                        volume));\n                });\n            }, delegate\n            {\n                sbpowerpositionLines.AppendLine(&quot;OnError&quot;);\n                Log.Error(&quot;OnError&quot;);\n            }, \n            async () =&gt;\n            {\n                if (streamMode == StreamMode.StreamToMemory) return;\n                string path = Path.Combine(csvFilePath,\n                    &quot;PowerPosition&quot; &#43; dtrunDate.ToString(&quot;_yyyyMMdd_&quot;) &#43; DateTime.Now.ToString(&quot;HHmm&quot;) &#43;\n                    &quot;.csv&quot;);\n                if (Directory.Exists(csvFilePath))\n                {\n                    using (var stream = new StreamWriter(path))\n                    {\n                        await stream.WriteAsync(sbpowerpositionLines.ToString());\n                        await stream.FlushAsync();\n                    }\n                    Log.Info(&quot;Completed &quot; &#43; path &#43; &quot;\\n&quot;);\n                }\n                else\n                {\n                    Log.Error(&quot;Completed but Path &quot; &#43; path &#43; &quot; do not exist !!\\n&quot;);\n                }\n            });\n        });\n}\n</pre>\r\n<p>The code above may appear a bit daunting. However if you are familiar with the Rx grammer , then actually it is not. Instead of an intricate stateful workflow , we can relate the above scenario\r\n<strong>functionally</strong> such as we have a infinite set of timer events <strong>\r\ninput</strong> representing schdules which transforms into <strong>output</strong> at the time schedules as specified above and persisted into CSV files. The other matters like scheduling , async calls, error handling are all available out of box with Rx. All\r\n that we need to ensure in our design is that the workflow conforms with the Rx grammar. An Rx sequence follows up with zero or more\r\n<strong><em>OnNext</em></strong>and then ends up in either <strong><em>OnError</em>\r\n</strong>or <strong><em>OnCompleted</em></strong>. Grammatically this can be represented as</p>\r\n<pre>    sequence =&gt; {OnNext}{OnError || OnCompleted}\n</pre>\r\n<h3 style=\"text-align:left\"><span style=\"color:#ff9900\">Transformation</span></h3>\r\n<p>At the first stage we created a sequence of observable timer events. We will observe on these timer events to simulate the periodic schedules which are configurable as per specification 6.</p>\r\n<pre>    Observable.Interval(TimeSpan.FromMinutes(observationIntervalInMinutes), scheduler)\n</pre>\r\n<p>Next what we want is to <strong>Transform</strong> or <strong>project</strong> the timer schedule events into Observable list of Trades. The fact that the projection involves an\r\n<span style=\"color:#0000ff\">async</span> call and associated exception handling; is not much of a concern because unlike traditional try/catch (which cannot handle async exceptions) Rx is equipped with proper mechanism to handle async exceptions. As shown below\r\n<span style=\"color:#0000ff\">Observable</span>.<span style=\"color:#0000ff\">FromAsync</span> will neatly take care of converting the result into an observable sequence. You will also notice that the time is rolled over by the offset of the time Interval sequence\r\n multipled with schedule interval in minutes.</p>\r\n<pre>.Select(i =&gt;\n    {\n        dtrunDate = dtrunDate.AddMinutes((i &#43; 1) * observationIntervalInMinutes);\n        return Observable.FromAsync(() =&gt; svc.GetTradesAsync(dtrunDate));\n    })\n</pre>\r\n<p>The resultant trades are projected into the OnNext in Subscribe. It is to be noted that the transformed collection of trades are themselves Observable and any exceptions emanating from the source &quot;<span style=\"color:#0000ff\">Observable</span>.<span style=\"color:#0000ff\">FromAsync&quot;</span>\r\n will be observable through the trades observable &quot;m&quot; which is input to the Outer Timer sequence Subscribe.The exception is intercepted and we can continue to proceed to the next sequence value , by normally returning an\r\n<span style=\"color:#0000ff\">Observable.Empty.<span style=\"color:#333333\">We instead make another call to &quot;<span style=\"color:#0000ff\">Observable</span>.<span style=\"color:#0000ff\">FromAsync&quot;<span style=\"color:#333333\">, so as get trades incase of error or exception\r\n with the previous call. It is to be also noted that we apply a .Retry() which will infinitely try the source for successful list of Trades incase of previous error or exception</span></span></span></span></p>\r\n<pre>    m.Catch((PowerServiceException ex) =&gt;\n        {\n        Log.Error(string.Format(&quot;PowerServiceException  {0}&quot;, ex.Message));\n        return Observable.FromAsync(() =&gt; svc.GetTradesAsync(dtrunDate));\n    })\n    .Retry()\n</pre>\r\n<p>As you can see below we use <span style=\"color:#0000ff\">.SelectMany</span> to further flatten the projection and then group the sequence of trade collections by individual period and then summing up the volume specific to each period. This is very similar\r\n to Linq to Objects , but there is a subtle difference. Using Rx Linq Operators we are dealing with streams, while Linq Object to memory will lay out the whole set in memory. This difference will not be quite so obvious in this example, however there are cases\r\n where you are dealing with a huge set to memory say parsing a 100 gb file , this difference will become quite obvious with the side effects reflect onto the resource monitor. You further notice that we apply yet another\r\n<span style=\"color:#0000ff\">.Select</span> to project the grouped periods into sequence of period and sum of all volumes in that period {P,&sum;v}</p>\r\n<pre>    .SelectMany(t =&gt; t.SelectMany(x =&gt; x.Periods))\n    .GroupBy(g =&gt; g.Period)\n    .Select(p =&gt; new {Period = p.Key, Volume = p.Sum(_ =&gt; _.Volume)})\n</pre>\r\n<p>The notable thing about applying Rx Linq Operators and aggregate is the fact that once you have applied aggregate ; the result also transforms into Observable, such that to obtain the value of aggregate we have to apply yet another nested\r\n<span style=\"color:#0000ff\">.Subscribe<span style=\"color:#333333\"> . If you do not then Rx will lock. Is this a necessary\r\n<span style=\"color:#ff0000\">Evil</span> ? No absolutely not. This is how Rx breaks down parallel processing at granular level which allows the framework to handle very large blocks of memory into steaming frames where conventional Linq to Object will fail.</span></span>\r\n But just in case you feel the conventional Linq to object code is what makes things looks simpler then here is the code to\r\n<span style=\"color:#0000ff\">Subscribe</span> just below the <span style=\"color:#0000ff\">\r\n.Retry()</span></p>\r\n<pre>.Retry()\n.Subscribe(value =&gt;\n{\n    var powerPeriods = value.SelectMany(t =&gt; t.Periods).GroupBy(g =&gt; g.Period).Select(\n        s =&gt; new PowerPeriod\n        {\n            Period = s.Key,\n            Volume = s.Sum(_ =&gt; _.Volume)\n        });\n    foreach (var powerPeriod in powerPeriods)\n    {\n        sbpowerpositionLines.AppendLine(string.Format(&quot;{0},{1}&quot;,\n            dateTimeHelper.UtcIndexToLocalHourMap[powerPeriod.Period], powerPeriod.Volume));\n        Log.Info(string.Format(&quot;Period {0}, Volume {1}&quot;,\n            dateTimeHelper.UtcIndexToLocalHourMap[powerPeriod.Period],\n            powerPeriod.Volume));\n    }\n}\n</pre>\r\n<p>You will also notice that I'm using a DateTimeHelper to convert an UTC time index to localtime. Further this helper resets itself when the day rolls over and automatically readjusts its internal dictionary at 12:00am. This allows us one hour time before\r\n the clock shifts back or forth at Daylight saving start or end.</p>\r\n<pre>    .Subscribe(value =&gt;\n    {\n        value.Volume.Subscribe(volume =&gt;\n        {\n            sbpowerpositionLines.AppendLine(string.Format(&quot;{0},{1}&quot;,dateTimeHelper.UtcIndexToLocalHourMap[value.Period], volume));\n            Log.Info(string.Format(&quot;Period {0}, Volume {1}&quot;,value.Period,volume));\n        });\n    }\n</pre>\r\n<p>Below <span style=\"color:#0000ff\">async</span> delegate is the inner <span style=\"color:#0000ff\">\r\nOnComplete</span>. I have introduced a <span style=\"color:#008080\">StreamMode</span> enum primarily as a technique to assist in the unit testing. Clearly when I unit test , I do not want any flush into physical files , but rather to test if the inner\r\n<span style=\"color:#0000ff\">OnNext</span>computation has finally Completed with the expected output. Otherwise this is the logical place where all the concurrent operations on the sequence has converged and there is a guarantee from Rx that no other action\r\n is pending on the sequence.</p>\r\n<pre>    async () =&gt;\n    {\n        if (streamMode == StreamMode.StreamToMemory) return;\n        string path = Path.Combine(csvFilePath,&quot;PowerPosition&quot; &#43; dtrunDate.ToString(&quot;_yyyyMMdd_&quot;) &#43; DateTime.Now.ToString(&quot;HHmm&quot;) &#43; &quot;.csv&quot;);\n        if (Directory.Exists(csvFilePath))\n        {\n            using (var stream = new StreamWriter(path))\n            {\n                await stream.WriteAsync(sbpowerpositionLines.ToString());\n                await stream.FlushAsync();\n            }\n            Log.Info(&quot;Completed &quot; &#43; path &#43; &quot;\\n&quot;);\n        }\n        else\n        {\n            Log.Error(&quot;Completed but Path &quot; &#43; path &#43; &quot; do not exist !!\\n&quot;);\n        }\n    }\n</pre>\r\n<h2 style=\"text-align:left\"><span style=\"color:#ff9900\">Daylight Saving</span></h2>\r\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\">\r\n<tbody>\r\n<tr>\r\n<td align=\"center\">&lt;embed src=&quot;http://www.worldtimeserver.com/clocks/wtsclock001.swf?color=FF9900&amp;wtsid=GB&quot; type=&quot;application/x-shockwave-flash&quot; width=&quot;200&quot; height=&quot;200&quot; /&gt;</td>\r\n</tr>\r\n<tr>\r\n<td align=\"center\">\r\n<h2>London</h2>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 style=\"text-align:left\">&nbsp;</h2>\r\n<p>As the specification suggests the times are to be converted to local GMT Time Zone. Clearly this implies that on the daytime saving start the clock will shift forward by 1 hour as reflected below the time shows as 2:00am instead of 1:00am. Similarly on Daylight\r\n saving end date the clock will shift back by 1 hour exactly at 2:00am to 1:00am. This is also reflected in the report as below.</p>\r\n<table dir=\"rtl\" border=\"0\" width=\"100%\" cellspacing=\"0\" cellpadding=\"0\" style=\"border-collapse:collapse\">\r\n<tbody>\r\n<tr>\r\n<td dir=\"ltr\" align=\"right\" width=\"33%\">\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<th colspan=\"2\">Daylight Saving End <span style=\"color:#0000ff\">2:00am</span></th>\r\n</tr>\r\n<tr>\r\n<th>Period</th>\r\n<th>Volume</th>\r\n</tr>\r\n<tr>\r\n<td>23:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>00:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>01:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td><span style=\"color:#0000ff\">01:00</span></td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>02:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>03:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>04:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>05:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>..</td>\r\n<td>..</td>\r\n</tr>\r\n<tr>\r\n<td>20:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>21:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>22:00</td>\r\n<td>20</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</td>\r\n<td dir=\"ltr\" align=\"left\" width=\"33%\">\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<th colspan=\"2\">Daylight Saving Start <span style=\"color:#0000ff\">1:00am</span></th>\r\n</tr>\r\n<tr>\r\n<th>Period</th>\r\n<th>Volume</th>\r\n</tr>\r\n<tr>\r\n<td>23:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>00:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td><span style=\"color:#0000ff\">02:00</span></td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>03:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>04:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>05:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>06:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>07:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>..</td>\r\n<td>..</td>\r\n</tr>\r\n<tr>\r\n<td>19:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>20:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>21:00</td>\r\n<td>20</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</td>\r\n<td dir=\"ltr\" align=\"left\" width=\"33%\">\r\n<div>\r\n<table>\r\n<tbody>\r\n<tr>\r\n<th colspan=\"2\">Normal BST</th>\r\n</tr>\r\n<tr>\r\n<th>Period</th>\r\n<th>Volume</th>\r\n</tr>\r\n<tr>\r\n<td>23:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>00:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>01:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>02:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>03:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>04:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>05:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>06:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>..</td>\r\n<td>..</td>\r\n</tr>\r\n<tr>\r\n<td>20:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>21:00</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>22:00</td>\r\n<td>20</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 style=\"text-align:left\"><span style=\"color:#ff9900\">Unit Testing</span></h2>\r\n<p>Now we will look into aspects of Unit Testing. Although it might look quite daunting to starting with as to how to unit test nested functions and that too with sub levels running concurrently. But once you are used to the Rx Testing paradigm , testing these\r\n complex scenarios will appear as easy breeze. As you can see below the TestScheduler that Rx provides is the most important tool which allows us to advance time into a virtual dimension, thereby allowing us to perform the time based tests.</p>\r\n<pre>    [SetUp]\n    Setup()\n    {\n        _testScheduler = new TestScheduler();\n        _powerService  = new Mock();\n    }\n</pre>\r\n<h3 style=\"text-align:left\"><span style=\"color:#ff9900\">Aggregation Test</span></h3>\r\n<p>Here we test the basic functionality such as given two trades , we have an expected output. As you can see below that we have faked the GetTradesAsync to return a task from a completed task. Next we plug the faked powerservice source and advance the timer\r\n of the injected scheduler into the virtual time dimension. This will in effect fire up the nested timer based events. We test that given two trades should result as below</p>\r\n<pre>{T1[ {1,20} , {2,30} , {3,40}] , T2[ {1,20} , {2,30} , {3,40}] } =&gt; R[{&quot;23:00&quot;,40},{&quot;00:00&quot;,60},{&quot;01:00&quot;,80}]\n</pre>\r\n<pre>[Test]\npublic void Should_Flatten_Trades_And_Aggregate_Periods_Per_Hour_LocalTime()\n{\n    //Arrange\n    var intradayReporter = new IntraDayReporter();\n    _powerService.Setup(p =&gt; p.GetTradesAsync(It.IsAny()))\n    .Returns(\n        Task.FromResult(CreateMockPowerTrades(It.IsAny(), 2,new[]{\n                        new PowerPeriod { Period = 1, Volume = 20 },\n                        new PowerPeriod { Period = 2, Volume = 30 },\n                        new PowerPeriod { Period = 3, Volume = 40 }}\n                        )));\n        DateTime date = DateTime.ParseExact( &quot;2011/03/28 10:42:33&quot;, &quot;yyyy/MM/dd HH:mm:ss&quot;, CultureInfo.InvariantCulture);\n        StringBuilder sb = new StringBuilder();\n        TimeZoneInfo gmtTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById(&quot;GMT Standard Time&quot;);\n        const string expected = &quot;Local Time,Volume\\r\\n23:00,40\\r\\n00:00,60\\r\\n01:00,80\\r\\n&quot;;\n    //Act\n    intradayReporter.Run1(_powerService.Object, _testScheduler, date, gmtTimeZoneInfo, 1, sb, It.IsAny(), IntraDayReporter.StreamMode.StreamToMemory);\n    _testScheduler.AdvanceBy(TimeSpan.FromMinutes(1).Ticks);\n    var actual = sb.ToString();\n    //Assert\n    Assert.AreEqual(expected,actual);\n}\n</pre>\r\n<h3 style=\"text-align:left\"><span style=\"color:#ff9900\">Exception Handling Test</span></h3>\r\n<p>We will further see the amazing ability that Rx Test Framework in conjunction with MoQ framework which allows us to test complex concurrent time based workflow sequence which otherwise would have been near impossible. What you see below is MOQ setup to return\r\n in sequence an exception, then a sequence of trades and subsequently another set of trades. You will note that once the exception occurs normaly Rx will result in OnError, however we catch the exception and then return the result of an instantaneous call to\r\n GetTrades rather than awaiting for the next schedule. This way we are able to meet the requirement 7 as to not acceptable to miss a scheduled extract. Hence we see that despite exception thrown by GetTrades we are see the expected result matching the subsequent\r\n call tp GetTrades. When we later advance the Time by next schedule we see the next set of results matching thereby proving that earlier exception did not terminate the outer interval sequence.</p>\r\n<pre>[Test]\npublic void Should_RetryOnException_And_Then_Continue_NextSchedule()\n{\n    //Arrange\n    _retryCount = 0;\n    var intradayReporter = new IntraDayReporter();\n    _powerService.SetupSequence(p =&gt; p.GetTradesAsync(It.IsAny()))\n        .Throws(new PowerServiceException(&quot;Thrown from Unit Test&quot;))\n        .Returns(\n            Task.FromResult(CreateMockPowerTrades(It.IsAny(), 2, new[]{\n                            new PowerPeriod { Period = 1, Volume = 20 },\n                            new PowerPeriod { Period = 2, Volume = 30 },\n                            new PowerPeriod { Period = 3, Volume = 40 }}\n                            )))\n        .Returns(\n            Task.FromResult(CreateMockPowerTrades(It.IsAny(), 3, new[]{\n                            new PowerPeriod { Period = 1, Volume = 10 },\n                            new PowerPeriod { Period = 2, Volume = 10 },\n                            new PowerPeriod { Period = 3, Volume = 10 }}\n                            )));\n    DateTime date = DateTime.ParseExact(&quot;2011/03/28 10:42:33&quot;, &quot;yyyy/MM/dd HH:mm:ss&quot;, CultureInfo.InvariantCulture);\n    StringBuilder sb = new StringBuilder();\n    TimeZoneInfo gmtTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById(&quot;GMT Standard Time&quot;);\n    const string expectedfirst = &quot;Local Time,Volume\\r\\n23:00,40\\r\\n00:00,60\\r\\n01:00,80\\r\\n&quot;;\n    const string expectedsecond = &quot;Local Time,Volume\\r\\n23:00,30\\r\\n00:00,30\\r\\n01:00,30\\r\\n&quot;;\n    //Act\n    intradayReporter.Run1(_powerService.Object, _testScheduler, date, gmtTimeZoneInfo, 1, sb, It.IsAny(), IntraDayReporter.StreamMode.StreamToMemory);\n    _testScheduler.AdvanceBy(TimeSpan.FromMinutes(1).Ticks);\n    var actual = sb.ToString();\n    //Assert\n    Assert.AreEqual(expectedfirst, actual);\n    //Act\n    /*Advance Virtual time to next schedule */\n    _testScheduler.AdvanceBy(TimeSpan.FromMinutes(1).Ticks);\n    actual = sb.ToString();\n    //Assert\n    Assert.AreEqual(expectedsecond, actual);\n}\n</pre>\r\n<h3 style=\"text-align:left\"><span style=\"color:#ff9900\">Daylight Saving Start Test</span></h3>\r\n<p>In this test we have chosen a date 29<sup>th</sup>March 2015, which is the start of Daylight saving. As because the time shifts forward by 1 hour at 1:00am in BST timezone; we will have total of 23 hours inbetween 11:00pm 28<sup>th</sup>March 2015 and 29<sup>th</sup>March\r\n 2015 instead of normal 24 hours. Now that the result is expected in Localtime we will need to show hour &quot;03:00&quot; for the period id 3. This will indicate that the dateTimeHelper class is resetting the hour dictionary correctly. It is to be noted that DayLightHelper\r\n attempts to resets its internal dictionary whenever the day rolls over incase the day falls in daylightsaving for the given timezone.</p>\r\n<pre>[Test]\npublic void Should_Handle_24HRPreviouDay_to_22HRCurrentDay_LocalTimeOn_DaylightSaving_Start()\n{\n    //Arrange\n    var intradayReporter = new IntraDayReporter();\n    _powerService.Setup(p =&gt; p.GetTradesAsync(It.IsAny()))\n        .Returns(\n        Task.FromResult(CreateMockPowerTrades(It.IsAny(), 2, new[]{\n                        new PowerPeriod { Period = 1, Volume = 10 },\n                        new PowerPeriod { Period = 2, Volume = 10 },\n                        new PowerPeriod { Period = 3, Volume = 10 },\n                        new PowerPeriod { Period = 4, Volume = 10 },\n                        new PowerPeriod { Period = 5, Volume = 10 },\n                        new PowerPeriod { Period = 6, Volume = 10 },\n                        new PowerPeriod { Period = 7, Volume = 10 },\n                        new PowerPeriod { Period = 8, Volume = 10 },\n                        new PowerPeriod { Period = 9, Volume = 10 },\n                        new PowerPeriod { Period = 10, Volume = 10 },\n                        new PowerPeriod { Period = 11, Volume = 10 },\n                        new PowerPeriod { Period = 12, Volume = 10 },\n                        new PowerPeriod { Period = 13, Volume = 10 },\n                        new PowerPeriod { Period = 14, Volume = 10 },\n                        new PowerPeriod { Period = 15, Volume = 10 },\n                        new PowerPeriod { Period = 16, Volume = 10 },\n                        new PowerPeriod { Period = 17, Volume = 10 },\n                        new PowerPeriod { Period = 18, Volume = 10 },\n                        new PowerPeriod { Period = 19, Volume = 10 },\n                        new PowerPeriod { Period = 20, Volume = 10 },\n                        new PowerPeriod { Period = 21, Volume = 10 },\n                        new PowerPeriod { Period = 22, Volume = 10 }}\n                        )));\n    DateTime date = DateTime.ParseExact(&quot;2015/03/29&quot;, &quot;yyyy/MM/dd&quot;, CultureInfo.InvariantCulture);\n    StringBuilder sb = new StringBuilder();\n    TimeZoneInfo gmtTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById(&quot;GMT Standard Time&quot;);\n    const string expected = &quot;Local Time,Volume\\r\\n23:00,20\\r\\n00:00,20\\r\\n02:00,20\\r\\n03:00,20\\r\\n04:00,20\\r\\n05:00,20\\r\\n06:00,20\\r\\n07:00,20\\r\\n08:00,20\\r\\n09:00,20\\r\\n10:00,20\\r\\n11:00,20\\r\\n12:00,20\\r\\n13:00,20\\r\\n14:00,20\\r\\n15:00,20\\r\\n16:00,20\\r\\n17:00,20\\r\\n18:00,20\\r\\n19:00,20\\r\\n20:00,20\\r\\n21:00,20\\r\\n&quot;;\n    //Act\n    intradayReporter.Run1(_powerService.Object, _testScheduler, date, gmtTimeZoneInfo, 1, sb, It.IsAny(), IntraDayReporter.StreamMode.StreamToMemory);\n    _testScheduler.AdvanceBy(TimeSpan.FromMinutes(1).Ticks);\n    var actual = sb.ToString();\n    //Assert\n    Assert.AreEqual(expected, actual);           \n}\n</pre>\r\n<h3 style=\"text-align:left\"><span style=\"color:#ff9900\">Daylight Saving End Test</span></h3>\r\n<p>Similarly we check the scenario such that the during the DayLight Saving end, exactly at 2:00am , the clock turns back by one hour and become 1:00am. Clearly we will have 25 UTC hours between 23:00am previous day and current day 23:00 hr for this specific\r\n day. This can be tested similary like above.</p>\r\n<pre>[Test]\npublic void Should_Handle_24HRPreviouDay_to_25HRCurrentDay_LocalTimeOn_DaylightSaving_End()\n{\n    //Arrange\n    var intradayReporter = new IntraDayReporter();\n    _powerService.Setup(p =&gt; p.GetTradesAsync(It.IsAny()))\n        .Returns(\n        Task.FromResult(CreateMockPowerTrades(It.IsAny(), 2, new[]{\n                                        new PowerPeriod { Period = 1, Volume = 10 },\n                                        new PowerPeriod { Period = 2, Volume = 10 },\n                                        new PowerPeriod { Period = 3, Volume = 10 },\n                                        new PowerPeriod { Period = 4, Volume = 10 },\n                                        new PowerPeriod { Period = 5, Volume = 10 },\n                                        new PowerPeriod { Period = 6, Volume = 10 },\n                                        new PowerPeriod { Period = 7, Volume = 10 },\n                                        new PowerPeriod { Period = 8, Volume = 10 },\n                                        new PowerPeriod { Period = 9, Volume = 10 },\n                                        new PowerPeriod { Period = 10, Volume = 10 },\n                                        new PowerPeriod { Period = 11, Volume = 10 },\n                                        new PowerPeriod { Period = 12, Volume = 10 },\n                                        new PowerPeriod { Period = 13, Volume = 10 },\n                                        new PowerPeriod { Period = 14, Volume = 10 },\n                                        new PowerPeriod { Period = 15, Volume = 10 },\n                                        new PowerPeriod { Period = 16, Volume = 10 },\n                                        new PowerPeriod { Period = 17, Volume = 10 },\n                                        new PowerPeriod { Period = 18, Volume = 10 },\n                                        new PowerPeriod { Period = 19, Volume = 10 },\n                                        new PowerPeriod { Period = 20, Volume = 10 },\n                                        new PowerPeriod { Period = 21, Volume = 10 },\n                                        new PowerPeriod { Period = 22, Volume = 10 },\n                                        new PowerPeriod { Period = 23, Volume = 10 },\n                                        new PowerPeriod { Period = 24, Volume = 10 },\n                                        new PowerPeriod { Period = 25, Volume = 10 }}\n                                        )));\n    DateTime date = DateTime.ParseExact(&quot;2015/10/25&quot;, &quot;yyyy/MM/dd&quot;, CultureInfo.InvariantCulture);\n    StringBuilder sb = new StringBuilder();\n    TimeZoneInfo gmtTimeZoneInfo = TimeZoneInfo.FindSystemTimeZoneById(&quot;GMT Standard Time&quot;);\n    const string expected =\n        &quot;Local Time,Volume\\r\\n23:00,20\\r\\n00:00,20\\r\\n01:00,20\\r\\n01:00,20\\r\\n02:00,20\\r\\n03:00,20\\r\\n04:00,20\\r\\n05:00,20\\r\\n06:00,20\\r\\n07:00,20\\r\\n08:00,20\\r\\n09:00,20\\r\\n10:00,20\\r\\n11:00,20\\r\\n12:00,20\\r\\n13:00,20\\r\\n14:00,20\\r\\n15:00,20\\r\\n16:00,20\\r\\n17:00,20\\r\\n18:00,20\\r\\n19:00,20\\r\\n20:00,20\\r\\n21:00,20\\r\\n22:00,20\\r\\n&quot;;\n\n    //Act\n    intradayReporter.Run(_powerService.Object, _testScheduler, date, gmtTimeZoneInfo, 1, sb, It.IsAny(), IntraDayReporter.StreamMode.StreamToMemory);\n    _testScheduler.AdvanceBy(TimeSpan.FromMinutes(1).Ticks);\n    var actual = sb.ToString();\n\n    //Assert\n    Assert.AreEqual(expected, actual);\n}\n</pre>\r\n<h3 style=\"text-align:left\"><span style=\"color:#ff9900\">DateTimeHelper Internal Dictionary Reset Test</span></h3>\r\n<p>The specification requires the results to be in the Local Time. Clearly as we would be getting the hour offset in UTC, we will need a mechanism to convert the UTC timeoffset to a valid Local time. Also this is a functionality which can be separated from\r\n the core functionality above in line with the first principle of solid design which is separation of concern. As you will notice that each timer event offsets the time that this process has started on. The offseted time is input to the PowerService so that\r\n it can pull the correct Trades specific to the date. So for the sake of our testing there are two times which are of interest to us. These are 1:00 am on the Daylight Saving start and 2:00 am on the Daylight Saving End. At these times the Local time wiill\r\n change and hence to provide the correct local time the internal dictionary has to change which is facilitate on the DayLightHelper instance through the\r\n<span style=\"color:#0000ff\">.Reset()</span> extension method.</p>\r\n<pre>[Test]\npublic void DateTimeHelperDayRollOver1AM_OnDaylightSavingStart()\n{\n    //Arrange\n    var dateStart = DateTime.ParseExact(&quot;2015/03/28 23:30&quot;, &quot;yyyy/MM/dd HH:mm&quot;, CultureInfo.InvariantCulture);\n    var dateRollOverPre1am = DateTime.ParseExact(&quot;2015/03/29&quot;, &quot;yyyy/MM/dd&quot;, CultureInfo.InvariantCulture);\n    var dateRollOverpsot1am = DateTime.ParseExact(&quot;2015/03/29 01:00&quot;, &quot;yyyy/MM/dd HH:mm&quot;, CultureInfo.InvariantCulture);\n    var dateTimeHelper = new DateTimeHelper(dateStart, TimeZoneInfo.FindSystemTimeZoneById(&quot;GMT Standard Time&quot;));\n    var expectedReset = new Dictionary&lt;int, string&gt;\n    {\n        {1, &quot;23:00&quot;},{2,&quot;00:00&quot;},{3, &quot;01:00&quot;},{4,&quot;02:00&quot;},{5, &quot;03:00&quot;},{6,&quot;04:00&quot;},\n        {7, &quot;05:00&quot;},{8,&quot;06:00&quot;},{9, &quot;07:00&quot;},{10,&quot;08:00&quot;},{11, &quot;09:00&quot;},{12,&quot;10:00&quot;},\n        {13,&quot;11:00&quot;},{14,&quot;12:00&quot;},{15, &quot;13:00&quot;},{16,&quot;14:00&quot;},{17, &quot;15:00&quot;},{18,&quot;16:00&quot;},\n        {19,&quot;17:00&quot;},{20,&quot;18:00&quot;},{21, &quot;19:00&quot;},{22,&quot;20:00&quot;},{23, &quot;21:00&quot;},{24,&quot;22:00&quot;}\n    };\n\n    var expectedReset1 = new Dictionary&lt;int, string&gt;\n    {\n        {1, &quot;23:00&quot;},{2,&quot;00:00&quot;},{3, &quot;02:00&quot;},{4,&quot;03:00&quot;},{5, &quot;04:00&quot;},{6,&quot;05:00&quot;},\n        {7, &quot;06:00&quot;},{8,&quot;07:00&quot;},{9, &quot;08:00&quot;},{10,&quot;09:00&quot;},{11, &quot;10:00&quot;},{12,&quot;11:00&quot;},\n        {13,&quot;12:00&quot;},{14,&quot;13:00&quot;},{15, &quot;14:00&quot;},{16,&quot;15:00&quot;},{17, &quot;16:00&quot;},{18,&quot;17:00&quot;},\n        {19,&quot;18:00&quot;},{20,&quot;19:00&quot;},{21, &quot;20:00&quot;},{22,&quot;21:00&quot;},{23, &quot;22:00&quot;}\n    };\n\n    //Act\n    var dateTimeHelperReset = dateTimeHelper.Reset(dateRollOverPre1am,\n        TimeZoneInfo.FindSystemTimeZoneById(&quot;GMT Standard Time&quot;));\n\n    //Assert\n    CollectionAssert.AreEquivalent(expectedReset,dateTimeHelperReset.UtcIndexToLocalHourMap);\n\n    var dateTimeHelperReset1 = dateTimeHelperReset.Reset(dateRollOverpsot1am,\n        TimeZoneInfo.FindSystemTimeZoneById(&quot;GMT Standard Time&quot;));\n\n    //Assert\n    CollectionAssert.AreEquivalent(expectedReset1, dateTimeHelperReset1.UtcIndexToLocalHourMap);\n\n}\n</pre>\r\n<pre>[Test]\npublic void DateTimeHelperDayRollOver2AM_OnDaylightSavingEnd()\n{\n    //Arrange\n    var dateStart = DateTime.ParseExact(&quot;2015/10/24 23:30&quot;, &quot;yyyy/MM/dd HH:mm&quot;, CultureInfo.InvariantCulture);\n    var dateRollOverPre2am = DateTime.ParseExact(&quot;2015/10/25&quot;, &quot;yyyy/MM/dd&quot;, CultureInfo.InvariantCulture);\n    var dateRollOverpsot2am = DateTime.ParseExact(&quot;2015/10/25 02:00&quot;, &quot;yyyy/MM/dd HH:mm&quot;, CultureInfo.InvariantCulture);\n    var dateTimeHelper = new DateTimeHelper(dateStart, TimeZoneInfo.FindSystemTimeZoneById(&quot;GMT Standard Time&quot;));\n    var expectedReset = new Dictionary&lt;int, string&gt;\n    {\n        {1, &quot;23:00&quot;},{2,&quot;00:00&quot;},{3, &quot;01:00&quot;},{4,&quot;02:00&quot;},{5, &quot;03:00&quot;},{6,&quot;04:00&quot;},\n        {7, &quot;05:00&quot;},{8,&quot;06:00&quot;},{9, &quot;07:00&quot;},{10,&quot;08:00&quot;},{11, &quot;09:00&quot;},{12,&quot;10:00&quot;},\n        {13,&quot;11:00&quot;},{14,&quot;12:00&quot;},{15, &quot;13:00&quot;},{16,&quot;14:00&quot;},{17, &quot;15:00&quot;},{18,&quot;16:00&quot;},\n        {19,&quot;17:00&quot;},{20,&quot;18:00&quot;},{21, &quot;19:00&quot;},{22,&quot;20:00&quot;},{23, &quot;21:00&quot;},{24,&quot;22:00&quot;}\n    };\n\n    var expectedReset1 = new Dictionary&lt;int, string&gt;\n    {\n        {1, &quot;23:00&quot;},{2,&quot;00:00&quot;},{3, &quot;01:00&quot;},{4,&quot;01:00&quot;},{5, &quot;02:00&quot;},{6,&quot;03:00&quot;},\n        {7, &quot;04:00&quot;},{8,&quot;05:00&quot;},{9, &quot;06:00&quot;},{10,&quot;07:00&quot;},{11, &quot;08:00&quot;},{12,&quot;09:00&quot;},\n        {13,&quot;10:00&quot;},{14,&quot;11:00&quot;},{15, &quot;12:00&quot;},{16,&quot;13:00&quot;},{17, &quot;14:00&quot;},{18,&quot;15:00&quot;},\n        {19,&quot;16:00&quot;},{20,&quot;17:00&quot;},{21, &quot;18:00&quot;},{22,&quot;19:00&quot;},{23, &quot;20:00&quot;},{24,&quot;21:00&quot;},\n        {25,&quot;22:00&quot;}\n    };\n\n    //Act\n    var dateTimeHelperReset = dateTimeHelper.Reset(dateRollOverPre2am,\n        TimeZoneInfo.FindSystemTimeZoneById(&quot;GMT Standard Time&quot;));\n\n    //Assert\n    CollectionAssert.AreEquivalent(expectedReset, dateTimeHelperReset.UtcIndexToLocalHourMap);\n\n    var dateTimeHelperReset1 = dateTimeHelperReset.Reset(dateRollOverpsot2am,\n        TimeZoneInfo.FindSystemTimeZoneById(&quot;GMT Standard Time&quot;));\n\n    //Assert\n    CollectionAssert.AreEquivalent(expectedReset1, dateTimeHelperReset1.UtcIndexToLocalHourMap);\n\n}\n</pre>\r\n<h3 style=\"text-align:left\"><span style=\"color:#ff9900\">The Test Results are below</span></h3>\r\n<p><a href=\"http://www.alanaamy.net/wp-content/uploads/2015/07/RxTimedWindowTests.png\"><img src=\"http://www.alanaamy.net/wp-content/uploads/2015/07/RxTimedWindowTests.png\" alt=\"RxTimedWindowTests\" width=\"736\" height=\"299\"></a></p>\r\n<h3 style=\"text-align:left\"><span style=\"color:#ff9900\">Installation</span></h3>\r\n<p>Installation is quite simple for Windows services and can vbe done like below</p>\r\n<pre>installutil /LogFile=svcinstalllog.txt AlanAamy.Net.RxTimedWindow.Service.exe\n</pre>\r\n<h3 style=\"text-align:left\"><span style=\"color:#ff9900\">Console based Debugging</span></h3>\r\n<p>Services can be tweaked to run in console mode and that is quite simple to do regular integration testing , once when the unit tests are all done. You can debug the same service in console mode using command parameter -console in debug. I'll keave this for\r\n you to explore in the code. But the results can be see bu configuring the Log4net to flush to the console as you can see the results below.\r\n<a href=\"http://www.alanaamy.net/wp-content/uploads/2015/07/RxTimedWindowErrors.png\">\r\n<img src=\"http://www.alanaamy.net/wp-content/uploads/2015/07/RxTimedWindowErrors.png\" alt=\"RxTimedWindowErrors\" width=\"1104\" height=\"648\"></a></p>\r\n<h3 style=\"text-align:left\"><span style=\"color:#ff9900\">Performance</span></h3>\r\n<p>The memory usage graph shows no steps in the private memory. This clearly indicates no memory leak albeit the snapshot window below is less. The CPU usage in a multi-core machine will show uniform distribution of load across the CPU clearly eliminating CPU\r\n affinity issues which in traditional thread programming would not take care of these issue without you writing quite an extra amount of code.\r\n<a href=\"http://www.alanaamy.net/wp-content/uploads/2015/07/RxTimedWindowTestsMemory.png\">\r\n<img src=\"http://www.alanaamy.net/wp-content/uploads/2015/07/RxTimedWindowTestsMemory.png\" alt=\"RxTimedWindowTestsMemory\" width=\"577\" height=\"424\"></a></p>\r\n<h3 style=\"text-align:left\"><span style=\"color:#ff9900\">Building From Source</span></h3>\r\n<ol>\r\n<li>\r\n<p>Move to your local git repository directory or any directory (with git init) in console.</p>\r\n</li><li>\r\n<p>Clone repository.</p>\r\n<pre>                <code>git clone https://github.com/arupalan/RxTimedWindow.git</code>\n            </pre>\r\n</li><li>\r\n<p>Move to source directory, update submodule and build.</p>\r\n<pre>                <code>  cd AlanAamy.Net.RxTimedWindow/\n                        git submodule update --init --recursive\n                        msbuild\n                </code>\n            </pre>\r\n</li></ol>\r\n</div><div class=\"ClearBoth\"></div>",
  "TagList": "",
  "LastEdited": "2015-07-05T03:03:44.61-07:00"
}