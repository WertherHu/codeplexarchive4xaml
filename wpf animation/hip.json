{
  "ProjectName": "hip",
  "Title": "Human Interface Project",
  "Description": "The Human Interface Project (HIP) is a tiny library for the .NET platform and Windows Presentation Foundation (WPF) aimed at making complex and/or mundane operations simple and elegant, for both end-users and developers.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><b>Project Description</b><br />The Human Interface Project &#40;HIP&#41; is a tiny library for the .NET platform and Windows Presentation Foundation &#40;WPF&#41; aimed at making complex and&#47;or mundane operations simple and elegant, for both end-users and developers.<br />\n<h2>hip:Link</h2>\r\nhip:Link is the first component to be released as part of the Human Interface Project. It allows developers to construct complex dynamic bindings in a simple and familiar manner similar to that of events: you define a method or property in your code-behind and hip:Link will apply the result to a property you target in XAML, automatically re-evaluating it when its dependencies change. Dependencies are specified by the use of code-side attributes, meaning they are always right beside the definition, making it easy to see and verify what dependencies exist, unlike traditional WPF bindings in which the converter and converter parameters are defined in separate locations.<br /><br />Here&#39;s an example of what you can do with hip:Link:<br /><br /><i><b>XAML:</b></i><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">&lt;</span><span style=\"color:#A31515;\">TextBlock</span>\n    <span style=\"color:Red;\">x:Name</span><span style=\"color:Blue;\">=</span><span style=\"color:Black;\">&quot;</span><span style=\"color:Blue;\">Title</span><span style=\"color:Black;\">&quot;</span>\n    <span style=\"color:Red;\">Text</span><span style=\"color:Blue;\">=</span><span style=\"color:Black;\">&quot;</span><span style=\"color:Blue;\">{hip:Link}</span><span style=\"color:Black;\">&quot;</span> <span style=\"color:Blue;\">/&gt;</span>\r\n</pre></div><br /><i><b>C#:</b></i><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n[DependsOn( <span style=\"color:#A31515;\">&quot;this.Title&quot;</span> )]\n[DependsOn( <span style=\"color:#A31515;\">&quot;this.Editable&quot;</span> )]\n<span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">string</span> Title_Text {\n    <span style=\"color:Blue;\">get</span> {\n        <span style=\"color:Blue;\">if</span> ( !String.IsNullOrEmpty( <span style=\"color:Blue;\">this</span>.Title ) )\n            <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">this</span>.Title.Trim();\n        <span style=\"color:Blue;\">else</span> <span style=\"color:Blue;\">if</span> ( <span style=\"color:Blue;\">this</span>.Editable )\n            <span style=\"color:Blue;\">return</span> <span style=\"color:#A31515;\">&quot;Click to add a title.&quot;</span>;\n        <span style=\"color:Blue;\">else</span>\n            <span style=\"color:Blue;\">return</span> <span style=\"color:#A31515;\">&quot;Untitled&quot;</span>;\n    }\n}\r\n</pre></div><br />One of the goals of hip:Link is to make the assignment of arbitrarily-complex definitions to properties in XAML as simple and concise as possible. The above example uses hip:Link&#39;s default naming convention, which is based on the assigned name of the target element (&quot;Title&quot;) and the name of the property being set (&quot;Text&quot;). You can also explicitly specify the name of an existing property or parameterless method as the default (unnamed) parameter of the hip:Link directive. These identifiers point to members in the codebehind file corresponding to the xaml file the directive is used in:<br /><br /><i><b>MyControl.xaml:</b></i><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">&lt;</span><span style=\"color:#A31515;\">TextBlock</span>\n    <span style=\"color:Red;\">Text</span><span style=\"color:Blue;\">=</span><span style=\"color:Black;\">&quot;</span><span style=\"color:Blue;\">{hip:Link GetTitle}</span><span style=\"color:Black;\">&quot;</span> <span style=\"color:Blue;\">/&gt;</span>\r\n</pre></div><br /><i><b>MyControl.xaml.cs:</b></i><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">string</span> GetTitle() {\n    <span style=\"color:Blue;\">return</span> <span style=\"color:#A31515;\">&quot;I am a title with no dependencies!&quot;</span>;\n}\r\n</pre></div><br />Note also that hip:Link supports private members, so your class can remain clean and tidy to the outside even if it has lots of hip:Link definitions.<br />\n<h3>Two-way bindings</h3>\r\nTwo-way binding (i.e. propagating changes back to dependencies) is supported automatically when you link to a property (the associated property setter is used if it exists). For methods and properties without an associated setter, an explicit &quot;setback&quot; method or property can be specified, which represents either a method that accepts a single &#39;object&#39; parameter, or another property that has a setter. This is provided by the SetBack attribute:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">&lt;</span><span style=\"color:#A31515;\">TextBox</span> <span style=\"color:Red;\">Text</span><span style=\"color:Blue;\">=</span><span style=\"color:Black;\">&quot;</span><span style=\"color:Blue;\">{hip:Link GetTitle, SetBack=SetTitle}</span><span style=\"color:Black;\">&quot;</span> <span style=\"color:Blue;\">/&gt;</span>\r\n</pre></div><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">void</span> SetTitle( <span style=\"color:Blue;\">object</span> title ) {\n    <span style=\"color:Blue;\">this</span>.Title = (<span style=\"color:Blue;\">string</span>)title;\n}\r\n</pre></div><br />Setback methods do not require DependsOn attributes because they do not directly affect the evaluation of the definition, and any changes they make to other dependencies should initiate the proper updates themselves (see <i>Property change notifications</i> below).<br />\n<h3>Dependencies</h3>\r\nThe magic of hip:Link comes from its ability to automatically re-evaluate a property definition when any of its declared dependencies change. In general, a dependency is any object or property mentioned within the body of a definition that a) is capable of changing, and b) affects the result of the definition. Pretty much every definition will have at least one dependency (if it doesn&#39;t, you can probably just declare the value of the property statically). Consider the following example:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">&lt;</span><span style=\"color:#A31515;\">TextBlock</span>\n    <span style=\"color:Red;\">x:Name</span><span style=\"color:Blue;\">=</span><span style=\"color:Black;\">&quot;</span><span style=\"color:Blue;\">Title</span><span style=\"color:Black;\">&quot;</span>\n    <span style=\"color:Red;\">Text</span><span style=\"color:Blue;\">=</span><span style=\"color:Black;\">&quot;</span><span style=\"color:Blue;\">{hip:Link}</span><span style=\"color:Black;\">&quot;</span>\n    <span style=\"color:Red;\">Foreground</span><span style=\"color:Blue;\">=</span><span style=\"color:Black;\">&quot;</span><span style=\"color:Blue;\">{hip:Link GetTitleColor}</span><span style=\"color:Black;\">&quot;</span> <span style=\"color:Blue;\">/&gt;</span>\r\n</pre></div><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">public</span> Brush GetTitleColor() {\n    <span style=\"color:Blue;\">if</span> ( <span style=\"color:Blue;\">this</span>.IsTitleInvalid )\n        <span style=\"color:Blue;\">return</span> Brushes.Red;\n    <span style=\"color:Blue;\">else</span>\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">new</span> BrushConverter().ConvertFromString( Settings.Default.TitleColor );\n}\r\n</pre></div><br />In this small method we are determining which color the Title TextBlock should have. We base this decision on a simple rule: if the title is &quot;invalid&quot; (whatever we may choose that to mean), color it red; otherwise, color it according to the user&#39;s established preference. This method has two direct dependencies: the local IsTitleInvalid property, and the TitleColor application setting. To tell hip:Link about these dependencies, we attach two DependsOn attributes to the method, like so:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n[DependsOn( <span style=\"color:#A31515;\">&quot;this.IsTitleInvalid&quot;</span> )]\n[DependsOn( <span style=\"color:#A31515;\">&quot;settings.TitleColor&quot;</span> )]\n<span style=\"color:Blue;\">public</span> Brush GetTitleColor() {\n    <span style=\"color:Blue;\">if</span> ( <span style=\"color:Blue;\">this</span>.IsTitleInvalid )\n        <span style=\"color:Blue;\">return</span> Brushes.Red;\n    <span style=\"color:Blue;\">else</span>\n        <span style=\"color:Blue;\">return</span> <span style=\"color:Blue;\">new</span> BrushConverter().ConvertFromString( Settings.Default.TitleColor );\n}\r\n</pre></div><br />Now when either of those dependencies change, <i>GetTitleColor</i> will be re-evaluated and the <i>Foreground</i> property of the title TextBlock will be updated to reflect the new value. (See below for information on the &quot;settings&quot; dependency target.)<br /><br />The first part of the dependency identifier is the dependency target (see <i>Dependency targets</i> below) and represents the source of the underlying binding. Everything following the first dot identifies the path to the dependency, relative to the source. In the simplest scenarios this will just be the name of the property you are identifying, however, since this string actually represents the Path property of the underlying binding, you can take advantage of WPF&#39;s advanced path syntax to identify subproperties, attached properties, indexes, and so on. Read more about WPF Path syntax <a href=\"http://msdn.microsoft.com/en-us/library/system.windows.data.binding.path.aspx\">here</a>.<br />\n<h3>Property change notifications</h3>\r\nhip:Link piggybacks on WPF&#39;s existing databinding engine to handle dependency changes and re-evaluations. This means that out of the box, hip:Link will support two kinds of property change notifications: DependencyProperties and INotifyPropertyChanged. What this means is if the dependency you are identifying is already a DependencyProperty, it automatically supports change notifications and will work automatically. If the property you are identifying as a dependency is not a DependencyProperty, the class that contains it must implement <a href=\"http://msdn.microsoft.com/en-us/library/system.componentmodel.inotifypropertychanged.aspx\">INotifyPropertyChanged</a> and signal when the property changes.<br /><br />This is generally very simple to do, and can be automated with the wonderful <a href=\"http://moxaml.codeplex.com/\">MoXAML Power Toys</a> by Pete O&#39;Hanlon. You can read more implementing INotifyPropertyChanged <a href=\"http://msdn.microsoft.com/en-us/library/ms743695.aspx\">here</a>.<br />\n<h3>Dependency targets</h3>\r\nhip:Link supports three built-in target types for specifying dependencies: <i>this</i>, <i>target</i>, and <i>context</i>. These are defined as follows:<br /><br /><i><b>this:</b></i><br />This represents the current instance of the root element of the file, and is analogous to the &#39;this&#39; keyword in the codebehind file. For example, if you are defining a custom UserControl called ClockEditor, &quot;this&quot; refers to the instance of ClockEditor the link is defined within.<br /><br /><i><b>target:</b></i><br />The target represents the element that hosts the property being defined. In the above examples, this would be the &#39;TextBlock&#39; or &#39;TextBox&#39;. You can use this target to define dependencies analogous to the {RelativeSource Self} directive.<br /><br /><i><b>context:</b></i><br />The context represents the current inherited DataContext for the target element. DataContexts are used extensively in binding to provide an inherited context that applies to an entire scope of child elements in XAML. Read more about DataContext <a href=\"http://msdn.microsoft.com/en-us/library/system.windows.frameworkelement.datacontext.aspx\">here</a>. <i>You can even set the DataContext on elements using a hip:Link declaration!</i><br />\n<h3>Adding custom targets</h3>\r\nhip:Link also supports the ability to add or remove custom dependency targets that work on a global scale throughout your application:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">static</span> ClockEditor() {\n    Hip.LinkExtension.AddTarget( <span style=\"color:#A31515;\">&quot;settings&quot;</span>, Properties.Settings.Default );\n}\r\n</pre></div><br />This allows you to add dependencies for properties in that object:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\n[DependsOn( <span style=\"color:#A31515;\">&quot;settings.Use24HourClock&quot;</span> )]\n<span style=\"color:Blue;\">private</span> <span style=\"color:Blue;\">string</span> Hours_Text {\n    <span style=\"color:Blue;\">get</span> {\n        ...\n    }\n}\r\n</pre></div>\n<h2>Requirements</h2>\r\nhip:Link is made possible thanks to new constructs introduced in .NET 4.0 and therefore will not run on installations prior to version 4.0. It will, however, run on the client profile subset of .NET 4.<br />\n<h2>Known issues</h2>\r\nThere is potentially a <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/568271/debugger-halting-on-exception-thrown-inside-methodinfo-invoke#details\">bug</a> in Visual Studio 2010 that will cause the debugger to halt on exceptions that occur inside a MethodInfo.Invoke call that should otherwise be caught in code. This presents a problem with hip:Link because of the way WPF evaluates bindings. In particular, WPF may call your definition property/method before its dependencies have been initialized, usually resulting in an exception. In general this is not a problem because as soon as the dependencies are initialized, the definition will be re-evaluated with the proper values, but it may trigger the exception helper when running in debug mode.<br /><br />Do note that this is only a problem when debugging, and should not affect the final program at all. It also does not appear to affect everyone, so you may well be immune to it. I have submitted a <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/568271/debugger-halting-on-exception-thrown-inside-methodinfo-invoke#details\">bug report</a> to Microsoft Connect describing the problem.<br />\n<h3>Workarounds</h3>\r\nIf you are experiencing this problem, one thing to do is to always wrap your hip:Link definitions in try/catch blocks and simply return a harmless value (like null or Binding.DoNothing) from your catch block. Because the exception is caught before it reaches the MethodInfo.Invoke layer, it should prevent the debugger from thinking the exception is unhandled.<br /><br />Another (more convenient) workaround is to disable &quot;Just My Code&quot; in the Visual Studio debugger (Tools -&gt; Options -&gt; Debugging | Enable Just My Code). This seems to work just as well and doesn&#39;t require you to add extraneous try/catch blocks to your code.</div><div class=\"ClearBoth\"></div>",
  "TagList": "",
  "LastEdited": "2011-10-27T09:06:48.577-07:00"
}