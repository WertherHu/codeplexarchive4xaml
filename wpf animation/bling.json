{
  "ProjectName": "bling",
  "Title": "Bling UI Toolkit",
  "Description": "Bling is a library and C#-based language for programming animations, interactions, and visualizations. It is meant for designer/programmers to easily prototype advanced hardware accelerated graphics with DirectX and user interfaces under Windows/WPF. Compare to Flash/Processing.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><a href=\"https://bling.codeplex.com/wikipage?title=Tutorial&referringTitle=Home\">Tutorial Manual</a> | <a href=\"https://bling.codeplex.com/wikipage?title=FAQ&referringTitle=Home\">FAQ</a><br /><br />Bling is a C#-based library for easily programming images, animations, interactions, and visualizations on Microsoft&#39;s WPF/.NET. Bling is oriented towards design technologists, i.e., designers who sometimes program, to aid in the rapid prototyping of rich UI design ideas.  Students, artists, researchers, and hobbyists will also find Bling useful as a tool for quickly expressing ideas or visualizations. Bling&#39;s APIs and constructs are optimized for the fast programming of throw away code as opposed to the careful programming of production code. <br /><br />Bling as the following features that aid in the rapid prototyping of rich UIs:\n<ul><li><b><a href=\"https://bling.codeplex.com/wikipage?title=constraints&referringTitle=Home\">Declarative constraints</a></b> that maintain dynamic relationships in the UI without the need for complex event handling.  For example, <i>button.Width = 100 - slider.Value</i> causes button to shrink as the slider thumb is moved to the right, or grow as it is moved to the left. Constraints have many benefits: they allow rich custom layouts to be expressed with very little code, they are easy animate, and they support UIs with lots of dynamic behavior. </li>\n<li><b><a href=\"https://bling.codeplex.com/wikipage?title=constraints&referringTitle=Home&ANCHOR#animation\">Simplified animation</a></b> with one line of code. For example, <i>button.Left.Animate().Duration(500).To = label.Right</i> will cause button to move to the right of label in 500 milliseconds. </li>\n<li>High-level <b><a href=\"https://bling.codeplex.com/wikipage?title=fungraphics&referringTitle=Home\">functional programming constructs</a></b> for graphics programming including abstractions for <a href=\"https://bling.codeplex.com/wikipage?title=texture&referringTitle=Home\">textures</a>, <a href=\"https://bling.codeplex.com/wikipage?title=pixel%20effect&referringTitle=Home\">pixel effects</a>, <a href=\"https://bling.codeplex.com/wikipage?title=transition&referringTitle=Home\">transitions</a>, <a href=\"https://bling.codeplex.com/wikipage?title=curve&referringTitle=Home\">curves</a>, <a href=\"https://bling.codeplex.com/wikipage?title=surface&referringTitle=Home\">surfaces</a>, <a href=\"https://bling.codeplex.com/wikipage?title=height%20field&referringTitle=Home\">height fields</a>, <a href=\"https://bling.codeplex.com/wikipage?title=normal%20map&referringTitle=Home\">normal maps</a>, and 3D/2.5D <b><a href=\"https://bling.codeplex.com/wikipage?title=lighting&referringTitle=Home\">lighting</a></b>. </li>\n<li>Experimental support for <b><a href=\"https://bling.codeplex.com/wikipage?title=DirectX&referringTitle=Home\">Direct3D 10</a></b> surfaces that are defined by pixel, vertex, and geometry shaders.</li>\n<li><b><a href=\"https://bling.codeplex.com/wikipage?title=shader&referringTitle=Home\">Pixel shader effects</a></b> without the need to write HLSL code or boilerplate code! For example, <i>canvas.Effect.Custom = (input, uv) =&gt; new ColorBl(1d - input[uv].ScRGB, input[uv].ScA);</i> defines and installs a pixel shader on a canvas that inverts the canvas&#39;s colors.  Pixel shading in Bling takes advantage of your graphics card to create rich, pixel-level effects. </li>\n<li>An experimental <b><a href=\"https://bling.codeplex.com/wikipage?title=physics&referringTitle=Home\">UI physics engine</a></b> for integrating physics into user interfaces! The physics supported by Bling is flexible, controllable, and easy to program.  </li>\n<li>A rich library of <b><a href=\"https://bling.codeplex.com/wikipage?title=geometry&referringTitle=Home\">geometry routines</a></b>; e.g., finding where two lines intersect, the base of a triangle, the area of triangle, or a point on Bezier curve. These routines are compatible with all of Bling&#39;s features; e.g., they can be used in express constraints, pixel shaders, or physical constraints. Bling also provides a rich API for manipulating angles in both degrees and radians.</li>\n<li>And many <b>smaller things</b>; e.g., a frame-based background animation manager and slide presentation system.</li>\n<li>As a <b>lightweight wrapper</b> around WPF, Bling code is completely compatible with conventional WPF code written in C#, XAML, or other .NET languages.</li></ul>\n<br /><br />Bling is an open source project created by <a href=\"mailto:sean.mcdirmid@gmail.com\">Sean McDirmid</a> and friends to aid in design rapid prototyping. We used Bling to enhance our productivity and would like to share it with other WPF UI design prototypers.<br />\n<h3>Getting Started</h3>\r\nRequirments: Visual Studio 2008 full or <a href=\"http://www.microsoft.com/express/download/\">Express</a>, <a href=\"http://www.microsoft.com/downloads/details.aspx?FamilyId=333325FD-AE52-4E35-B531-508D977D32A6\">.NET 3.5</a> and <a href=\"http://www.microsoft.com/downloads/details.aspx?familyid=ab99342f-5d1a-413d-8319-81da479ab0d7\">.NET 3.5 SP1</a>, <a href=\"http://www.microsoft.com/downloads/details.aspx?FamilyId=FBEE1648-7106-44A7-9649-6D9F6D58056E\">Visual Studio 2008 SP1</a> (may not be necessary, comes with VS 2008 Express). To support WPF pixel shaders, the <a href=\"http://www.microsoft.com/downloads/details.aspx?displaylang=en&amp;FamilyID=c1367bc3-4676-481a-bfaa-5c15d1d7199d\">DirectX August 2008 runtime</a> is sometimes required, although this is often already installed on your machine.<br /><br />As of Bling 3, DirectX 10 is also supported for Windows Vista and Windows 7 (sorry XP users!). If you want to use DirectX 10, you&#39;ll have to install the latest redistrutable; e.g., the <a href=\"http://www.microsoft.com/downloads/details.aspx?familyid=2DA43D38-DB71-4C1B-BC6A-9B6652CD92A3&amp;displaylang=en\">web installer</a>. Bling also depends on the <a href=\"https://bling.codeplex.com/wikipage?title=http%3a%2f%2fcode.msdn.microsoft.com%2fWindowsAPICodePack&referringTitle=Home\">Windows API Code Pack</a> and the <a href=\"https://bling.codeplex.com/wikipage?title=http%3a%2f%2fwww.codeplex.com%2fdlr&referringTitle=Home\">DLR</a>, but both DLLs are included in the distribution.<br /><br />Download the source release from the web page. An example comes with the release. To include in your own project for WPF development, simply add the Bling.Core and Bling.WPF projects to your solution, and then add a reference to the Bling project from your own project. For DirectX 10 development, add and refer to the Bling.Core, Bling.WPF, and Bling.D3D10 projects.<br />\n<h3>Example</h3>\r\nThe code used in this getting started example is located in the GettingStarted.cs file of the GettingStarted project in the release. We start of this example by creating a <b>thumb</b> and <b>label</b> on a <b>canvas</b>:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\nThumbBl thumb = <span style=\"color:Blue;\">new</span> ThumbBl(canvas) {\n  Background = Brushes.Red,\n  CanDrag = <span style=\"color:Blue;\">true</span>,\n  CenterPosition = canvas.Size - <span style=\"color:Blue;\">new</span> PointBl(20,20),\n  ZIndex = 1,\n};\nLabelBl label = <span style=\"color:Blue;\">new</span> LabelBl(canvas) {\n  Content = <span style=\"color:#A31515;\">&quot;Hello World: &quot;</span>.Bl() + thumb.CenterPosition.ToStringBl(),\n  Font = { Weight = FontWeights.SemiBold, Size = 80, },\n  CenterPosition = canvas.CenterSize,\n};\r\n</pre></div><br />The first statement creates a red <b>thumb</b> that can be dragged (<i>CanDrag = true</i>).  The initial location of the <b>thumb</b> is in the right hand bottom corner of the <b>canvas</b>,<br />while its Z index is set to one.  The second statement creates a <b>label</b> whose content is bound to &quot;Hello World&quot; prepended to the current location of the <b>thumb</b>.  By default,<br />assignments to properties in Bling are <i>contraints</i> where the bound to property will change as the bound-to expression changes.  In our example, the <b>label</b>&#39;s content will change<br />to always reflect the location of the <b>thumb</b>, which you can experience this by moving the <b>thumb</b>. Likewise, the center position of the <b>label</b> is bound to the center of its containing canvas. As the window that contains the canvas is resized, the label is repositioned so that it always remains in the center. <br /><br />Constraints are ubiquitous and incredibly expressive in Bling. Consider another constraint:<br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\nlabel.RenderTransform.Rotate = \n  (thumb.CenterPosition - label.CenterPosition).Angle.ToDegrees();\r\n</pre></div><br />This code rotates the <b>label</b> according to the position of the <b>thumb</b> with respect to the center of the <b>label</b>. A vector from the center of the <b>label</b> is first computed using subtraction, where the vector is then converted into a radian angle (via <i>Angle</i>), which itself is turned into a degree angle (<i>ToDegrees</i>).  The result is that the <b>label</b> rotates as the <b>thumb</b> is moved in a circle around its center.  This example demonstrates the power of Bling constraints: properties can be bound to many kinds of expressions including those that operate over angles.<br /><br />The next piece of code demonstrates how a UI widget can easily undergo custom pixel shading: <br /><br /><div style=\"color:Black;background-color:White;\"><pre>\r\nThumbBl thumbB = <span style=\"color:Blue;\">new</span> ThumbBl(canvas) {\n  Background = Brushes.Blue, LeftTop = <span style=\"color:Blue;\">new</span> PointBl(0,0), CanDrag = <span style=\"color:Blue;\">true</span> \n};\nlabel.Effect.Custom = (input, uv) =&gt; {\n  <span style=\"color:Green;\">/*L1*/</span> PointBl p = label.RenderTransform.Inverse.\n   Transform(thumbB.CenterPosition - label.LeftTop);\n  <span style=\"color:Green;\">/*L2*/</span> PointBl q = uv * label.Size;\n  <span style=\"color:Green;\">/*L3*/</span> DoubleBl d = (p - q).Length;\n  <span style=\"color:Green;\">/*L4*/</span> d = 1 - (d / 500).Min(1);\n  <span style=\"color:Green;\">/*L5*/</span> ColorBl clr = (d).Lerp(Colors.Black, Colors.Blue);\n  <span style=\"color:Green;\">/*L6*/</span> <span style=\"color:Blue;\">return</span> ColorBl.FromScRgb\n    ((input[uv].ScA).Min((1 - (d * d)).Max(.4)), clr.ScRGB);\n};\r\n</pre></div><br />We want to shade the <b>label</b> with respect to the position of <b>thumbB</b>. However, pixel shader effects are applied before render transforms, so we have to transform the position of <b>thumbB</b> with respect to <b>label</b>&#39;s inverse transform, which happens on the first line of the shader (below <i>(input,uv) =&gt; {</i>). Since transforms are relative to the widgets they are applied, we also subtract <b>label</b>&#39;s left top position from <b>thumbB</b>&#39;s center position. <b>uv</b> identifies the  position of the pixel being shaded in term of a percentage rather than in pixels.  So that we can compare <b>uv</b> to the position of <b>thumbB</b>, we multiple it by the size of the label (line two) and then we can find the distance between the two points (line three).  Line four specifies that the circle we care about is 500 pixels in radius, which we then invert so that closer distances are higher in value. Line five uses the result <b>d</b> to interpolate between black and blue colors, which is then used on line six to create the color of the pixel with some modifications to its alpha. <br /><br />The resulting pixel shader executes on the GPU with performance similar to a DirectX pixel shader, and in fact, it is a DirectX pixel shader. Pixel shaders can refer to many UI objects and properties  directly, such as positions, although there are limitations. For example, a pixel shader can refer to a point property but not an enum property, and can refer to an image brush but not a solid color brush (due to limitations enforced by WPF). </div><div class=\"ClearBoth\"></div>",
  "TagList": "WPF,download,Funx,",
  "LastEdited": "2009-10-25T23:22:40.173-07:00"
}