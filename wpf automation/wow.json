{
  "ProjectName": "wow",
  "Title": "WoW - Wpf Over Websockets",
  "Description": "Wpf Over Websockets",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\">\r\n<p>WPF over Websockets is a POC that pumps a WPF element/window over websockets to a browser, and render it using an HTML5 canvas. See the video and related blog post in my blog, @&nbsp;<a href=\"http://www.amazedsaint.com/2011/04/wpf-over-web-sockets-how-to-pump-wpf.html\">http://www.amazedsaint.com/2011/04/wpf-over-web-sockets-how-to-pump-wpf.html</a></p>\r\n<h3>Rendering the image in the browser</h3>\r\n<p>HTML5 draft specification includes Websockets - <a href=\"http://dev.w3.org/html5/websockets/\">\r\nhttp://dev.w3.org/html5/websockets/</a>&nbsp;</p>\r\n<blockquote>\r\n<p><strong>WebSocket</strong> is a technology providing for bi-directional, <a href=\"http://en.wikipedia.org/wiki/Duplex_(telecommunications)#Full-duplex\">\r\nfull-duplex</a> communications channels, over a single <a href=\"http://en.wikipedia.org/wiki/Transmission_Control_Protocol\">\r\nTransmission Control Protocol</a> (TCP) <a href=\"http://en.wikipedia.org/wiki/Internet_socket\">\r\nsocket</a>. It is designed to be implemented in <a href=\"http://en.wikipedia.org/wiki/Web_browser\">\r\nweb browsers</a> and <a href=\"http://en.wikipedia.org/wiki/Web_server\">web servers</a> but it can be used by any client or server application. The WebSocket API is being standardized by the\r\n<a href=\"http://en.wikipedia.org/wiki/World_Wide_Web_Consortium\">W3C</a> and the WebSocket protocol is being standardized by the\r\n<a href=\"http://en.wikipedia.org/wiki/Internet_Engineering_Task_Force\">IETF</a>.</p>\r\n</blockquote>\r\n<p>Here is a pretty minimized implementation of the page that opens a web socket, retrieve the image data, and draws the same on a canvas</p>\r\n<pre>var socket = new WebSocket(&quot;ws://localhost:8181/main&quot;);\nsocket.onopen = function () {\n\n}\n\nsocket.onmessage = function (msg) {\n\tvar canvas = document.getElementById(&quot;canvas&quot;);\n\tvar ctx = canvas.getContext(&quot;2d&quot;);\n\tvar img = new Image;\n\timg.onload = function () {\n\t\tctx.clearRect(0, 0, canvas.width, canvas.height)\n\t\tctx.drawImage(img, 0, 0); // Or at whatever offset you like\n\t};\n\timg.src = &quot;data:image/gif;base64,&quot; &#43; msg.data; ;\n}</pre>\r\n<h3>The server</h3>\r\n<p>I was planning to implement a quick socket server based on draft specifications &ndash; but I found that there are already a couple of .NET based implementations out there. One among them is Nugget -\r\n<a href=\"http://nugget.codeplex.com/\">http://nugget.codeplex.com/</a> &ndash; I&rsquo;m having a thin layer on top of Nugget for creating a window instance when ever a client socket connects to the server.</p>\r\n<pre>\tvar srv = new WebSocketServer(port, origin, &quot;ws://&quot; &#43; server &#43; &quot;:&quot; &#43; port);\n\tsrv.RegisterHandler&lt;ElementSocket&lt;T&gt;&gt;(&quot;/&quot; &#43; name);\n\tsrv.Start();\n\treturn srv;</pre>\r\n<p>Most of the logic required for creating window instances, and pumping them back to the connected client socket goes in my ElementSocket implementation.</p>\r\n</div><div class=\"ClearBoth\"></div>",
  "TagList": "",
  "LastEdited": "2011-04-09T03:46:45.7-07:00"
}