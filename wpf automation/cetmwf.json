{
  "ProjectName": "cetmwf",
  "Title": "Cet MicroWorkflow",
  "Description": "Create your own automation on Netduino in a visual way.",
  "MovedLink": "https://github.com/highfield/cetmwf",
  "HomeWiki": "<div class=\"wikidoc\"><h2>Description</h2>\rCreate your own automation on Netduino in a visual way.<br /><br /><b>Disclaimer:</b> <i>this project and its name has nothing to do with the</i> <a href=\"http://micro-workflow.com/\">http://micro-workflow.com/</a> <i>site.</i><br /><br />Cet MicroWorkflow is a framework layer for creating simple automation on the top of a host .Net application. It currently supports both the standard .Net framework, and the .Net MF.<br /><br /><img src=\"/projects/cetmwf/f6284ac7-5441-4ba7-b008-bea32ca218f3\" alt=\"mwf1sm.jpg\" title=\"mwf1sm.jpg\" /><br /><br />It’s not meant as a replacement of the underlying programming language, but rather a simple and effective way for creating small tasks, which aid the main hosting application. A dedicate engine provide one or more tasks to run, by interpreting runtime the complied workflow designed by the user.<br />The language structure is procedural, similar to Pascal. Several functions are available at the moment of writing, but many more will be added, as well as general improvements.<br />\n<h2>At a glance…</h2>\r\nStructural features:<br />\n<ul><li>Deeply inspired by the <a href=\"http://msdn.microsoft.com/en-us/library/dd489441.aspx\">Windows Workflow Foundation</a>: meant to be a very light, yet flexible platform for small/embedded devices.</li>\n<li>The tasks run on the top of the .Net framework, so that their implementation code can be loaded/unloaded anytime, with absolutely no assembly-gluing.</li>\n<li>No special firmwares are required.</li>\n<li>The tasks run in a “sandbox”, which share a custom interface with the hosting application. This is perfect for keeping the application protected, while the custom tasks can be modified by the user.</li>\n<li>The engine is structured in a functional-fashion: that yields to an easier thread-safe concurrency, for running many tasks simultaneously.</li>\n<li>A compiled task is very compact and easy to transfer, as a simple string is.</li>\n<li>Total independence from the communication channel: the data can be sent via TCP/IP, UART, SPI, etc. Any feasible way for exchanging a string can be used.</li>\n<li>The compiled tasks may be stored in any non-volatile medium, such as SD or EEProm. Afterward, the hosting app could load the right task on-demand.</li></ul>\n<br /><br />Interop features:<br />\n<ul><li>No skilled programming required, nor complicated IDEs. Even Visual Studio is not required. A full-visual approach has been chosen for creating your own tasks.</li>\n<li>The target engine supports the step-by-step remote-debugging of the running tasks (i.e. over the same channel above mentioned). <i>(COMING SOON)</i></li>\n<li>Ability to create your own procedures and functions by using the workflow. <i>(COMING SOON)</i></li>\n<li>Block commenting. <i>(COMING SOON)</i></li>\n<li>Performance (see <a href=\"http://highfieldtales.wordpress.com/2012/09/29/introducing-microworkflow-for-netduino/\">here</a>)</li></ul>\n<br /><br />Known limitations:<br />\n<ul><li>no support for exception yet. <i>(COMING SOON)</i></li>\n<li>no support for arrays yet.</li>\n<li>no support for even trivial literal expressions (e.g. “3+5″), and blocks must be used instead. However, this feature is planned.</li>\n<li>not feasible for specialized/low-level tasks, such as buffers, port handshakings, etc. These features should be exposed by the hosting app interface.</li>\n<li>no overload resolution for generic functions/procedures. However, operators are overloaded.</li></ul>\n<br />\n<h2>The hardware prototype used</h2>\r\n<img src=\"/projects/cetmwf/e26904c3-a149-4543-b7cc-58137936fda1\" alt=\"breadboard&#32;prototype\" title=\"breadboard&#32;prototype\" /><br /><br />Notes:\n<ul><li>the orange wire from Aref to +3.3V is required only for Netduinoes rev. A</li>\n<li>the buttons are shorting to the ground, so that &quot;pressed&quot; yields a &quot;zero&quot;</li>\n<li>the resistor in series to each button needs to protect the port in case of wrong direction (i.e. an output instead of an input)</li>\n<li>the trimpot is used to generate a variable voltage to the analog input: it can be any value from 1k to 100k (suggested 10k)</li></ul>\n<br /><br />Sponsored by:<br /><a href=\"http&#58;&#47;&#47;www.cet-electronics.com\"><img src=\"/projects/cetmwf/a2100b40-3079-4ac4-9063-9bf6ac236499\" alt=\"Cet&#32;Electronics&#32;logo\" title=\"Cet&#32;Electronics&#32;logo\" /></a><br /><br /></div><div class=\"ClearBoth\"></div>",
  "TagList": ".NET Micro Framework,",
  "LastEdited": "2012-10-03T01:28:12.163-07:00"
}