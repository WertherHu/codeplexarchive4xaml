{
  "ProjectName": "aspectize",
  "Title": "NConcern .NET AOP Framework",
  "Description": "NConcern is a .NET runtime AOP (Aspect-Oriented Programming) lightweight framework written in C# that reduces tangling caused by cross-cutting concerns.",
  "MovedLink": "",
  "HomeWiki": "<div class=\"wikidoc\"><i><a href=\"https://github.com/Virtuoze/NConcern\">https://github.com/Virtuoze/NConcern</a></i><br /><i><a href=\"https://www.nuget.org/packages/NConcern\">https://www.nuget.org/packages/NConcern</a></i><br /><br /><b>Version 4.0.2 is available</b>\n<ul><li><i>Version 3.0.0 was just released few days ago but it seems to be too easily affected by CLR mood to use it in production case.</i></li>\n<li><i>All older versions are based on unsafe runtime interception only. This one is based on both compile &amp; runtime mechanism to guarantee code coverage and optimal performance.</i></li>\n<li><i>Core principles is now directly injected into target assembly by third party called CNeptune on which I actively work  : <a href=\"https://github.com/Virtuoze/CNeptune\">https://github.com/Virtuoze/CNeptune</a> &amp; <a href=\"https://www.nuget.org/packages/CNeptune\">https://www.nuget.org/packages/CNeptune</a></i></li>\n<li><i>It wil support all types of methods (virtual, generic, static, constructor, etc...)</i></li>\n<li><i>CNeptune is soon available as a nuget package and will not add an assembly dependency but a build action step to rewrite output assembly and make it more flexible.</i></li>\n<li><i>This major version will not introduce any breaking changes, allow interception without DebuggableAttribute and will be released on or about March 20, 2017.</i></li></ul>\n\n<hr />\n<br /><b>Description</b><br />NConcern is a .NET runtime AOP &#40;Aspect-Oriented Programming&#41; lightweight framework written in C&#35; that reduces tangling caused by cross-cutting concerns. Its role is to introduce Aspect-Oriented Programming paradigm with a minimum cost to maximize quality and productivity.<br /><br /><b>Features</b><br />NConcern AOP Framework is based on code injection at runtime. \n<ul><li><b>non-intrusive</b> : no need to change the source code or the publishing process.</li>\n<li><b>friendly</b> : delegates, expressions (linq) or CIL (ILGenerator) can be used to define an aspect</li>\n<li><b>no configuration</b> : additional configuration files are not required</li>\n<li><b>no proxy</b> : decoration by inheritance and factory pattern are not required </li>\n<li><b>low learning curve</b> : get started under 20 minutes</li>\n<li><b>no installer</b> : single .net library (.dll) to reference</li>\n<li><b>suited for unit testing</b> : weaving is controlled at runtime</li>\n<li><b>low performance overhead</b> : injection mechanic is built to be efficient</li>\n<li><b>limitless</b> : everything (constructors included) except generic methods is supported (coming with next release)</li>\n<li><b>runtime lifecycle</b> : aspect can be updated/created/removed at runtime</li></ul>\n<br /><b>Aspect</b><br />An aspect represents a set of features related to a specific concern. The role of an aspect is to provide advices for method. It can be added and removed at runtime.<br /><br /><b>Advice</b><br />An advice is the code added by an aspect to complete a method. It can be implemented using delegate, expression or CIL generation.<br />\n<ul><li><b>Before</b> : runs before method execution</li>\n<li><b>After</b> : runs after method execution regardless of its outcome</li>\n<li><b>After.Returning</b> : runs after method execution only if it completes sucessfully</li>\n<li><b>After.Throwing</b> : runs after method execution only if it exits by throwing an exception</li>\n<li><b>Around</b> : runs around method execution</li></ul>\n\n<hr />\n<br /><b>Example</b><br />\n<ul><li>Use case :</li></ul>\n<pre>\nI want to trace my service calls with &quot;Console.WriteLine&quot;.\nMy services are OperationContract typed (WCF service)\n</pre><br />\n<ul><li>Disable compilation and JIT inlining by placing Debuggable attribute in AssemblyInfo.cs</li></ul>\n<pre>\n[assembly: System.Diagnostics.Debuggable(true, true)]\n</pre><br />\n<ul><li>Calculator : WCF service</li></ul>\n<pre>\n[ServiceContract]\npublic class Calculator\n{\n    [OperationContract]\n    public int Add(int a, int b)\n    {\n       return a + b;\n    }\n}\n</pre><br />\n<ul><li>Tracer : simple tracer to log into Console</li></ul>\n<pre>\nstatic public class Tracer\n{\n    static public void Trace(MethodBase method, object[] arguments)\n    {\n        Console.WriteLine(&quot;{0}({1})&quot;, method.Name, string.Join(&quot;, &quot;, arguments));\n    }\n}\n</pre><br />\n<ul><li>Logging (Aspect) : define how &quot;Tracer&quot; can be injected into a method</li></ul>\n<pre>\npublic class Logging : IAspect\n{\n    public IEnumerable&lt;IAdvice&gt; Advise(MethodBase method)\n    {\n        yield return Advice.Basic.Before((instance, arguments) =&gt; \n        {\n            Tracer.Trace(method, arguments);\n        });\n    }\n}\n</pre><br />\n<ul><li>Enable logging for services using implicit joinpoint</li></ul>\n<pre>\nAspect.Weave&lt;Logging&gt;(typeof(OperationContractAttriute));\n</pre><br />\n<ul><li>Disable logging for services using implicit joinpoint</li></ul>\n<pre>\nAspect.Release&lt;Logging&gt;(typeof(OperationContractAttriute));\n</pre><br />\n<hr />\n<br /><b>FAQ</b><br />\n<ul><li>How this AOP Framework is different from the others?</li></ul>\n<i>Most of time developping cross-cutting source code required reflection and boxing to be done. NConcern offer a way to define it using Linq Expressions or ILGenerator because cross-cutting source code have to manage not statically known datas. No need factory and no need base class is the second exclusive feature that make the difference because interception is i not based on method overriding or ContextBoundObject.</i><br />\n<ul><li>How fast is &quot;low performance overhead&quot;?</li></ul>\n<i>For real there is no overhead when Linq Expressions or ILGenerator are used. Basic advice introduce a light overhead caused by boxing and arguments array creation. However, MethodInfo is not prepared if capture in not required in lambda expression.</i><br />\n<ul><li>Why I have to use DebuggableAttribute?</li></ul>\n<i>Interception is based on method swaping and cannot be applied when JIT or compiler optimize a call by inlining. The DebuggableAttribute is an acceptable way to disable inlining without being to much intrusive. You are free to do it by another way (MethodImplAttribute for example) but keep in mind that only non virtual methods can be inlined.</i><br />\n<ul><li>Can I add multiple aspect for same target? if yes how can I control priority?</li></ul>\n<i>Yes you can. Priority is defined by the order of weaving. It can be reorganized by calling Aspect.Release(...)/Aspect.Weave(...) and you can check the whole aspects mapping by calling Aspect.Lookup(...)</i><br />\n<ul><li>Is an attribute required to identify a mehod to weave?</li></ul>\n<i>No you can identify a method by the way you want. There is a Aspect.Weave(...) overload that take a Func&lt;MethodInfo, bool&gt; to select methods.</i><br />\n<ul><li>Can I intercept constructor? If yes, how do I implement it? </li></ul>\n<i>Constructor interception is supported and is treated like another method with declaring type as first argument and void for return type.</i><br />\n<hr />\n<br /></div><div class=\"ClearBoth\"></div>",
  "TagList": ".NET,C#,AOP,automation,IOC,DI,Runtime,IL,CIL,Injection,instrumentation,interception,.NET 4.0,Decoration,AOP.net,AOP .NET,",
  "LastEdited": "2017-03-30T15:28:06.62-07:00"
}